{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository hug aims to make developing Python driven APIs as simple as possible, but no simpler. As a result, it drastically simplifies Python API development. hug's Design Objectives: Make developing a Python driven API as succinct as a written definition. The framework should encourage code that self-documents. It should be fast. A developer should never feel the need to look somewhere else for performance reasons. Writing tests for APIs written on-top of hug should be easy and intuitive. Magic done once, in an API framework, is better than pushing the problem set to the user of the API framework. Be the basis for next generation Python APIs, embracing the latest technology. As a result of these goals, hug is Python 3+ only and built upon Falcon's high performance HTTP library Supporting hug development Get professionally supported hug with the Tidelift Subscription Professional support for hug is available as part of the Tidelift Subscription . Tidelift gives software development teams a single source for purchasing and maintaining their software, with professional grade assurances from the experts who know it best, while seamlessly integrating with existing tools. Installing hug Installing hug is as simple as: pip3 install hug --upgrade Ideally, within a virtual environment . Getting Started Build an example API with a simple endpoint in just a few lines. # filename: happy_birthday.py \"\"\"A basic (single function) API written using hug\"\"\" import hug @hug.get ( '/happy_birthday' ) def happy_birthday ( name , age : hug . types . number = 1 ): \"\"\"Says happy birthday to a user\"\"\" return \"Happy {age} Birthday {name}!\" . format ( ** locals ()) To run, from the command line type: hug -f happy_birthday.py You can access the example in your browser at: localhost:8000/happy_birthday?name=hug&age=1 . Then check out the documentation for your API at localhost:8000/documentation Parameters can also be encoded in the URL (check out happy_birthday.py for the whole example). @hug.get ( '/greet/{event}' ) def greet ( event : str ): \"\"\"Greets appropriately (from http://blog.ketchum.com/how-to-write-10-common-holiday-greetings/) \"\"\" greetings = \"Happy\" if event == \"Christmas\" : greetings = \"Merry\" if event == \"Kwanzaa\" : greetings = \"Joyous\" if event == \"wishes\" : greetings = \"Warm\" return \"{greetings} {event}!\" . format ( ** locals ()) Which, once you are running the server as above, you can use this way: curl http : // localhost : 8000 / greet / wishes \"Warm wishes!\" Versioning with hug # filename: versioning_example.py \"\"\"A simple example of a hug API call with versioning\"\"\" import hug @hug.get ( '/echo' , versions = 1 ) def echo ( text ): return text @hug.get ( '/echo' , versions = range ( 2 , 5 )) def echo ( text ): return \"Echo: {text}\" . format ( ** locals ()) To run the example: hug -f versioning_example.py Then you can access the example from localhost:8000/v1/echo?text=Hi / localhost:8000/v2/echo?text=Hi Or access the documentation for your API from localhost:8000 Note: versioning in hug automatically supports both the version header as well as direct URL based specification. Testing hug APIs hug's http method decorators don't modify your original functions. This makes testing hug APIs as simple as testing any other Python functions. Additionally, this means interacting with your API functions in other Python code is as straight forward as calling Python only API functions. hug makes it easy to test the full Python stack of your API by using the hug.test module: import hug import happy_birthday hug . test . get ( happy_birthday , 'happy_birthday' , { 'name' : 'Timothy' , 'age' : 25 }) # Returns a Response object You can use this Response object for test assertions (check out test_happy_birthday.py ): def tests_happy_birthday (): response = hug . test . get ( happy_birthday , 'happy_birthday' , { 'name' : 'Timothy' , 'age' : 25 }) assert response . status == HTTP_200 assert response . data is not None Running hug with other WSGI based servers hug exposes a __hug_wsgi__ magic method on every API module automatically. Running your hug based API on any standard wsgi server should be as simple as pointing it to module_name : __hug_wsgi__ . For Example: uwsgi --http 0 .0.0.0:8000 --wsgi-file examples/hello_world.py --callable __hug_wsgi__ To run the hello world hug example API. Building Blocks of a hug API When building an API using the hug framework you'll use the following concepts: METHOD Decorators get , post , update , etc HTTP method decorators that expose your Python function as an API while keeping your Python method unchanged @hug.get () # <- Is the hug METHOD decorator def hello_world (): return \"Hello\" hug uses the structure of the function you decorate to automatically generate documentation for users of your API. hug always passes a request, response, and api_version variable to your function if they are defined params in your function definition. Type Annotations functions that optionally are attached to your methods arguments to specify how the argument is validated and converted into a Python type @hug.get () def math ( number_1 : int , number_2 : int ): #The :int after both arguments is the Type Annotation return number_1 + number_2 Type annotations also feed into hug 's automatic documentation generation to let users of your API know what data to supply. Directives functions that get executed with the request / response data based on being requested as an argument in your api_function. These apply as input parameters only, and can not be applied currently as output formats or transformations. @hug.get () def test_time ( hug_timer ): return { 'time_taken' : float ( hug_timer )} Directives may be accessed via an argument with a hug_ prefix, or by using Python 3 type annotations. The latter is the more modern approach, and is recommended. Directives declared in a module can be accessed by using their fully qualified name as the type annotation (ex: module.directive_name ). Aside from the obvious input transformation use case, directives can be used to pipe data into your API functions, even if they are not present in the request query string, POST body, etc. For an example of how to use directives in this way, see the authentication example in the examples folder. Adding your own directives is straight forward: @hug.directive () def square ( value = 1 , ** kwargs ): '''Returns passed in parameter multiplied by itself''' return value * value @hug.get () @hug.local () def tester ( value : square = 10 ): return value tester () == 100 For completeness, here is an example of accessing the directive via the magic name approach: @hug.directive () def multiply ( value = 1 , ** kwargs ): '''Returns passed in parameter multiplied by itself''' return value * value @hug.get () @hug.local () def tester ( hug_multiply = 10 ): return hug_multiply tester () == 100 Output Formatters a function that takes the output of your API function and formats it for transport to the user of the API. @hug.default_output_format () def my_output_formatter ( data ): return \"STRING:{0}\" . format ( data ) @hug.get ( output = hug . output_format . json ) def hello (): return { 'hello' : 'world' } as shown, you can easily change the output format for both an entire API as well as an individual API call Input Formatters a function that takes the body of data given from a user of your API and formats it for handling. @hug.default_input_format ( \"application/json\" ) def my_input_formatter ( data ): return ( 'Results' , hug . input_format . json ( data )) Input formatters are mapped based on the content_type of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your api_function Middleware functions that get called for every request a hug API processes @hug.request_middleware () def process_data ( request , response ): request . env [ 'SERVER_NAME' ] = 'changed' @hug.response_middleware () def process_data ( request , response , resource ): response . set_header ( 'MyHeader' , 'Value' ) You can also easily add any Falcon style middleware using: __hug__ . http . add_middleware ( MiddlewareObject ()) Parameter mapping can be used to override inferred parameter names, eg. for reserved keywords: import marshmallow.fields as fields ... @hug.get ( '/foo' , map_params = { 'from' : 'from_date' }) # API call uses 'from' def get_foo_by_date ( from_date : fields . DateTime ()): return find_foo ( from_date ) Input formatters are mapped based on the content_type of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your api_function Splitting APIs over multiple files hug enables you to organize large projects in any manner you see fit. You can import any module that contains hug decorated functions (request handling, directives, type handlers, etc) and extend your base API with that module. For example: something.py import hug @hug.get ( '/' ) def say_hi (): return 'hello from something' Can be imported into the main API file: __init__.py import hug from . import something @hug.get ( '/' ) def say_hi (): return \"Hi from root\" @hug.extend_api ( '/something' ) def something_api (): return [ something ] Or alternatively - for cases like this - where only one module is being included per a URL route: #alternatively hug . API ( __name__ ) . extend ( something , '/something' ) Configuring hug 404 By default, hug returns an auto generated API spec when a user tries to access an endpoint that isn't defined. If you would not like to return this spec you can turn off 404 documentation: From the command line application: hug -nd -f { file } #nd flag tells hug not to generate documentation on 404 Additionally, you can easily create a custom 404 handler using the hug.not_found decorator: @hug.not_found () def not_found_handler (): return \"Not Found\" This decorator works in the same manner as the hug HTTP method decorators, and is even version aware: @hug.not_found ( versions = 1 ) def not_found_handler (): return \"\" @hug.not_found ( versions = 2 ) def not_found_handler (): return \"Not Found\" Asyncio support When using the get and cli method decorator on coroutines, hug will schedule the execution of the coroutine. Using asyncio coroutine decorator @hug.get () @asyncio.coroutine def hello_world (): return \"Hello\" Using Python 3.5 async keyword. @hug.get () async def hello_world (): return \"Hello\" NOTE: Hug is running on top Falcon which is not an asynchronous server. Even if using asyncio, requests will still be processed synchronously. Using Docker If you like to develop in Docker and keep your system clean, you can do that but you'll need to first install Docker Compose . Once you've done that, you'll need to cd into the docker directory and run the web server (Gunicorn) specified in ./docker/gunicorn/Dockerfile , after which you can preview the output of your API in the browser on your host machine. $ cd ./docker # This will run Gunicorn on port 8000 of the Docker container. $ docker-compose up gunicorn # From the host machine, find your Dockers IP address. # For Windows & Mac: $ docker-machine ip default # For Linux: $ ifconfig docker0 | grep 'inet' | cut -d: -f2 | awk '{ print $1}' | head -n1 By default, the IP is 172.17.0.1. Assuming that's the IP you see, as well, you would then go to http://172.17.0.1:8000/ in your browser to view your API. You can also log into a Docker container that you can consider your work space. This workspace has Python and Pip installed so you can use those tools within Docker. If you need to test the CLI interface, for example, you would use this. $ docker-compose run workspace bash On your Docker workspace container, the ./docker/templates directory on your host computer is mounted to /src in the Docker container. This is specified under services > app of ./docker/docker-compose.yml . bash-4.3# cd /src bash-4.3# tree . \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 handlers \u251c\u2500\u2500 birthday.py \u2514\u2500\u2500 hello.py 1 directory, 3 files Security contact information hug takes security and quality seriously. This focus is why we depend only on thoroughly tested components and utilize static analysis tools (such as bandit and safety) to verify the security of our code base. If you find or encounter any potential security issues, please let us know right away so we can resolve them. To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure. Why hug? HUG simply stands for Hopefully Useful Guide. This represents the project's goal to help guide developers into creating well written and intuitive APIs. Thanks and I hope you find this hug helpful as you develop your next Python API! ~Timothy Crosley","title":"Home"},{"location":"#supporting-hug-development","text":"Get professionally supported hug with the Tidelift Subscription Professional support for hug is available as part of the Tidelift Subscription . Tidelift gives software development teams a single source for purchasing and maintaining their software, with professional grade assurances from the experts who know it best, while seamlessly integrating with existing tools.","title":"Supporting hug development"},{"location":"#installing-hug","text":"Installing hug is as simple as: pip3 install hug --upgrade Ideally, within a virtual environment .","title":"Installing hug"},{"location":"#getting-started","text":"Build an example API with a simple endpoint in just a few lines. # filename: happy_birthday.py \"\"\"A basic (single function) API written using hug\"\"\" import hug @hug.get ( '/happy_birthday' ) def happy_birthday ( name , age : hug . types . number = 1 ): \"\"\"Says happy birthday to a user\"\"\" return \"Happy {age} Birthday {name}!\" . format ( ** locals ()) To run, from the command line type: hug -f happy_birthday.py You can access the example in your browser at: localhost:8000/happy_birthday?name=hug&age=1 . Then check out the documentation for your API at localhost:8000/documentation Parameters can also be encoded in the URL (check out happy_birthday.py for the whole example). @hug.get ( '/greet/{event}' ) def greet ( event : str ): \"\"\"Greets appropriately (from http://blog.ketchum.com/how-to-write-10-common-holiday-greetings/) \"\"\" greetings = \"Happy\" if event == \"Christmas\" : greetings = \"Merry\" if event == \"Kwanzaa\" : greetings = \"Joyous\" if event == \"wishes\" : greetings = \"Warm\" return \"{greetings} {event}!\" . format ( ** locals ()) Which, once you are running the server as above, you can use this way: curl http : // localhost : 8000 / greet / wishes \"Warm wishes!\"","title":"Getting Started"},{"location":"#versioning-with-hug","text":"# filename: versioning_example.py \"\"\"A simple example of a hug API call with versioning\"\"\" import hug @hug.get ( '/echo' , versions = 1 ) def echo ( text ): return text @hug.get ( '/echo' , versions = range ( 2 , 5 )) def echo ( text ): return \"Echo: {text}\" . format ( ** locals ()) To run the example: hug -f versioning_example.py Then you can access the example from localhost:8000/v1/echo?text=Hi / localhost:8000/v2/echo?text=Hi Or access the documentation for your API from localhost:8000 Note: versioning in hug automatically supports both the version header as well as direct URL based specification.","title":"Versioning with hug"},{"location":"#testing-hug-apis","text":"hug's http method decorators don't modify your original functions. This makes testing hug APIs as simple as testing any other Python functions. Additionally, this means interacting with your API functions in other Python code is as straight forward as calling Python only API functions. hug makes it easy to test the full Python stack of your API by using the hug.test module: import hug import happy_birthday hug . test . get ( happy_birthday , 'happy_birthday' , { 'name' : 'Timothy' , 'age' : 25 }) # Returns a Response object You can use this Response object for test assertions (check out test_happy_birthday.py ): def tests_happy_birthday (): response = hug . test . get ( happy_birthday , 'happy_birthday' , { 'name' : 'Timothy' , 'age' : 25 }) assert response . status == HTTP_200 assert response . data is not None","title":"Testing hug APIs"},{"location":"#running-hug-with-other-wsgi-based-servers","text":"hug exposes a __hug_wsgi__ magic method on every API module automatically. Running your hug based API on any standard wsgi server should be as simple as pointing it to module_name : __hug_wsgi__ . For Example: uwsgi --http 0 .0.0.0:8000 --wsgi-file examples/hello_world.py --callable __hug_wsgi__ To run the hello world hug example API.","title":"Running hug with other WSGI based servers"},{"location":"#building-blocks-of-a-hug-api","text":"When building an API using the hug framework you'll use the following concepts: METHOD Decorators get , post , update , etc HTTP method decorators that expose your Python function as an API while keeping your Python method unchanged @hug.get () # <- Is the hug METHOD decorator def hello_world (): return \"Hello\" hug uses the structure of the function you decorate to automatically generate documentation for users of your API. hug always passes a request, response, and api_version variable to your function if they are defined params in your function definition. Type Annotations functions that optionally are attached to your methods arguments to specify how the argument is validated and converted into a Python type @hug.get () def math ( number_1 : int , number_2 : int ): #The :int after both arguments is the Type Annotation return number_1 + number_2 Type annotations also feed into hug 's automatic documentation generation to let users of your API know what data to supply. Directives functions that get executed with the request / response data based on being requested as an argument in your api_function. These apply as input parameters only, and can not be applied currently as output formats or transformations. @hug.get () def test_time ( hug_timer ): return { 'time_taken' : float ( hug_timer )} Directives may be accessed via an argument with a hug_ prefix, or by using Python 3 type annotations. The latter is the more modern approach, and is recommended. Directives declared in a module can be accessed by using their fully qualified name as the type annotation (ex: module.directive_name ). Aside from the obvious input transformation use case, directives can be used to pipe data into your API functions, even if they are not present in the request query string, POST body, etc. For an example of how to use directives in this way, see the authentication example in the examples folder. Adding your own directives is straight forward: @hug.directive () def square ( value = 1 , ** kwargs ): '''Returns passed in parameter multiplied by itself''' return value * value @hug.get () @hug.local () def tester ( value : square = 10 ): return value tester () == 100 For completeness, here is an example of accessing the directive via the magic name approach: @hug.directive () def multiply ( value = 1 , ** kwargs ): '''Returns passed in parameter multiplied by itself''' return value * value @hug.get () @hug.local () def tester ( hug_multiply = 10 ): return hug_multiply tester () == 100 Output Formatters a function that takes the output of your API function and formats it for transport to the user of the API. @hug.default_output_format () def my_output_formatter ( data ): return \"STRING:{0}\" . format ( data ) @hug.get ( output = hug . output_format . json ) def hello (): return { 'hello' : 'world' } as shown, you can easily change the output format for both an entire API as well as an individual API call Input Formatters a function that takes the body of data given from a user of your API and formats it for handling. @hug.default_input_format ( \"application/json\" ) def my_input_formatter ( data ): return ( 'Results' , hug . input_format . json ( data )) Input formatters are mapped based on the content_type of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your api_function Middleware functions that get called for every request a hug API processes @hug.request_middleware () def process_data ( request , response ): request . env [ 'SERVER_NAME' ] = 'changed' @hug.response_middleware () def process_data ( request , response , resource ): response . set_header ( 'MyHeader' , 'Value' ) You can also easily add any Falcon style middleware using: __hug__ . http . add_middleware ( MiddlewareObject ()) Parameter mapping can be used to override inferred parameter names, eg. for reserved keywords: import marshmallow.fields as fields ... @hug.get ( '/foo' , map_params = { 'from' : 'from_date' }) # API call uses 'from' def get_foo_by_date ( from_date : fields . DateTime ()): return find_foo ( from_date ) Input formatters are mapped based on the content_type of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your api_function","title":"Building Blocks of a hug API"},{"location":"#splitting-apis-over-multiple-files","text":"hug enables you to organize large projects in any manner you see fit. You can import any module that contains hug decorated functions (request handling, directives, type handlers, etc) and extend your base API with that module. For example: something.py import hug @hug.get ( '/' ) def say_hi (): return 'hello from something' Can be imported into the main API file: __init__.py import hug from . import something @hug.get ( '/' ) def say_hi (): return \"Hi from root\" @hug.extend_api ( '/something' ) def something_api (): return [ something ] Or alternatively - for cases like this - where only one module is being included per a URL route: #alternatively hug . API ( __name__ ) . extend ( something , '/something' )","title":"Splitting APIs over multiple files"},{"location":"#configuring-hug-404","text":"By default, hug returns an auto generated API spec when a user tries to access an endpoint that isn't defined. If you would not like to return this spec you can turn off 404 documentation: From the command line application: hug -nd -f { file } #nd flag tells hug not to generate documentation on 404 Additionally, you can easily create a custom 404 handler using the hug.not_found decorator: @hug.not_found () def not_found_handler (): return \"Not Found\" This decorator works in the same manner as the hug HTTP method decorators, and is even version aware: @hug.not_found ( versions = 1 ) def not_found_handler (): return \"\" @hug.not_found ( versions = 2 ) def not_found_handler (): return \"Not Found\"","title":"Configuring hug 404"},{"location":"#asyncio-support","text":"When using the get and cli method decorator on coroutines, hug will schedule the execution of the coroutine. Using asyncio coroutine decorator @hug.get () @asyncio.coroutine def hello_world (): return \"Hello\" Using Python 3.5 async keyword. @hug.get () async def hello_world (): return \"Hello\" NOTE: Hug is running on top Falcon which is not an asynchronous server. Even if using asyncio, requests will still be processed synchronously.","title":"Asyncio support"},{"location":"#using-docker","text":"If you like to develop in Docker and keep your system clean, you can do that but you'll need to first install Docker Compose . Once you've done that, you'll need to cd into the docker directory and run the web server (Gunicorn) specified in ./docker/gunicorn/Dockerfile , after which you can preview the output of your API in the browser on your host machine. $ cd ./docker # This will run Gunicorn on port 8000 of the Docker container. $ docker-compose up gunicorn # From the host machine, find your Dockers IP address. # For Windows & Mac: $ docker-machine ip default # For Linux: $ ifconfig docker0 | grep 'inet' | cut -d: -f2 | awk '{ print $1}' | head -n1 By default, the IP is 172.17.0.1. Assuming that's the IP you see, as well, you would then go to http://172.17.0.1:8000/ in your browser to view your API. You can also log into a Docker container that you can consider your work space. This workspace has Python and Pip installed so you can use those tools within Docker. If you need to test the CLI interface, for example, you would use this. $ docker-compose run workspace bash On your Docker workspace container, the ./docker/templates directory on your host computer is mounted to /src in the Docker container. This is specified under services > app of ./docker/docker-compose.yml . bash-4.3# cd /src bash-4.3# tree . \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 handlers \u251c\u2500\u2500 birthday.py \u2514\u2500\u2500 hello.py 1 directory, 3 files","title":"Using Docker"},{"location":"#security-contact-information","text":"hug takes security and quality seriously. This focus is why we depend only on thoroughly tested components and utilize static analysis tools (such as bandit and safety) to verify the security of our code base. If you find or encounter any potential security issues, please let us know right away so we can resolve them. To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure.","title":"Security contact information"},{"location":"#why-hug","text":"HUG simply stands for Hopefully Useful Guide. This represents the project's goal to help guide developers into creating well written and intuitive APIs. Thanks and I hope you find this hug helpful as you develop your next Python API! ~Timothy Crosley","title":"Why hug?"},{"location":"ACKNOWLEDGEMENTS/","text":"Core Developers Timothy Edmund Crosley (@timothycrosley) Brandon Hoffman (@BrandonHoffman) Jason Tyler (@jay-tyler) Fabian Kochem (@vortec) Notable Bug Reporters Michael Buckner (@michaelbuckner) Carl Neuhaus (@carlneuhaus) Eirik Rye (@eirikrye) Matteo Bertini (@naufraghi) Erwin Haasnoot (@ErwinHaasnoot) Aris Pikeas (@pikeas) Code Contributors Kostas Dizas (@kostasdizas) Ali-Akber Saifee (@alisaifee) @arpesenti Eirik Rye (@eirikrye) Matteo Bertini (@naufraghi) Trevor Scheitrum (@trevorscheitrum) Ian Wagner (@ianthetechie) Erwin Haasnoot (@ErwinHaasnoot) Kirk Leon Guerrero (@kirklg) Ergo_ (@johnlam) Rodrigue Cloutier (@rodcloutier) KhanhIceTea (@khanhicetea) Prashant Sinha (@PrashntS) Alan Lu (@cag) Soloman Weng (@soloman1124) Evan Owen (@thatGuy0923) Gemedet (@gemedet) Garrett Squire (@gsquire) Ha\u00efkel Gu\u00e9mar (@hguemar) Eshin Kunishima (@mikoim) Mike Adams (@mikeadamz) Michal Bultrowicz (@butla) Bogdan (@spock) @banteg Philip Bjorge (@philipbjorge) Daniel Metz (@danielmmetz) Alessandro Amici (@alexamici) Trevor Bekolay (@tbekolay) Elijah Wilson (@tizz98) Chelsea Dole (@chelseadole) Antti Kaihola (@akaihola) Christopher Goes (@GhostOfGoes) Stanislav (@atmo) Lordran (@xzycn) Stephan Fitzpatrick (@knowsuchagency) Edvard Majakari (@EdvardM) Documenters Timothy Cyrus (@tcyrus) M.Yasoob Ullah Khalid (@yasoob) Lionel Montrieux (@lmontrieux) Ian Wagner (@ianthetechie) Andrew Murray (@radarhere) Tim (@timlyo) Sven-Hendrik Haase (@svenstaro) Matt Caldwell (@mattcaldwell) berdario (@berdario) Cory Taylor (@coryandrewtaylor) James C. (@JamesMCo) Ally Weir (@allyjweir) Steven Loria (@sloria) Patrick Abeya (@wombat2k) Ergo_ (@johnlam) Adeel Khan (@adeel) Benjamin Williams (@benjaminjosephw) @gdw2 Thierry Colsenet (@ThierryCols) Shawn Q Jackson (@gt50) Bernhard E. Reiter (@bernhardreiter) Adam McCarthy (@mccajm) Sobolev Nikita (@sobolevn) Chris (@ckhrysze) Amanda Crosley (@waddlelikeaduck) Chelsea Dole (@chelseadole) Joshua Crowgey (@jcrowgey) Antti Kaihola (@akaihola) Simon Ince (@Simon-Ince) Edvard Majakari (@EdvardM) A sincere thanks to everyone who has helped make hug the great Python3 project it is today! ~Timothy Crosley","title":"Acknowledgements"},{"location":"ACKNOWLEDGEMENTS/#core-developers","text":"Timothy Edmund Crosley (@timothycrosley) Brandon Hoffman (@BrandonHoffman) Jason Tyler (@jay-tyler) Fabian Kochem (@vortec)","title":"Core Developers"},{"location":"ACKNOWLEDGEMENTS/#notable-bug-reporters","text":"Michael Buckner (@michaelbuckner) Carl Neuhaus (@carlneuhaus) Eirik Rye (@eirikrye) Matteo Bertini (@naufraghi) Erwin Haasnoot (@ErwinHaasnoot) Aris Pikeas (@pikeas)","title":"Notable Bug Reporters"},{"location":"ACKNOWLEDGEMENTS/#code-contributors","text":"Kostas Dizas (@kostasdizas) Ali-Akber Saifee (@alisaifee) @arpesenti Eirik Rye (@eirikrye) Matteo Bertini (@naufraghi) Trevor Scheitrum (@trevorscheitrum) Ian Wagner (@ianthetechie) Erwin Haasnoot (@ErwinHaasnoot) Kirk Leon Guerrero (@kirklg) Ergo_ (@johnlam) Rodrigue Cloutier (@rodcloutier) KhanhIceTea (@khanhicetea) Prashant Sinha (@PrashntS) Alan Lu (@cag) Soloman Weng (@soloman1124) Evan Owen (@thatGuy0923) Gemedet (@gemedet) Garrett Squire (@gsquire) Ha\u00efkel Gu\u00e9mar (@hguemar) Eshin Kunishima (@mikoim) Mike Adams (@mikeadamz) Michal Bultrowicz (@butla) Bogdan (@spock) @banteg Philip Bjorge (@philipbjorge) Daniel Metz (@danielmmetz) Alessandro Amici (@alexamici) Trevor Bekolay (@tbekolay) Elijah Wilson (@tizz98) Chelsea Dole (@chelseadole) Antti Kaihola (@akaihola) Christopher Goes (@GhostOfGoes) Stanislav (@atmo) Lordran (@xzycn) Stephan Fitzpatrick (@knowsuchagency) Edvard Majakari (@EdvardM)","title":"Code Contributors"},{"location":"ACKNOWLEDGEMENTS/#documenters","text":"Timothy Cyrus (@tcyrus) M.Yasoob Ullah Khalid (@yasoob) Lionel Montrieux (@lmontrieux) Ian Wagner (@ianthetechie) Andrew Murray (@radarhere) Tim (@timlyo) Sven-Hendrik Haase (@svenstaro) Matt Caldwell (@mattcaldwell) berdario (@berdario) Cory Taylor (@coryandrewtaylor) James C. (@JamesMCo) Ally Weir (@allyjweir) Steven Loria (@sloria) Patrick Abeya (@wombat2k) Ergo_ (@johnlam) Adeel Khan (@adeel) Benjamin Williams (@benjaminjosephw) @gdw2 Thierry Colsenet (@ThierryCols) Shawn Q Jackson (@gt50) Bernhard E. Reiter (@bernhardreiter) Adam McCarthy (@mccajm) Sobolev Nikita (@sobolevn) Chris (@ckhrysze) Amanda Crosley (@waddlelikeaduck) Chelsea Dole (@chelseadole) Joshua Crowgey (@jcrowgey) Antti Kaihola (@akaihola) Simon Ince (@Simon-Ince) Edvard Majakari (@EdvardM) A sincere thanks to everyone who has helped make hug the great Python3 project it is today! ~Timothy Crosley","title":"Documenters"},{"location":"ARCHITECTURE/","text":"The guiding thought behind the architecture hug is the cleanest way to create HTTP REST APIs on Python 3. It consistently benchmarks among the top 3 performing web frameworks for Python, handily beating out Flask and Django. For almost every common Web API task the code written to accomplish it in hug is a small fraction of what is required in other Frameworks. However, it's important to note, hug is not a Web API Framework. OK--that certainly is a function it performs. And exceptionally well at that. But at its core, hug is a framework for exposing idiomatically correct and standard internal Python APIs externally. A framework to allow developers and architects to define logic and structure once, and then cleanly expose it over other means. Currently, this means that you can expose existing Python functions / APIs over HTTP and CLI in addition to standard Python. However, as time goes on more interfaces will be supported. The architecture and implementation decisions that have gone into hug have and will continue to support this goal. This central concept also frees hug to rely on the fastest and best of breed components for every interface it supports: Falcon is leveraged when exposing to HTTP for its impressive performance at this task Argparse is leveraged when exposing to CLI for the clean consistent interaction it enables from the command line What this looks like in practice - an illustrative example Let's say I have a very simple Python API I've built to add 2 numbers together. I call my invention addition . Trust me, this is legit. It's trademarked and everything: \"\"\"A simple API to enable adding two numbers together\"\"\" def add ( number_1 , number_2 ): \"\"\"Returns the result of adding number_1 to number_2\"\"\" return number_1 + number_2 It works, it's well documented, and it's clean. Several people are already importing and using my Python module for their math needs. However, there's a great injustice! I'm lazy, and I don't want to open a Python interpreter etc to access my function. Here's how I modify it to expose it via the command line: \"\"\"A simple API to enable adding two numbers together\"\"\" import hug @hug.cli () def add ( number_1 : hug . types . number , number_2 : hug . types . number ): \"\"\"Returns the result of adding number_1 to number_2\"\"\" return number_1 + number_2 if __name__ == '__main__' : add . interface . cli () Yay! Now I can just do my math from the command line using: add.py $NUMBER_1 $NUMBER_2 . And even better, if I miss an argument it lets me know what it is and how to fix my error. The thing I immediately notice, is that my new command line interface works, it's well documented, and it's clean. Just like the original. However, users are not satisfied. I keep updating my API and they don't want to have to install a new copy every time. They demand a Web API so they can always be pointing to my latest and greatest without restarting their apps and APIs. No problem. I'll just expose it over HTTP as well: \"\"\"A simple API to enable adding two numbers together\"\"\" import hug @hug.get () # <-- This is the only additional line @hug.cli () def add ( number_1 : hug . types . number , number_2 : hug . types . number ): \"\"\"Returns the result of adding number_1 to number_2\"\"\" return number_1 + number_2 if __name__ == '__main__' : add . interface . cli () That's it. I then run my new service via hug -f add.py and can see it running on http://localhost:8000/ . The default page shows me documentation that points me toward http://localhost:8000/add?number_1=1&number_2=2 to perform my first addition. The thing I immediately notice, is that my new web interface works, it's well documented, and it's clean. Just like the original. Even better, after all of this, people hitting the API via Python didn't have to change anything. All my original unit tests continue to pass and my code coverage remains at 100%. It turns out, the problems and thoughts that go into defining a clean well documented API for internal use greatly mirror those that are required to expose an API for external use. hug recognizes this and enables cleanly reusing the documentation, requirements, and structure of internal APIs for external use. This also encourages easier to use and well documented internal APIs: a major win/win. What happened internally as I exposed my API to new interfaces? A few things happen when you wrapped that first function for external use, with hug.cli(): hug created a singleton hug.API object on your module to keep track of all interfaces that exist within the module This is referable by __hug__ or hug.API(__name__) a new hug.interface.CLI() object was created and attached to add.interface.cli This interface fully encapsulates the logic needed to expose add as a command line tool NOTE: all supported ways to expose a function via hug can be found in hug/interface.py the original Python add function is returned unmodified (with exception to the .interface.cli property addition) Then when I extended my API to run as HTTP service the same basic pattern was followed: hug saw that the singleton already existed a new hug.interface.HTTP() object was created and attached to add.interface.http This interface encapsulates the logic needed to expose the add command as an HTTP service The new HTTP interface handler is registered to the API singleton the original Python add function is returned unmodified (with exception to the .interface.http property addition) At the end of this, I have 2 interface objects attached to my original function: add.cli and add.http . Which is consistent with what I want to accomplish, one Python API with 2 additional external interfaces. When I start the service via the command line, I call the add.cli interface directly which executes the code producing a command line tool to interact with the add function. When I run hug -f add.py the hug runner looks for the __hug__ singleton object and then looks for all registered HTTP interfaces, creating a Falcon WSGI API from them. It then uses this new Falcon API to directly handle incoming HTTP requests. Where does the code live for these core pieces? While hug has a lot of modules that enable it to provide a great depth of functionality, everything accomplished above, and that is core to hug, lives in only a few: hug/api.py : Defines the hug per-module singleton object that keeps track of all registered interfaces, alongside the associated per interface APIs (HTTPInterfaceAPI, CLIInterfaceAPI) hug/routing.py : holds all the data and settings that should be passed to newly created interfaces, and creates the interfaces from that data. This directly is what powers hug.get , hug.cli , and all other function to interface routers Can be seen as a Factory for creating new interfaces hug/interface.py : Defines the actual interfaces that manage external interaction with your function (CLI and HTTP). These 3 modules define the core functionality of hug, and any API that uses hug will inevitably utilize these modules. Develop a good handling on just these and you'll be in great shape to contribute to hug, and think of new ways to improve the Framework. Beyond these there is one additional internal utility library that enables hug to do its magic: hug/introspect.py . This module provides utility functions that enable hugs routers to determine what arguments a function takes and in what form. Enabling interfaces to improve upon internal functions hug provides several mechanisms to enable your exposed interfaces to have additional capabilities not defined by the base Python function. Enforced type annotations hug interfaces automatically enforce the type annotations that you set on functions def add ( number_1 : hug . types . number , number_2 : hug . types . number ): These types are simply called with the data which is passed into that field, if an exception is raised then it's seen as invalid. All of hug's custom types used for enforcing annotations are defined in hug/types.py . Directives hug interfaces allow replacing Python function parameters with dynamically-pulled data via directives. def add ( number_1 : hug . types . number , number_2 : hug . types . number , hug_timer = 2 ): In this example hug_timer is a directive, when calling via a hug interface hug_timer is replaced with a timer that contains the starting time. All of hug's built-in directives are defined in hug/directives.py . Requires hug requirements allow you to specify requirements that must be met only for specified interfaces. @hug.get ( requires = hug . authentication . basic ( hug . authentication . verify ( 'User1' , 'mypassword' ))) Causes the HTTP method to only successfully call the Python function if User1 is logged in. require functions currently highly focused on authentication and all existing require functions are defined in hug/authentication.py . Transformations hug transformations enable changing the result of a function but only for the specified interface. @hug.get ( transform = str ) The above would cause the method to return a stringed result, while the original Python function would still return an int. All of hug's built in transformations are defined in hug/transform.py . Input/Output formats hug provides an extensive number of built-in input and output formats. python @hug.get(output_format=hug.output_format.json) These formats define how data should be sent to your API function and how it will be returned. All of hugs built-in output formats are found in hug/output_format.py . All of hugs built-in input formats are found in hug/input_format.py . The default output_formatting is JSON. Switching from using a hug API over one interface to another hug does its best to also solve the other side of the coin: that is how APIs are used. While native Python will always be the fastest, HTTP can provide attractive auto updating and clear responsibility separation benefits. You can interact with hug APIs via hug.use.[interface] if the ability to switch between these is a high priority for you. The code that enables this is found in hug/use.py and should be kept in mind if working on adding an additional interface for hug, or changing how hug calls functions. Feel free to update or request more info :) I tried my best to highlight where important functionality in the hug project lives via this Architecture document, as well as explain the reasoning behind it. However, this document is certainly not complete! If you encounter anything you would like to be expanded upon or explained in detail here, please either let me know or modify the document so everyone can get a good walkthrough of hug's architecture. Thanks! I hope you have found this guide useful :) ~Timothy","title":"Architecture"},{"location":"ARCHITECTURE/#the-guiding-thought-behind-the-architecture","text":"hug is the cleanest way to create HTTP REST APIs on Python 3. It consistently benchmarks among the top 3 performing web frameworks for Python, handily beating out Flask and Django. For almost every common Web API task the code written to accomplish it in hug is a small fraction of what is required in other Frameworks. However, it's important to note, hug is not a Web API Framework. OK--that certainly is a function it performs. And exceptionally well at that. But at its core, hug is a framework for exposing idiomatically correct and standard internal Python APIs externally. A framework to allow developers and architects to define logic and structure once, and then cleanly expose it over other means. Currently, this means that you can expose existing Python functions / APIs over HTTP and CLI in addition to standard Python. However, as time goes on more interfaces will be supported. The architecture and implementation decisions that have gone into hug have and will continue to support this goal. This central concept also frees hug to rely on the fastest and best of breed components for every interface it supports: Falcon is leveraged when exposing to HTTP for its impressive performance at this task Argparse is leveraged when exposing to CLI for the clean consistent interaction it enables from the command line","title":"The guiding thought behind the architecture"},{"location":"ARCHITECTURE/#what-this-looks-like-in-practice-an-illustrative-example","text":"Let's say I have a very simple Python API I've built to add 2 numbers together. I call my invention addition . Trust me, this is legit. It's trademarked and everything: \"\"\"A simple API to enable adding two numbers together\"\"\" def add ( number_1 , number_2 ): \"\"\"Returns the result of adding number_1 to number_2\"\"\" return number_1 + number_2 It works, it's well documented, and it's clean. Several people are already importing and using my Python module for their math needs. However, there's a great injustice! I'm lazy, and I don't want to open a Python interpreter etc to access my function. Here's how I modify it to expose it via the command line: \"\"\"A simple API to enable adding two numbers together\"\"\" import hug @hug.cli () def add ( number_1 : hug . types . number , number_2 : hug . types . number ): \"\"\"Returns the result of adding number_1 to number_2\"\"\" return number_1 + number_2 if __name__ == '__main__' : add . interface . cli () Yay! Now I can just do my math from the command line using: add.py $NUMBER_1 $NUMBER_2 . And even better, if I miss an argument it lets me know what it is and how to fix my error. The thing I immediately notice, is that my new command line interface works, it's well documented, and it's clean. Just like the original. However, users are not satisfied. I keep updating my API and they don't want to have to install a new copy every time. They demand a Web API so they can always be pointing to my latest and greatest without restarting their apps and APIs. No problem. I'll just expose it over HTTP as well: \"\"\"A simple API to enable adding two numbers together\"\"\" import hug @hug.get () # <-- This is the only additional line @hug.cli () def add ( number_1 : hug . types . number , number_2 : hug . types . number ): \"\"\"Returns the result of adding number_1 to number_2\"\"\" return number_1 + number_2 if __name__ == '__main__' : add . interface . cli () That's it. I then run my new service via hug -f add.py and can see it running on http://localhost:8000/ . The default page shows me documentation that points me toward http://localhost:8000/add?number_1=1&number_2=2 to perform my first addition. The thing I immediately notice, is that my new web interface works, it's well documented, and it's clean. Just like the original. Even better, after all of this, people hitting the API via Python didn't have to change anything. All my original unit tests continue to pass and my code coverage remains at 100%. It turns out, the problems and thoughts that go into defining a clean well documented API for internal use greatly mirror those that are required to expose an API for external use. hug recognizes this and enables cleanly reusing the documentation, requirements, and structure of internal APIs for external use. This also encourages easier to use and well documented internal APIs: a major win/win.","title":"What this looks like in practice - an illustrative example"},{"location":"ARCHITECTURE/#what-happened-internally-as-i-exposed-my-api-to-new-interfaces","text":"A few things happen when you wrapped that first function for external use, with hug.cli(): hug created a singleton hug.API object on your module to keep track of all interfaces that exist within the module This is referable by __hug__ or hug.API(__name__) a new hug.interface.CLI() object was created and attached to add.interface.cli This interface fully encapsulates the logic needed to expose add as a command line tool NOTE: all supported ways to expose a function via hug can be found in hug/interface.py the original Python add function is returned unmodified (with exception to the .interface.cli property addition) Then when I extended my API to run as HTTP service the same basic pattern was followed: hug saw that the singleton already existed a new hug.interface.HTTP() object was created and attached to add.interface.http This interface encapsulates the logic needed to expose the add command as an HTTP service The new HTTP interface handler is registered to the API singleton the original Python add function is returned unmodified (with exception to the .interface.http property addition) At the end of this, I have 2 interface objects attached to my original function: add.cli and add.http . Which is consistent with what I want to accomplish, one Python API with 2 additional external interfaces. When I start the service via the command line, I call the add.cli interface directly which executes the code producing a command line tool to interact with the add function. When I run hug -f add.py the hug runner looks for the __hug__ singleton object and then looks for all registered HTTP interfaces, creating a Falcon WSGI API from them. It then uses this new Falcon API to directly handle incoming HTTP requests.","title":"What happened internally as I exposed my API to new interfaces?"},{"location":"ARCHITECTURE/#where-does-the-code-live-for-these-core-pieces","text":"While hug has a lot of modules that enable it to provide a great depth of functionality, everything accomplished above, and that is core to hug, lives in only a few: hug/api.py : Defines the hug per-module singleton object that keeps track of all registered interfaces, alongside the associated per interface APIs (HTTPInterfaceAPI, CLIInterfaceAPI) hug/routing.py : holds all the data and settings that should be passed to newly created interfaces, and creates the interfaces from that data. This directly is what powers hug.get , hug.cli , and all other function to interface routers Can be seen as a Factory for creating new interfaces hug/interface.py : Defines the actual interfaces that manage external interaction with your function (CLI and HTTP). These 3 modules define the core functionality of hug, and any API that uses hug will inevitably utilize these modules. Develop a good handling on just these and you'll be in great shape to contribute to hug, and think of new ways to improve the Framework. Beyond these there is one additional internal utility library that enables hug to do its magic: hug/introspect.py . This module provides utility functions that enable hugs routers to determine what arguments a function takes and in what form.","title":"Where does the code live for these core pieces?"},{"location":"ARCHITECTURE/#enabling-interfaces-to-improve-upon-internal-functions","text":"hug provides several mechanisms to enable your exposed interfaces to have additional capabilities not defined by the base Python function.","title":"Enabling interfaces to improve upon internal functions"},{"location":"ARCHITECTURE/#enforced-type-annotations","text":"hug interfaces automatically enforce the type annotations that you set on functions def add ( number_1 : hug . types . number , number_2 : hug . types . number ): These types are simply called with the data which is passed into that field, if an exception is raised then it's seen as invalid. All of hug's custom types used for enforcing annotations are defined in hug/types.py .","title":"Enforced type annotations"},{"location":"ARCHITECTURE/#directives","text":"hug interfaces allow replacing Python function parameters with dynamically-pulled data via directives. def add ( number_1 : hug . types . number , number_2 : hug . types . number , hug_timer = 2 ): In this example hug_timer is a directive, when calling via a hug interface hug_timer is replaced with a timer that contains the starting time. All of hug's built-in directives are defined in hug/directives.py .","title":"Directives"},{"location":"ARCHITECTURE/#requires","text":"hug requirements allow you to specify requirements that must be met only for specified interfaces. @hug.get ( requires = hug . authentication . basic ( hug . authentication . verify ( 'User1' , 'mypassword' ))) Causes the HTTP method to only successfully call the Python function if User1 is logged in. require functions currently highly focused on authentication and all existing require functions are defined in hug/authentication.py .","title":"Requires"},{"location":"ARCHITECTURE/#transformations","text":"hug transformations enable changing the result of a function but only for the specified interface. @hug.get ( transform = str ) The above would cause the method to return a stringed result, while the original Python function would still return an int. All of hug's built in transformations are defined in hug/transform.py .","title":"Transformations"},{"location":"ARCHITECTURE/#inputoutput-formats","text":"hug provides an extensive number of built-in input and output formats. python @hug.get(output_format=hug.output_format.json) These formats define how data should be sent to your API function and how it will be returned. All of hugs built-in output formats are found in hug/output_format.py . All of hugs built-in input formats are found in hug/input_format.py . The default output_formatting is JSON.","title":"Input/Output formats"},{"location":"ARCHITECTURE/#switching-from-using-a-hug-api-over-one-interface-to-another","text":"hug does its best to also solve the other side of the coin: that is how APIs are used. While native Python will always be the fastest, HTTP can provide attractive auto updating and clear responsibility separation benefits. You can interact with hug APIs via hug.use.[interface] if the ability to switch between these is a high priority for you. The code that enables this is found in hug/use.py and should be kept in mind if working on adding an additional interface for hug, or changing how hug calls functions.","title":"Switching from using a hug API over one interface to another"},{"location":"ARCHITECTURE/#feel-free-to-update-or-request-more-info","text":"I tried my best to highlight where important functionality in the hug project lives via this Architecture document, as well as explain the reasoning behind it. However, this document is certainly not complete! If you encounter anything you would like to be expanded upon or explained in detail here, please either let me know or modify the document so everyone can get a good walkthrough of hug's architecture. Thanks! I hope you have found this guide useful :) ~Timothy","title":"Feel free to update or request more info :)"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of hug simply run: pip3 install hug --upgrade Ideally, within a virtual environment. Changelog 2.6.0 - August 29, 2019 Improved CLI multiple behaviour with empty defaults Improved CLI type output for built-in types Improved MultiCLI base documentation 2.5.6 - June 20, 2019 Fixed issue #815: map_params() causes api documentation to lose param type information Improved project testing: restoring 100% coverage 2.5.5 - June 13, 2019 Fixed issue #808: Problems with command line invocation via hug CLI Fixed issue #647: Support for arbitrary URL complexity when using CORS middleware Fixed issue #805: Added documentation for map_params feature Added initial automated code cleaning and linting partially satisfying HOPE-8 -- Style Guideline for Hug Implemented HOPE-20 -- The Zen of Hug 2.5.4 hotfix - May 19, 2019 Fix issue #798 - Development runner TypeError when executing cli 2.5.3 hotfix - May 15, 2019 Fixed issue #794 - Restore support for versions of Marshmallow pre-2.17.0 2.5.2 hotfix - May 10, 2019 Fixed issue #790 - Set Falcon defaults to pre 2.0.0 version to avoid breaking changes for Hug users until a Hug 3.0.0 release. The new default Falcon behaviour can be defaulted before hand by setting __hug__.future = True . 2.5.1 hotfix - May 9, 2019 Fixed issue #784 - POST requests broken on 2.5.0 Optimizations and simplification of async support, taking advantadge of Python3.4 deprecation. Fix issue #785: Empty query params are not ignored on 2.5.0 Added support for modifying falcon API directly on startup Initial black formatting of code base, in preperation for CI enforced code formatting 2.5.0 - May 4, 2019 Updated to latest Falcon: 2.0.0 Added support for Marshmallow 3 Added support for args decorator parameter to optionally specify type transformations separate from annotations Added support for tests to provide a custom host parameter Breaking Changes: Deprecated support for Python 3.4 2.4.9 - TBD Add the ability to invoke the hug development server as a Python module e.g. python -m hug Corrected the documentation for the --without-cython install option 2.4.8 - April 7, 2019 Fixed issue #762 - HTTP errors crash with selectable output types Fixed MacOS testing via travis - added testing accross all the same Python versions tested on Linux 2.4.7 - March 28, 2019 Fixed API documentation with selectable output types 2.4.6 - March 25, 2019 Fixed issue #753 - 404 not found does not respect default output format. Documented the --without-cython option in CONTRIBUTING.md Extended documentation for output formats 2.4.4 - March 21, 2019 Added the ability to change the default output format for CLI endpoints both at the API and global level. Added the ablity to extend CLI APIs in addition to HTTP APIs issue #744. Added optional built-in API aware testing for CLI commands. Add unit test for extend_api() with CLI commands Fix running tests using python setup.py test Fix issue #749 extending API with mixed GET/POST methods Documented the multiple_files example Added the --without-cython option to setup.py 2.4.3 [hotfix] - March 17, 2019 Fix issue #737 - latest hug release breaks meinheld worker setup 2.4.2 - March 16, 2019 Python 3.7 support improvements No longer test against Python 3.4 - aimed for full deprecation in Hug 3.0.0 Improved interoperability with the latest Falcon release Documentation improvements Fixed bug in auto reload 2.4.1 - Sep 17, 2018 Fixed issue #631: Added support for Python 3.7 Fixed issue #665: Fixed problem with hug.types.json Fixed issue #679: Return docs for marshmallow schema instead of for dump method 2.4.0 - Jan 31, 2018 Updated Falcon requirement to 1.4.1 Fixed issue #590: Textual output formats should have explicitly defined charsets by default Fixed issue #596: Host argument for development runner Fixed issue #563: Added middleware to handle CORS requests Implemented issue #612: Add support for numpy types in JSON output by default Implemented improved class based directives with cleanup support (see: https://github.com/timothycrosley/hug/pull/603) Support ujson if installed Implement issue #579: Allow silencing intro message when running hug from command line Implemented issue #531: Allow exit value to alter status code for CLI tools Updated documentation generation to use hug's JSON outputter for consistency 2.3.2 - Sep 28, 2017 Implemented Issue #540: Add support for remapping parameters Updated Falcon requirement to 1.3.0 Fixed issue #552: Version ignored in class based routes Fixed issue #555: Gracefully handle digit only version strings Fixed issue #519: Exceptions are now correctly inserted into the current API using extend_api Breaking Changes: Fixed issue #539: Allow JSON output to include non-ascii (UTF8) characters by default. 2.3.1 - Aug 26, 2017 Fixed issue #500 & 504: Added support for automatic reload on Windows & enabled intuitive use of pdb within autoreloader Implemented improved way to retrieve list of urls and handlers for issue #462 Implemented support for Python typing module style sub types Updated to allow -m parameter load modules on current directory Improved hug.test decode behaviour Added built in handlers for CORS support: directive hug.directives.cors Improved routing support Added allow origins middleware 2.3.0 - May 4, 2017 Falcon requirement upgraded to 1.2.0 Enables filtering documentation according to a base_url Fixed a vulnerability in the static file router that allows files in parent directory to be accessed Fixed issue #392: Enable posting self in JSON data structure Fixed issue #418: Ensure version passed is a number Fixed issue #399: Multiple ints not working correctly for CLI interface Fixed issue #461: Enable async startup methods running in parallel Fixed issue #412: None type return for file output format Fixed issue #464: Class based routing now inherit templated parameters Fixed issue #346: Enable using async routes within threaded server Implemented issue #437: Added support for anonymous APIs Added support for exporting timedeltas to JSON as seconds Added support for endpoint-specific input formatters: def my_input_formatter ( data ): return ( 'Results' , hug . input_format . json ( data )) @hug.get ( inputs = { 'application/json' : my_input_formatter }) def foo (): pass Adds support for passing in a custom scheme in hug.test Adds str() and repr() support to hug_timer directive Added support for moduleless APIs Improved argparser usage message Implemented feature #427: Allow custom argument deserialization together with standard type annotation Improvements to exception handling. Added support for request / response in a single generator based middleware function Automatic reload support for development runner Added support for passing params dictionary and query_string arguments into hug.test.http command for more direct modification of test inputs Added support for manual specifying the scheme used in hug.test calls Improved output formats, enabling nested request / response dependent formatters Breaking Changes Sub output formatters functions now need to accept response & request or **kwargs Fixed issue #432: Improved ease of sub classing simple types - causes type extensions of types that dont take to init arguments, to automatically return an instanciated type, beaking existing usage that had to instanciate after the fact Fixed issue #405: cli and http @hug.startup() differs, not executed for cli, this also means that startup handlers are given an instance of the API and not of the interface. 2.2.0 - Oct 16, 2016 Defaults asyncio event loop to uvloop automatically if it is installed Added support for making endpoints private to enforce lack of automatic documentation creation for them. Added HTTP method named (get, post, etc) routers to the API router to be consistent with documentation Added smart handling of empty JSON content (issue #300) Added ability to have explicitly unversioned API endpoints using versions=False Added support for providing a different base URL when extending an API Added support for sinks when extending API Added support for object based CLI handlers Added support for excluding exceptions from being handled Added support for **kwarg handling within CLI interfaces Allows custom decorators to access parameters like request and response, without putting them in the original functions' parameter list Fixed not found handlers not being imported when extending an API Fixed API extending support of extra features like input_format Fixed issue with API directive not working with extension feature Fixed nested async calls so that they reuse the same loop Fixed TypeError being raised incorrectly when no content-type is specified (issue #330) Fixed issues with multi-part requests (issue #329) Fixed documentation output to exclude api_version and body Fixed an issue passing None where a text value was required (issue #341) 2.1.2 - May 18, 2016 Fixed an issue with sharing exception handlers across multiple modules (Thanks @soloman1124) Fixed how single direction (response / request) middlewares are bounded to work when code is Cython compiled 2.1.1 - May 17, 2016 Hot-fix release to ensure input formats don't die with unexpected parameters 2.1.0 - May 17, 2016 Updated base Falcon requirement to the latest: 1.0.0 Added native support for using asyncio methods (Thanks @rodcloutier!) Added improved support for application/x-www-form-urlencoded forms (thanks @cag!) Added initial support for multipart/form-data Added support for getting URL from hug function Added support for using hug.local() on methods in addition to functions Added a default mime-type for static file endpoints ( application/octet-stream ) Added initial hug.API(__name__).context dictionary as a safe place to store global per-thread state (such as database connections) Added support for manually specifying API object for all decorators (including middleware / startup) to enable easier plugin interaction Added support for selectively removing requirements per endpoint Added conditional output format based on Accept request header, as detailed in issue #277 Added support for dynamically creating named modules from API names Improved how hug.test deals with non JSON content types Fixed issues with certain non-standard content-type values causing an exception Fixed a bug producing documentation when versioning is used, and there are no routes that apply accros versions Fixed a bug in the hug_documentation directive Breaking Changes Input formats no longer get passed encoding but instead get passed charset along side all other set content type parameters 2.0.7 - Mar 25, 2016 Added convenience put_post router to enable easier usage of the common @hug.get('url/', ('PUT', 'POST\")) pattern When passing lists or tuples to the hug http testing methods, they will now correctly be handled as multiple values 2.0.5 - 2.0.6 - Mar 25, 2016 Adds built-in support for token based authentication 2.0.4 - Mar 22, 2016 Fixes documentation on PyPI website 2.0.3 - Mar 22, 2016 Fixes hug.use module on Windows 2.0.2 - Mar 18, 2016 Work-around bug that was keeping hug from working on Windows machines Introduced a delete method to the abstract hug store module 2.0.1 - Mar 18, 2016 Add in-memory data / session store for testing Default hug.use.HTTP to communicate over JSON body 2.0.0 - Mar 17, 2016 Adds the concept of chain-able routing decorators Adds built-in static file handling support via a @hug.static decorator (thanks @BrandonHoffman!) Adds a directive to enable directly accessing the user object from any API call (thanks @ianthetechie) Adds the concept of seamless micro-services via the hug.use module, enable switching between HTTP and local without code change Adds built-in support for 'X-Api-Key' header based authentication via authentication.api_key Adds support for running arbitrary python functions at runtime via a @hug.startup decorator Adds support for smarter handling of html output types Adds a UUID type Adds support for explicit API creation / referencing using hug.api(__name__) Adds a logging middleware to simplify the process of logging all requests with hug Adds a middleware_class class decorator, to enable quickly registering middleware classes Adds smart_redirection allowing API functions to return other endpoints Adds support for class based handlers Adds support for automatically handling exceptions Adds support for automatically outputting images with save method that don't take a format. Added extended support for delimited fields, enabling use of custom delimiters Added support for running different transformers based on content_type Added support for outputting a different response output type based on the response content_type Added support for running different transformations and outputting different content_types based on path suffix Added support for automatically supporting a set of suffixes at the end of a URL Added support for automatically adding headers based on route match Added support for quickly adding cache header based on route match Added support for quickly adding allow origin header based on route match Added support for quickly re-routing to defined 404 handler Added support for length based types ( length , shorter_than , and longer_than ) Added support for easily extending hugs JSON outputter with support for custom types Added support for a custom final pass validation function Added support for defining routes separate from handlers Added support for raising on validation errors - to enable overall exception handlers to catch them Added support for multiple transformers on an endpoint via transform.all Added support for applying type annotations and directives locally with @hug.local() Added support for a base_url by doing hug.API(__name__).http.base_url = '/base_url' Added support for automatically running CLI commands from hug command line runner Added requirements to documentation Updated all default output formats to gracefully handle error dictionaries Documentation generation was moved to API instances to enable easier customization Now correctly identifies and handles custom encodings Improved integration with Falcon so that primary elements (like status codes) can be imported directly from hug Added the ability to specify a transformer for validation errors per request handler, via on_invalid decorator argument Added the ability to specify an output format specific to validation errors per request handler, via output_invalid decorator argument Changed transform functions to get ran on output of validation errors by default Automatically works around a bug in uwsgi when returning byte streams Refactored how interfaces are built to be more reasuable, and more easily introspected Refactored how the built in annotation types are built to be more easily built upon Updated type.string to fail if a list is passed in Removed 'cli_behaviour' from types, instead moving the responsibility of per-type behavior to the CLI interface Fixed a bug that leaked annotation provided directives to the produced documentation Fully re-factored hug's type system for easier extensibility Breaking Changes directives are no longer automatically applied to local function calls, '@hug.local' must be used to apply them cli_behaviour has been removed as a type feature - however common sense inheritance of base types should easily replace it's usage documentation module has been removed, in favor of documentation being generated by the api object and individual interfaces API singleton now has sub-apis for each interface in use (IE hug.API( name ).http and hug.API( name ).cli) run module has been removed, with the functionality moved to hug.API( name ).http.server() and the terminal functionality being moved to hug.development_runner.hug 1.9.9 - Dec 15, 2015 Hug's json serializer will now automatically convert decimal.Decimal objects during serializationkw Added in_range , greater_than , and less_than types to allow easily limiting values entered into an API 1.9.8 - Dec 1, 2015 Hug's json serializer will now automatically convert returned (non-list) iterables into json lists 1.9.7 - Dec 1, 2015 Fixed a bug (issue #115) that caused the command line argument for not auto generating documentation -nd to fail 1.9.6 - Nov 25, 2015 Fixed a bug (issue #112) that caused non-versioned endpoints not to show up in auto-generated documentation, when versioned endpoints are present 1.9.5 - Nov 20, 2015 Improved cli output, to output nothing if None is returned 1.9.3 - Nov 18, 2015 Enabled hug.types.multiple to be exposed as nargs * Fixed a bug that caused a CLI argument when adding an argument starting with help Fixed a bug that caused CLI arguments that used hug.types.multiple to be parsed as nested lists 1.9.2 - Nov 18, 2015 Improved boolean type behavior on CLIs 1.9.1 - Nov 14, 2015 Fixes a bug that caused hug cli clients to occasionally incorrectly require additional arguments Added support for automatically converting non utf8 bytes to base64 during json output 1.9.0 - Nov 10, 2015 Added initial built-in support for video output formats (Thanks @arpesenti!) Added built-in automatic support for range-requests when streaming files (such as videos) Output formatting functions are now called, even if a stream is returned. Input formatting functions now need to be responsible for dealing with text encoding and streaming Added additional default input format for text/plain and a few other common text based formats If no input format is available, but the body parameter is requested - the body stream is now returned Added support for a generic file output formatter that automatically determines the content type for the file 1.8.2 - Nov 9, 2015 Drastically improved hug performance when dealing with a large number of requests in wsgi mode 1.8.1 - Nov 5, 2015 Added json as a built in hug type to handle urlencoded json data in a request Added multi as a built in hug type that will allow a single field to be one of multiple types 1.8.0 - Nov 4, 2015 Added a middleware module make it easier to bundle generally useful middlewares going forward Added a generic / reusable SessionMiddleware (Thanks @vortec!) 1.7.1 - Nov 4, 2015 Fix a bug that caused error messages sourced from exceptions to be double quoted 1.7.0 - Nov 3, 2015 Auto supply response and request to output transformations and formats when they are taken as arguments Improved the smart_boolean type even further, to allow 0, 1, t, f strings as input Enabled normal boolean type to easily work with cli apps, by having it interact via 'store_true' 1.6.5 - Nov 2, 2015 Fixed a small spelling error on the smart_boolean type 1.6.2 - Nov 2, 2015 Added a mapping type that allows users to quikly map string values to Python types Added a smart_boolean type that respects explicit true/false in string values 1.6.1 - Oct 30, 2015 Added support for overriding parameters via decorator to ease use of **kwargs Added built-in boolean type support Improved testing environment 1.6.0 - Oct 13, 2015 Adds support for attaching hug routes to method calls Hug is now compiled using Cython (when it is available) for an additional performance boost 1.5.1 - Oct 1, 2015 Added built-in support for serializing sets 1.5.0 - Sep 30, 2015 Added built-in support for outputting svg images Added support for rendering images from pygal graphs, or other image framworks that support render , automatically Added support for marshmallow powered output transformations Added support for marshmallow schema powered input types Added support for using individual marshmallow fields directly as input types Added support for attaching directives to specific named parameters, allowing directives to be used multiple times in a single API call Added support for attaching named directives using only the text name of the directive 1.4.0 - Sep 14, 2015 Added *args support to hug.cli Added built-in html output support Added multi-api composition example to examples folder Fixed issue #70: error when composing two API modules into a single one without directives Fixed issue #73: README file is incorrectly formatted on PYPI 1.3.1 - Sep 8, 2015 Fixed string only annotations causing exceptions when used in conjunction with hug.cli Fixed return of image file not correctly able to set stream len information / not correctly returning with PIL images Added examples of image loading with hug 1.3.0 - Sep 8, 2015 Started keeping a log of all changes between releases Added support for quickly exposing functions as cli clients with hug.cli decorator Added support for quickly serving up development APIs from withing the module using: if __name__ == '__main__': __hug__.serve() Added support for documentation only type annotations, simply by passing just a string in as the type annotation Added support for requires argument to limit execution of functions based on a given criteria Added automatic documentation of output type transformations Added initial built-in authentication support Added built-in support for outputting common image file types Added support for returning streams within hugged functions hug.types.decimal renamed to hug.types.float_number and hug.types.decimal type added that returns python Decimal hug.types.accept wrapper added, that makes it easy to customize doc strings and error handling for any preexisting type converter","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of hug simply run: pip3 install hug --upgrade Ideally, within a virtual environment.","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#260-august-29-2019","text":"Improved CLI multiple behaviour with empty defaults Improved CLI type output for built-in types Improved MultiCLI base documentation","title":"2.6.0 - August 29, 2019"},{"location":"CHANGELOG/#256-june-20-2019","text":"Fixed issue #815: map_params() causes api documentation to lose param type information Improved project testing: restoring 100% coverage","title":"2.5.6 - June 20, 2019"},{"location":"CHANGELOG/#255-june-13-2019","text":"Fixed issue #808: Problems with command line invocation via hug CLI Fixed issue #647: Support for arbitrary URL complexity when using CORS middleware Fixed issue #805: Added documentation for map_params feature Added initial automated code cleaning and linting partially satisfying HOPE-8 -- Style Guideline for Hug Implemented HOPE-20 -- The Zen of Hug","title":"2.5.5 - June 13, 2019"},{"location":"CHANGELOG/#254-hotfix-may-19-2019","text":"Fix issue #798 - Development runner TypeError when executing cli","title":"2.5.4 hotfix - May 19, 2019"},{"location":"CHANGELOG/#253-hotfix-may-15-2019","text":"Fixed issue #794 - Restore support for versions of Marshmallow pre-2.17.0","title":"2.5.3 hotfix - May 15, 2019"},{"location":"CHANGELOG/#252-hotfix-may-10-2019","text":"Fixed issue #790 - Set Falcon defaults to pre 2.0.0 version to avoid breaking changes for Hug users until a Hug 3.0.0 release. The new default Falcon behaviour can be defaulted before hand by setting __hug__.future = True .","title":"2.5.2 hotfix - May 10, 2019"},{"location":"CHANGELOG/#251-hotfix-may-9-2019","text":"Fixed issue #784 - POST requests broken on 2.5.0 Optimizations and simplification of async support, taking advantadge of Python3.4 deprecation. Fix issue #785: Empty query params are not ignored on 2.5.0 Added support for modifying falcon API directly on startup Initial black formatting of code base, in preperation for CI enforced code formatting","title":"2.5.1 hotfix - May 9, 2019"},{"location":"CHANGELOG/#250-may-4-2019","text":"Updated to latest Falcon: 2.0.0 Added support for Marshmallow 3 Added support for args decorator parameter to optionally specify type transformations separate from annotations Added support for tests to provide a custom host parameter Breaking Changes: Deprecated support for Python 3.4","title":"2.5.0 - May 4, 2019"},{"location":"CHANGELOG/#249-tbd","text":"Add the ability to invoke the hug development server as a Python module e.g. python -m hug Corrected the documentation for the --without-cython install option","title":"2.4.9 - TBD"},{"location":"CHANGELOG/#248-april-7-2019","text":"Fixed issue #762 - HTTP errors crash with selectable output types Fixed MacOS testing via travis - added testing accross all the same Python versions tested on Linux","title":"2.4.8 - April 7, 2019"},{"location":"CHANGELOG/#247-march-28-2019","text":"Fixed API documentation with selectable output types","title":"2.4.7 - March 28, 2019"},{"location":"CHANGELOG/#246-march-25-2019","text":"Fixed issue #753 - 404 not found does not respect default output format. Documented the --without-cython option in CONTRIBUTING.md Extended documentation for output formats","title":"2.4.6 - March 25, 2019"},{"location":"CHANGELOG/#244-march-21-2019","text":"Added the ability to change the default output format for CLI endpoints both at the API and global level. Added the ablity to extend CLI APIs in addition to HTTP APIs issue #744. Added optional built-in API aware testing for CLI commands. Add unit test for extend_api() with CLI commands Fix running tests using python setup.py test Fix issue #749 extending API with mixed GET/POST methods Documented the multiple_files example Added the --without-cython option to setup.py","title":"2.4.4 - March 21, 2019"},{"location":"CHANGELOG/#243-hotfix-march-17-2019","text":"Fix issue #737 - latest hug release breaks meinheld worker setup","title":"2.4.3 [hotfix] - March 17, 2019"},{"location":"CHANGELOG/#242-march-16-2019","text":"Python 3.7 support improvements No longer test against Python 3.4 - aimed for full deprecation in Hug 3.0.0 Improved interoperability with the latest Falcon release Documentation improvements Fixed bug in auto reload","title":"2.4.2 - March 16, 2019"},{"location":"CHANGELOG/#241-sep-17-2018","text":"Fixed issue #631: Added support for Python 3.7 Fixed issue #665: Fixed problem with hug.types.json Fixed issue #679: Return docs for marshmallow schema instead of for dump method","title":"2.4.1 - Sep 17, 2018"},{"location":"CHANGELOG/#240-jan-31-2018","text":"Updated Falcon requirement to 1.4.1 Fixed issue #590: Textual output formats should have explicitly defined charsets by default Fixed issue #596: Host argument for development runner Fixed issue #563: Added middleware to handle CORS requests Implemented issue #612: Add support for numpy types in JSON output by default Implemented improved class based directives with cleanup support (see: https://github.com/timothycrosley/hug/pull/603) Support ujson if installed Implement issue #579: Allow silencing intro message when running hug from command line Implemented issue #531: Allow exit value to alter status code for CLI tools Updated documentation generation to use hug's JSON outputter for consistency","title":"2.4.0 - Jan 31, 2018"},{"location":"CHANGELOG/#232-sep-28-2017","text":"Implemented Issue #540: Add support for remapping parameters Updated Falcon requirement to 1.3.0 Fixed issue #552: Version ignored in class based routes Fixed issue #555: Gracefully handle digit only version strings Fixed issue #519: Exceptions are now correctly inserted into the current API using extend_api Breaking Changes: Fixed issue #539: Allow JSON output to include non-ascii (UTF8) characters by default.","title":"2.3.2 - Sep 28, 2017"},{"location":"CHANGELOG/#231-aug-26-2017","text":"Fixed issue #500 & 504: Added support for automatic reload on Windows & enabled intuitive use of pdb within autoreloader Implemented improved way to retrieve list of urls and handlers for issue #462 Implemented support for Python typing module style sub types Updated to allow -m parameter load modules on current directory Improved hug.test decode behaviour Added built in handlers for CORS support: directive hug.directives.cors Improved routing support Added allow origins middleware","title":"2.3.1 - Aug 26, 2017"},{"location":"CHANGELOG/#230-may-4-2017","text":"Falcon requirement upgraded to 1.2.0 Enables filtering documentation according to a base_url Fixed a vulnerability in the static file router that allows files in parent directory to be accessed Fixed issue #392: Enable posting self in JSON data structure Fixed issue #418: Ensure version passed is a number Fixed issue #399: Multiple ints not working correctly for CLI interface Fixed issue #461: Enable async startup methods running in parallel Fixed issue #412: None type return for file output format Fixed issue #464: Class based routing now inherit templated parameters Fixed issue #346: Enable using async routes within threaded server Implemented issue #437: Added support for anonymous APIs Added support for exporting timedeltas to JSON as seconds Added support for endpoint-specific input formatters: def my_input_formatter ( data ): return ( 'Results' , hug . input_format . json ( data )) @hug.get ( inputs = { 'application/json' : my_input_formatter }) def foo (): pass Adds support for passing in a custom scheme in hug.test Adds str() and repr() support to hug_timer directive Added support for moduleless APIs Improved argparser usage message Implemented feature #427: Allow custom argument deserialization together with standard type annotation Improvements to exception handling. Added support for request / response in a single generator based middleware function Automatic reload support for development runner Added support for passing params dictionary and query_string arguments into hug.test.http command for more direct modification of test inputs Added support for manual specifying the scheme used in hug.test calls Improved output formats, enabling nested request / response dependent formatters Breaking Changes Sub output formatters functions now need to accept response & request or **kwargs Fixed issue #432: Improved ease of sub classing simple types - causes type extensions of types that dont take to init arguments, to automatically return an instanciated type, beaking existing usage that had to instanciate after the fact Fixed issue #405: cli and http @hug.startup() differs, not executed for cli, this also means that startup handlers are given an instance of the API and not of the interface.","title":"2.3.0 - May 4, 2017"},{"location":"CHANGELOG/#220-oct-16-2016","text":"Defaults asyncio event loop to uvloop automatically if it is installed Added support for making endpoints private to enforce lack of automatic documentation creation for them. Added HTTP method named (get, post, etc) routers to the API router to be consistent with documentation Added smart handling of empty JSON content (issue #300) Added ability to have explicitly unversioned API endpoints using versions=False Added support for providing a different base URL when extending an API Added support for sinks when extending API Added support for object based CLI handlers Added support for excluding exceptions from being handled Added support for **kwarg handling within CLI interfaces Allows custom decorators to access parameters like request and response, without putting them in the original functions' parameter list Fixed not found handlers not being imported when extending an API Fixed API extending support of extra features like input_format Fixed issue with API directive not working with extension feature Fixed nested async calls so that they reuse the same loop Fixed TypeError being raised incorrectly when no content-type is specified (issue #330) Fixed issues with multi-part requests (issue #329) Fixed documentation output to exclude api_version and body Fixed an issue passing None where a text value was required (issue #341)","title":"2.2.0 - Oct 16, 2016"},{"location":"CHANGELOG/#212-may-18-2016","text":"Fixed an issue with sharing exception handlers across multiple modules (Thanks @soloman1124) Fixed how single direction (response / request) middlewares are bounded to work when code is Cython compiled","title":"2.1.2 - May 18, 2016"},{"location":"CHANGELOG/#211-may-17-2016","text":"Hot-fix release to ensure input formats don't die with unexpected parameters","title":"2.1.1 - May 17, 2016"},{"location":"CHANGELOG/#210-may-17-2016","text":"Updated base Falcon requirement to the latest: 1.0.0 Added native support for using asyncio methods (Thanks @rodcloutier!) Added improved support for application/x-www-form-urlencoded forms (thanks @cag!) Added initial support for multipart/form-data Added support for getting URL from hug function Added support for using hug.local() on methods in addition to functions Added a default mime-type for static file endpoints ( application/octet-stream ) Added initial hug.API(__name__).context dictionary as a safe place to store global per-thread state (such as database connections) Added support for manually specifying API object for all decorators (including middleware / startup) to enable easier plugin interaction Added support for selectively removing requirements per endpoint Added conditional output format based on Accept request header, as detailed in issue #277 Added support for dynamically creating named modules from API names Improved how hug.test deals with non JSON content types Fixed issues with certain non-standard content-type values causing an exception Fixed a bug producing documentation when versioning is used, and there are no routes that apply accros versions Fixed a bug in the hug_documentation directive Breaking Changes Input formats no longer get passed encoding but instead get passed charset along side all other set content type parameters","title":"2.1.0 - May 17, 2016"},{"location":"CHANGELOG/#207-mar-25-2016","text":"Added convenience put_post router to enable easier usage of the common @hug.get('url/', ('PUT', 'POST\")) pattern When passing lists or tuples to the hug http testing methods, they will now correctly be handled as multiple values","title":"2.0.7 - Mar 25, 2016"},{"location":"CHANGELOG/#205-206-mar-25-2016","text":"Adds built-in support for token based authentication","title":"2.0.5 - 2.0.6 - Mar 25, 2016"},{"location":"CHANGELOG/#204-mar-22-2016","text":"Fixes documentation on PyPI website","title":"2.0.4 - Mar 22, 2016"},{"location":"CHANGELOG/#203-mar-22-2016","text":"Fixes hug.use module on Windows","title":"2.0.3 - Mar 22, 2016"},{"location":"CHANGELOG/#202-mar-18-2016","text":"Work-around bug that was keeping hug from working on Windows machines Introduced a delete method to the abstract hug store module","title":"2.0.2 - Mar 18, 2016"},{"location":"CHANGELOG/#201-mar-18-2016","text":"Add in-memory data / session store for testing Default hug.use.HTTP to communicate over JSON body","title":"2.0.1 - Mar 18, 2016"},{"location":"CHANGELOG/#200-mar-17-2016","text":"Adds the concept of chain-able routing decorators Adds built-in static file handling support via a @hug.static decorator (thanks @BrandonHoffman!) Adds a directive to enable directly accessing the user object from any API call (thanks @ianthetechie) Adds the concept of seamless micro-services via the hug.use module, enable switching between HTTP and local without code change Adds built-in support for 'X-Api-Key' header based authentication via authentication.api_key Adds support for running arbitrary python functions at runtime via a @hug.startup decorator Adds support for smarter handling of html output types Adds a UUID type Adds support for explicit API creation / referencing using hug.api(__name__) Adds a logging middleware to simplify the process of logging all requests with hug Adds a middleware_class class decorator, to enable quickly registering middleware classes Adds smart_redirection allowing API functions to return other endpoints Adds support for class based handlers Adds support for automatically handling exceptions Adds support for automatically outputting images with save method that don't take a format. Added extended support for delimited fields, enabling use of custom delimiters Added support for running different transformers based on content_type Added support for outputting a different response output type based on the response content_type Added support for running different transformations and outputting different content_types based on path suffix Added support for automatically supporting a set of suffixes at the end of a URL Added support for automatically adding headers based on route match Added support for quickly adding cache header based on route match Added support for quickly adding allow origin header based on route match Added support for quickly re-routing to defined 404 handler Added support for length based types ( length , shorter_than , and longer_than ) Added support for easily extending hugs JSON outputter with support for custom types Added support for a custom final pass validation function Added support for defining routes separate from handlers Added support for raising on validation errors - to enable overall exception handlers to catch them Added support for multiple transformers on an endpoint via transform.all Added support for applying type annotations and directives locally with @hug.local() Added support for a base_url by doing hug.API(__name__).http.base_url = '/base_url' Added support for automatically running CLI commands from hug command line runner Added requirements to documentation Updated all default output formats to gracefully handle error dictionaries Documentation generation was moved to API instances to enable easier customization Now correctly identifies and handles custom encodings Improved integration with Falcon so that primary elements (like status codes) can be imported directly from hug Added the ability to specify a transformer for validation errors per request handler, via on_invalid decorator argument Added the ability to specify an output format specific to validation errors per request handler, via output_invalid decorator argument Changed transform functions to get ran on output of validation errors by default Automatically works around a bug in uwsgi when returning byte streams Refactored how interfaces are built to be more reasuable, and more easily introspected Refactored how the built in annotation types are built to be more easily built upon Updated type.string to fail if a list is passed in Removed 'cli_behaviour' from types, instead moving the responsibility of per-type behavior to the CLI interface Fixed a bug that leaked annotation provided directives to the produced documentation Fully re-factored hug's type system for easier extensibility Breaking Changes directives are no longer automatically applied to local function calls, '@hug.local' must be used to apply them cli_behaviour has been removed as a type feature - however common sense inheritance of base types should easily replace it's usage documentation module has been removed, in favor of documentation being generated by the api object and individual interfaces API singleton now has sub-apis for each interface in use (IE hug.API( name ).http and hug.API( name ).cli) run module has been removed, with the functionality moved to hug.API( name ).http.server() and the terminal functionality being moved to hug.development_runner.hug","title":"2.0.0 - Mar 17, 2016"},{"location":"CHANGELOG/#199-dec-15-2015","text":"Hug's json serializer will now automatically convert decimal.Decimal objects during serializationkw Added in_range , greater_than , and less_than types to allow easily limiting values entered into an API","title":"1.9.9 - Dec 15, 2015"},{"location":"CHANGELOG/#198-dec-1-2015","text":"Hug's json serializer will now automatically convert returned (non-list) iterables into json lists","title":"1.9.8 - Dec 1, 2015"},{"location":"CHANGELOG/#197-dec-1-2015","text":"Fixed a bug (issue #115) that caused the command line argument for not auto generating documentation -nd to fail","title":"1.9.7 - Dec 1, 2015"},{"location":"CHANGELOG/#196-nov-25-2015","text":"Fixed a bug (issue #112) that caused non-versioned endpoints not to show up in auto-generated documentation, when versioned endpoints are present","title":"1.9.6 - Nov 25, 2015"},{"location":"CHANGELOG/#195-nov-20-2015","text":"Improved cli output, to output nothing if None is returned","title":"1.9.5 - Nov 20, 2015"},{"location":"CHANGELOG/#193-nov-18-2015","text":"Enabled hug.types.multiple to be exposed as nargs * Fixed a bug that caused a CLI argument when adding an argument starting with help Fixed a bug that caused CLI arguments that used hug.types.multiple to be parsed as nested lists","title":"1.9.3 - Nov 18, 2015"},{"location":"CHANGELOG/#192-nov-18-2015","text":"Improved boolean type behavior on CLIs","title":"1.9.2 - Nov 18, 2015"},{"location":"CHANGELOG/#191-nov-14-2015","text":"Fixes a bug that caused hug cli clients to occasionally incorrectly require additional arguments Added support for automatically converting non utf8 bytes to base64 during json output","title":"1.9.1 - Nov 14, 2015"},{"location":"CHANGELOG/#190-nov-10-2015","text":"Added initial built-in support for video output formats (Thanks @arpesenti!) Added built-in automatic support for range-requests when streaming files (such as videos) Output formatting functions are now called, even if a stream is returned. Input formatting functions now need to be responsible for dealing with text encoding and streaming Added additional default input format for text/plain and a few other common text based formats If no input format is available, but the body parameter is requested - the body stream is now returned Added support for a generic file output formatter that automatically determines the content type for the file","title":"1.9.0 - Nov 10, 2015"},{"location":"CHANGELOG/#182-nov-9-2015","text":"Drastically improved hug performance when dealing with a large number of requests in wsgi mode","title":"1.8.2 - Nov 9, 2015"},{"location":"CHANGELOG/#181-nov-5-2015","text":"Added json as a built in hug type to handle urlencoded json data in a request Added multi as a built in hug type that will allow a single field to be one of multiple types","title":"1.8.1 - Nov 5, 2015"},{"location":"CHANGELOG/#180-nov-4-2015","text":"Added a middleware module make it easier to bundle generally useful middlewares going forward Added a generic / reusable SessionMiddleware (Thanks @vortec!)","title":"1.8.0 - Nov 4, 2015"},{"location":"CHANGELOG/#171-nov-4-2015","text":"Fix a bug that caused error messages sourced from exceptions to be double quoted","title":"1.7.1 - Nov 4, 2015"},{"location":"CHANGELOG/#170-nov-3-2015","text":"Auto supply response and request to output transformations and formats when they are taken as arguments Improved the smart_boolean type even further, to allow 0, 1, t, f strings as input Enabled normal boolean type to easily work with cli apps, by having it interact via 'store_true'","title":"1.7.0 - Nov 3, 2015"},{"location":"CHANGELOG/#165-nov-2-2015","text":"Fixed a small spelling error on the smart_boolean type","title":"1.6.5 - Nov 2, 2015"},{"location":"CHANGELOG/#162-nov-2-2015","text":"Added a mapping type that allows users to quikly map string values to Python types Added a smart_boolean type that respects explicit true/false in string values","title":"1.6.2 - Nov 2, 2015"},{"location":"CHANGELOG/#161-oct-30-2015","text":"Added support for overriding parameters via decorator to ease use of **kwargs Added built-in boolean type support Improved testing environment","title":"1.6.1 - Oct 30, 2015"},{"location":"CHANGELOG/#160-oct-13-2015","text":"Adds support for attaching hug routes to method calls Hug is now compiled using Cython (when it is available) for an additional performance boost","title":"1.6.0 - Oct 13, 2015"},{"location":"CHANGELOG/#151-oct-1-2015","text":"Added built-in support for serializing sets","title":"1.5.1 - Oct 1, 2015"},{"location":"CHANGELOG/#150-sep-30-2015","text":"Added built-in support for outputting svg images Added support for rendering images from pygal graphs, or other image framworks that support render , automatically Added support for marshmallow powered output transformations Added support for marshmallow schema powered input types Added support for using individual marshmallow fields directly as input types Added support for attaching directives to specific named parameters, allowing directives to be used multiple times in a single API call Added support for attaching named directives using only the text name of the directive","title":"1.5.0 - Sep 30, 2015"},{"location":"CHANGELOG/#140-sep-14-2015","text":"Added *args support to hug.cli Added built-in html output support Added multi-api composition example to examples folder Fixed issue #70: error when composing two API modules into a single one without directives Fixed issue #73: README file is incorrectly formatted on PYPI","title":"1.4.0 - Sep 14, 2015"},{"location":"CHANGELOG/#131-sep-8-2015","text":"Fixed string only annotations causing exceptions when used in conjunction with hug.cli Fixed return of image file not correctly able to set stream len information / not correctly returning with PIL images Added examples of image loading with hug","title":"1.3.1 - Sep 8, 2015"},{"location":"CHANGELOG/#130-sep-8-2015","text":"Started keeping a log of all changes between releases Added support for quickly exposing functions as cli clients with hug.cli decorator Added support for quickly serving up development APIs from withing the module using: if __name__ == '__main__': __hug__.serve() Added support for documentation only type annotations, simply by passing just a string in as the type annotation Added support for requires argument to limit execution of functions based on a given criteria Added automatic documentation of output type transformations Added initial built-in authentication support Added built-in support for outputting common image file types Added support for returning streams within hugged functions hug.types.decimal renamed to hug.types.float_number and hug.types.decimal type added that returns python Decimal hug.types.accept wrapper added, that makes it easy to customize doc strings and error handling for any preexisting type converter","title":"1.3.0 - Sep 8, 2015"},{"location":"CODING_STANDARD/","text":"Coding Standard Any submission to this project should closely follow the PEP 8 coding guidelines with the exceptions: Lines can be up to 100 characters long. Single letter or otherwise nondescript variable names are prohibited. Standards for new hug modules New modules added to the hug project should all live directly within the hug/ directory without nesting. If the modules are meant only for internal use within hug they should be prefixed with a leading underscore. For example, def _internal_function . Modules should contain a doc string at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Coding Standard"},{"location":"CODING_STANDARD/#coding-standard","text":"Any submission to this project should closely follow the PEP 8 coding guidelines with the exceptions: Lines can be up to 100 characters long. Single letter or otherwise nondescript variable names are prohibited.","title":"Coding Standard"},{"location":"CODING_STANDARD/#standards-for-new-hug-modules","text":"New modules added to the hug project should all live directly within the hug/ directory without nesting. If the modules are meant only for internal use within hug they should be prefixed with a leading underscore. For example, def _internal_function . Modules should contain a doc string at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Standards for new hug modules"},{"location":"CONTRIBUTING/","text":"Contributing to hug Looking for a growing and useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Want a free project t-shirt to show you're a contributor? Welcome! You have found the right place. hug is growing quickly and needs awesome contributors like you to help the project reach its full potential. From reporting issues, writing documentation, implementing new features, fixing bugs and creating logos to providing additional usage examples - any contribution you can provide will be greatly appreciated and acknowledged. Getting hug set up for local development The first step when contributing to any project is getting it set up on your local machine. hug aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.5+ Python3-venv (included with most Python3 installations but some Ubuntu systems require that it be installed separately) bash or a bash compatible shell (should be auto-installed on Linux / Mac) autoenv (optional) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/hug.git cd hug If you have autoenv set-up correctly, simply press Y and then wait for the environment to be set up for you. If you don't have autoenv set-up, run source .env to set up the local environment. You will need to run this script every time you want to work on the project - though it will not cause the entire set up process to re-occur. Run test to verify your everything is set up correctly. If the tests all pass, you have successfully set up hug for local development! If not, you can ask for help diagnosing the error here . At step 3, you can skip using autoenv and the .env script, and create your development virtul environment manually instead using e.g. python3 -m venv or mkvirtualenv (from virtualenvwrapper ). Install dependencies by running pip install -r requirements/release.txt , and optional build or development dependencies by running pip install -r requirements/build.txt or pip install -r requirements/build.txt . Install Hug itself with pip install . or pip install -e . (for editable mode). This will compile all modules with Cython if it's installed in the environment. You can skip Cython compilation using pip install --install-option=--without-cython . (this works with -e as well). Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main hug project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Run clean to automatically sort your imports according to pep-8 guidelines. Ensure your code matches hug's latest coding standards defined here . It's important to focus to focus on making your code efficient as hug is used as a base framework for several performance critical APIs. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the ACKNOWLEDGEMENTS.md list :). Getting a free t-shirt Once you have finished contributing to the project, send your mailing address and shirt size to timothy.crosley@gmail.com, with the title hug Shirt for @$GITHUB_USER_NAME. When the project has reached 100 contributors, I will be sending every one of the original hundred contributors a t-shirt to commemorate their awesome work. Thank you! I can not tell you how thankful I am for the hard work done by hug contributors like you. hug could not be the exciting and useful framework it is today without your help. Thank you! ~Timothy Crosley","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-hug","text":"Looking for a growing and useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Want a free project t-shirt to show you're a contributor? Welcome! You have found the right place. hug is growing quickly and needs awesome contributors like you to help the project reach its full potential. From reporting issues, writing documentation, implementing new features, fixing bugs and creating logos to providing additional usage examples - any contribution you can provide will be greatly appreciated and acknowledged.","title":"Contributing to hug"},{"location":"CONTRIBUTING/#getting-hug-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. hug aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.5+ Python3-venv (included with most Python3 installations but some Ubuntu systems require that it be installed separately) bash or a bash compatible shell (should be auto-installed on Linux / Mac) autoenv (optional) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/hug.git cd hug If you have autoenv set-up correctly, simply press Y and then wait for the environment to be set up for you. If you don't have autoenv set-up, run source .env to set up the local environment. You will need to run this script every time you want to work on the project - though it will not cause the entire set up process to re-occur. Run test to verify your everything is set up correctly. If the tests all pass, you have successfully set up hug for local development! If not, you can ask for help diagnosing the error here . At step 3, you can skip using autoenv and the .env script, and create your development virtul environment manually instead using e.g. python3 -m venv or mkvirtualenv (from virtualenvwrapper ). Install dependencies by running pip install -r requirements/release.txt , and optional build or development dependencies by running pip install -r requirements/build.txt or pip install -r requirements/build.txt . Install Hug itself with pip install . or pip install -e . (for editable mode). This will compile all modules with Cython if it's installed in the environment. You can skip Cython compilation using pip install --install-option=--without-cython . (this works with -e as well).","title":"Getting hug set up for local development"},{"location":"CONTRIBUTING/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main hug project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Run clean to automatically sort your imports according to pep-8 guidelines. Ensure your code matches hug's latest coding standards defined here . It's important to focus to focus on making your code efficient as hug is used as a base framework for several performance critical APIs. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the ACKNOWLEDGEMENTS.md list :).","title":"Making a contribution"},{"location":"CONTRIBUTING/#getting-a-free-t-shirt","text":"Once you have finished contributing to the project, send your mailing address and shirt size to timothy.crosley@gmail.com, with the title hug Shirt for @$GITHUB_USER_NAME. When the project has reached 100 contributors, I will be sending every one of the original hundred contributors a t-shirt to commemorate their awesome work.","title":"Getting a free t-shirt"},{"location":"CONTRIBUTING/#thank-you","text":"I can not tell you how thankful I am for the hard work done by hug contributors like you. hug could not be the exciting and useful framework it is today without your help. Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"EXTENDING/","text":"Building hug extensions Want to extend hug to tackle new problems? Integrate a new form of authentication? Add new useful types? Awesome! Here are some guidlines to help you get going and make a world class hug extension that you will be proud to have showcased to all hug users. How are extensions built? hug extensions should be built like any other python project and uploaded to PYPI. What makes a hug extension a hug extension is simply it's name and the fact it contains within its Python code utilities and classes that extend hugs capabilties. Naming your extension All hug extensions should be prefixed with hug_ for easy disscovery on PYPI. Additionally, there are a few more exact prefixes that can be optionally be added to help steer users to what your extensions accomplishes: hug_types_ should be used if your extensions is used primarily to add new types to hug (for example: hug_types_numpy). hug_authentication_ if your extension is used primarily to add a new authentication type to hug (for example: hug_authentication_oath2) hug_output_format_ if your extension is used primarily to add a new output format to hug (for example: hug_output_format_svg) hug_input_format_ if your extension is used primarily to add a new input format to hug (for example: hug_input_format_html) hug_validate_ if your extension is used primarily to add a new overall validator to hug (for example: hug_validate_no_null). hug_transform_ if your extension is used primarily to add a new hug transformer (for example: hug_transform_add_time) hug_middleware_ if your extension is used primarily to add a middleware to hug (for example: hug_middleware_redis_session) For any more complex or general use case that doesn't fit into these predefined categories or combines many of them, it is perfectly suitable to simply prefix your extension with hug_ . For example: hug_geo could combine hug types, hug input formats, and hug output formats making it a good use case for a simply prefixed extension. Building Recommendations Ideally, hug extensions should be built in the same manner as hug itself. This means 100% test coverage using pytest, decent performance, pep8 compliance, and built in optional compiling with Cython. None of this is strictly required, but will help give users of your extension faith that it wont slow things down or break their setup unexpectedly. Registering your extension Once you have finished developing and testing your extension, you can help increase others ability to discover it by registering it. The first place an extension should be registered is on PYPI, just like any other Python Package. In addition to that you can add your extension to the list of extensions on hug's github wiki . Thank you A sincere thanks to anyone that takes the time to develop and register an extension for hug. You are helping to make hug a more complete eco-system for everyuser out there, and paving the way for a solid foundation into the future. Thanks! ~Timothy Crosley","title":"Extending"},{"location":"EXTENDING/#building-hug-extensions","text":"Want to extend hug to tackle new problems? Integrate a new form of authentication? Add new useful types? Awesome! Here are some guidlines to help you get going and make a world class hug extension that you will be proud to have showcased to all hug users.","title":"Building hug extensions"},{"location":"EXTENDING/#how-are-extensions-built","text":"hug extensions should be built like any other python project and uploaded to PYPI. What makes a hug extension a hug extension is simply it's name and the fact it contains within its Python code utilities and classes that extend hugs capabilties.","title":"How are extensions built?"},{"location":"EXTENDING/#naming-your-extension","text":"All hug extensions should be prefixed with hug_ for easy disscovery on PYPI. Additionally, there are a few more exact prefixes that can be optionally be added to help steer users to what your extensions accomplishes: hug_types_ should be used if your extensions is used primarily to add new types to hug (for example: hug_types_numpy). hug_authentication_ if your extension is used primarily to add a new authentication type to hug (for example: hug_authentication_oath2) hug_output_format_ if your extension is used primarily to add a new output format to hug (for example: hug_output_format_svg) hug_input_format_ if your extension is used primarily to add a new input format to hug (for example: hug_input_format_html) hug_validate_ if your extension is used primarily to add a new overall validator to hug (for example: hug_validate_no_null). hug_transform_ if your extension is used primarily to add a new hug transformer (for example: hug_transform_add_time) hug_middleware_ if your extension is used primarily to add a middleware to hug (for example: hug_middleware_redis_session) For any more complex or general use case that doesn't fit into these predefined categories or combines many of them, it is perfectly suitable to simply prefix your extension with hug_ . For example: hug_geo could combine hug types, hug input formats, and hug output formats making it a good use case for a simply prefixed extension.","title":"Naming your extension"},{"location":"EXTENDING/#building-recommendations","text":"Ideally, hug extensions should be built in the same manner as hug itself. This means 100% test coverage using pytest, decent performance, pep8 compliance, and built in optional compiling with Cython. None of this is strictly required, but will help give users of your extension faith that it wont slow things down or break their setup unexpectedly.","title":"Building Recommendations"},{"location":"EXTENDING/#registering-your-extension","text":"Once you have finished developing and testing your extension, you can help increase others ability to discover it by registering it. The first place an extension should be registered is on PYPI, just like any other Python Package. In addition to that you can add your extension to the list of extensions on hug's github wiki .","title":"Registering your extension"},{"location":"EXTENDING/#thank-you","text":"A sincere thanks to anyone that takes the time to develop and register an extension for hug. You are helping to make hug a more complete eco-system for everyuser out there, and paving the way for a solid foundation into the future. Thanks! ~Timothy Crosley","title":"Thank you"},{"location":"FAQ/","text":"Frequently Asked Questions about Hug For more examples, check out Hug's documentation and examples Github directories, and its website . General Questions Q: Can I use Hug with a web framework -- Django for example? A: You can use Hug alongside Django or the web framework of your choice, but it does have drawbacks. You would need to run hug on a separate, hug-exclusive server. You can also mount Hug as a WSGI app , embedded within your normal Django app. Q: Is Hug compatabile with Python 2? A: Python 2 is not supported by Hug. However, if you need to account for backwards compatability, there are workarounds. For example, you can wrap the decorators: def my_get_fn ( func , * args , ** kwargs ): if 'hug' in globals (): return hug . get ( func , * args , ** kwargs ) return func Technical Questions Q: I need to ensure the security of my data. Can Hug be used over HTTPS? A: Not directly, but you can utilize uWSGI with nginx to transmit sensitive data. HTTPS is not part of the standard WSGI application layer, so you must use a WSGI HTTP server (such as uWSGI) to run in production. With this setup, Nginx handles SSL connections, and transfers requests to uWSGI. Q: How can I serve static files from a directory using Hug? A: For a static HTML page, you can just set the proper output format as: output=hug.output_format.html . To see other examples, check out the html_serve example, the image_serve example, and the more general static_serve example within hug/examples . Most basic examples will use a format that looks something like this: @hug.static ( '/static' ) \ufffc def my_static_dirs (): \ufffc return ( '/home/www/path-to-static-dir' ) Q: Does Hug support autoreloading? A: Hug supports any WSGI server that uses autoreloading, for example Gunicorn and uWSGI. The scripts for initializing autoreload for them are, respectively: Gunicorn: gunicorn --reload app:__hug_wsgi__ uWSGI: --py-autoreload 1 --http :8000 -w app:__hug_wsgi__ Q: How can I access a list of my routes? A: You can access a list of your routes by using the routes object on the HTTP API: __hug_wsgi__.http.routes It will return to you a structure of \"base_url -> url -> HTTP method -> Version -> Python Handler\". Therefore, for example, if you have no base_url set and you want to see the list of all URLS, you could run: __hug_wsgi__.http.routes[''].keys() Q: How can I configure a unique 404 route? A: By default, Hug will call documentation_404() if no HTTP route is found. However, if you want to configure other options (such as routing to a directiory, or routing everything else to a landing page) you can use the @hug.sink('/') decorator to create a \"catch-all\" route: import hug @hug.sink ( '/all' ) def my_sink ( request ): return request . path . replace ( '/all' , '' ) For more information, check out the ROUTING.md file within the hug/documentation directory. Q: How can I enable CORS A: There are many solutions depending on the specifics of your application. For most applications, you can use the included cors middleware: import hug api = hug . API ( __name__ ) api . http . add_middleware ( hug . middleware . CORSMiddleware ( api , max_age = 10 )) @hug.get ( \"/demo\" ) def get_demo (): return { \"result\" : \"Hello World\" } For cases that are more complex then the middleware handles This comment (and the discussion around it) give a good starting off point.","title":"Faq"},{"location":"FAQ/#frequently-asked-questions-about-hug","text":"For more examples, check out Hug's documentation and examples Github directories, and its website .","title":"Frequently Asked Questions about Hug"},{"location":"FAQ/#general-questions","text":"Q: Can I use Hug with a web framework -- Django for example? A: You can use Hug alongside Django or the web framework of your choice, but it does have drawbacks. You would need to run hug on a separate, hug-exclusive server. You can also mount Hug as a WSGI app , embedded within your normal Django app. Q: Is Hug compatabile with Python 2? A: Python 2 is not supported by Hug. However, if you need to account for backwards compatability, there are workarounds. For example, you can wrap the decorators: def my_get_fn ( func , * args , ** kwargs ): if 'hug' in globals (): return hug . get ( func , * args , ** kwargs ) return func","title":"General Questions"},{"location":"FAQ/#technical-questions","text":"Q: I need to ensure the security of my data. Can Hug be used over HTTPS? A: Not directly, but you can utilize uWSGI with nginx to transmit sensitive data. HTTPS is not part of the standard WSGI application layer, so you must use a WSGI HTTP server (such as uWSGI) to run in production. With this setup, Nginx handles SSL connections, and transfers requests to uWSGI. Q: How can I serve static files from a directory using Hug? A: For a static HTML page, you can just set the proper output format as: output=hug.output_format.html . To see other examples, check out the html_serve example, the image_serve example, and the more general static_serve example within hug/examples . Most basic examples will use a format that looks something like this: @hug.static ( '/static' ) \ufffc def my_static_dirs (): \ufffc return ( '/home/www/path-to-static-dir' ) Q: Does Hug support autoreloading? A: Hug supports any WSGI server that uses autoreloading, for example Gunicorn and uWSGI. The scripts for initializing autoreload for them are, respectively: Gunicorn: gunicorn --reload app:__hug_wsgi__ uWSGI: --py-autoreload 1 --http :8000 -w app:__hug_wsgi__ Q: How can I access a list of my routes? A: You can access a list of your routes by using the routes object on the HTTP API: __hug_wsgi__.http.routes It will return to you a structure of \"base_url -> url -> HTTP method -> Version -> Python Handler\". Therefore, for example, if you have no base_url set and you want to see the list of all URLS, you could run: __hug_wsgi__.http.routes[''].keys() Q: How can I configure a unique 404 route? A: By default, Hug will call documentation_404() if no HTTP route is found. However, if you want to configure other options (such as routing to a directiory, or routing everything else to a landing page) you can use the @hug.sink('/') decorator to create a \"catch-all\" route: import hug @hug.sink ( '/all' ) def my_sink ( request ): return request . path . replace ( '/all' , '' ) For more information, check out the ROUTING.md file within the hug/documentation directory. Q: How can I enable CORS A: There are many solutions depending on the specifics of your application. For most applications, you can use the included cors middleware: import hug api = hug . API ( __name__ ) api . http . add_middleware ( hug . middleware . CORSMiddleware ( api , max_age = 10 )) @hug.get ( \"/demo\" ) def get_demo (): return { \"result\" : \"Hello World\" } For cases that are more complex then the middleware handles This comment (and the discussion around it) give a good starting off point.","title":"Technical Questions"},{"location":"SECURITY/","text":"Security Policy hug takes security and quality seriously. This focus is why we depend only on thoroughly tested components and utilize static analysis tools (such as bandit and safety) to verify the security of our code base. If you find or encounter any potential security issues, please let us know right away so we can resolve them. Supported Versions Version Supported 2.5.6 :white_check_mark: Currently, only the latest version of hug will receive security fixes. Reporting a Vulnerability To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure.","title":"Security"},{"location":"SECURITY/#security-policy","text":"hug takes security and quality seriously. This focus is why we depend only on thoroughly tested components and utilize static analysis tools (such as bandit and safety) to verify the security of our code base. If you find or encounter any potential security issues, please let us know right away so we can resolve them.","title":"Security Policy"},{"location":"SECURITY/#supported-versions","text":"Version Supported 2.5.6 :white_check_mark: Currently, only the latest version of hug will receive security fixes.","title":"Supported Versions"},{"location":"SECURITY/#reporting-a-vulnerability","text":"To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure.","title":"Reporting a Vulnerability"},{"location":"benchmarks/http/RESULTS/","text":"Latest benchmark results: hug_test: Requests per second: 7518.20 [#/sec] (mean) Complete requests: 20000 falcon_test: Requests per second: 8186.67 [#/sec] (mean) Complete requests: 20000 flask_test: Requests per second: 5536.62 [#/sec] (mean) Complete requests: 20000 bobo_test: Requests per second: 6572.28 [#/sec] (mean) Complete requests: 20000 cherrypy_test: Requests per second: 3404.87 [#/sec] (mean) Complete requests: 20000 pyramid_test: Requests per second: 5961.53 [#/sec] (mean) Complete requests: 20000","title":"RESULTS"},{"location":"documentation/AUTHENTICATION/","text":"Authentication in hug Hug supports a number of authentication methods which handle the http headers for you and lets you very simply link them with your own authentication logic. To use hug's authentication, when defining an interface, you add a requires keyword argument to your @get (or other http verb) decorator. The argument to requires is a function , which returns either False , if the authentication fails, or a python object which represents the user. The function is wrapped by a wrapper from the hug.authentication.* module which handles the http header fields. That python object can be anything. In very simple cases it could be a string containing the user's username. If your application is using a database with an ORM such as peewee , then this object can be more complex and map to a row in a database table. To access the user object, you need to use the hug.directives.user directive in your declaration. @hug . get ( requires = ) def handler ( user : hug . directives . user ) This directive supplies the user object. Hug will have already handled the authentication, and rejected any requests with bad credentials with a 401 code, so you can just assume that the user is valid in your logic. Type of Authentication Hug Authenticator Wrapper Header Name Header Content Arguments to wrapped verification function Basic Authentication hug.authenticaton.basic Authorization \"Basic XXXX\" where XXXX is username:password encoded in Base64 username, password Token Authentication hug.authentication.token Authorization the token as a string token API Key Authentication hug.authentication.api_key X-Api-Key the API key as a string api-key","title":"Authentication"},{"location":"documentation/AUTHENTICATION/#authentication-in-hug","text":"Hug supports a number of authentication methods which handle the http headers for you and lets you very simply link them with your own authentication logic. To use hug's authentication, when defining an interface, you add a requires keyword argument to your @get (or other http verb) decorator. The argument to requires is a function , which returns either False , if the authentication fails, or a python object which represents the user. The function is wrapped by a wrapper from the hug.authentication.* module which handles the http header fields. That python object can be anything. In very simple cases it could be a string containing the user's username. If your application is using a database with an ORM such as peewee , then this object can be more complex and map to a row in a database table. To access the user object, you need to use the hug.directives.user directive in your declaration. @hug . get ( requires = ) def handler ( user : hug . directives . user ) This directive supplies the user object. Hug will have already handled the authentication, and rejected any requests with bad credentials with a 401 code, so you can just assume that the user is valid in your logic. Type of Authentication Hug Authenticator Wrapper Header Name Header Content Arguments to wrapped verification function Basic Authentication hug.authenticaton.basic Authorization \"Basic XXXX\" where XXXX is username:password encoded in Base64 username, password Token Authentication hug.authentication.token Authorization the token as a string token API Key Authentication hug.authentication.api_key X-Api-Key the API key as a string api-key","title":"Authentication in hug"},{"location":"documentation/CUSTOM_CONTEXT/","text":"Context factory in hug There is a concept of a 'context' in falcon, which is a dict that lives through the whole request. It is used to integrate for example SQLAlchemy library. However, in hug's case you would expect the context to work in each interface, not only the http one based on falcon. That is why hug provides its own context, that can be used in all interfaces. If you want to see the context in action, see the examples. Create context By default, the hug creates also a simple dict object as the context. However, you are able to define your own context by using the context_factory decorator. @hug.create_context () def context_factory ( * args , ** kwargs ): return dict () Arguments that are provided to the factory are almost the same as the ones provided to the directive (api, api_version, interface and interface specific arguments). For exact arguments, go to the interface definition. Delete context After the call is finished, the context is deleted. If you want to do something else with the context at the end, you can override the default behaviour by the delete_context decorator. @hug.delete_context () def delete_context ( context , exception = None , errors = None , lacks_requirement = None ): pass This function takes the context and some arguments that informs us about the result of the call's execution. If the call missed the requirements, the reason will be in lacks_requirements, errors will contain the result of the validation (None if call has passed the validation) and exception if there was any exception in the call. Note that if you use cli interface, the errors will contain a string with the first not passed validation. Otherwise, you will get a dict with errors. Where can I use the context? The context can be used in the authentication, directives and validation. The function used as an api endpoint should not get to the context directly, only using the directives. Authentication To use the context in the authentication function, you need to add an additional argument as the context. Using the context, you can for example check if the credentials meet the criteria basing on the connection with the database. Here are the examples: @hug.authentication.basic def context_basic_authentication ( username , password , context ): if username == context [ 'username' ] and password == context [ 'password' ]: return True @hug.authentication.api_key def context_api_key_authentication ( api_key , context ): if api_key == 'Bacon' : return 'Timothy' @hug.authentication.token def context_token_authentication ( token , context ): if token == precomptoken : return 'Timothy' Directives Here is an example of a directive that has access to the context: @hug.directive () def custom_directive ( context = None , ** kwargs ): return 'custom' Validation Hug types You can get the context by creating your own custom hug type. You can extend a regular hug type, as in example below: @hug.type ( chain = True , extend = hug . types . number , accept_context = True ) def check_if_near_the_right_number ( value , context ): the_only_right_number = context [ 'the_only_right_number' ] if value not in [ the_only_right_number - 1 , the_only_right_number , the_only_right_number + 1 , ]: raise ValueError ( 'Not near the right number' ) return value You can also chain extend a custom hug type that you created before. Keep in mind that if you marked that the type that you are extending is using the context, all the types that are extending it should also use the context. @hug.type ( chain = True , extend = check_if_near_the_right_number , accept_context = True ) def check_if_the_only_right_number ( value , context ): if value != context [ 'the_only_right_number' ]: raise ValueError ( 'Not the right number' ) return value It is possible to extend a hug type without the chain option, but still using the context: @hug.type ( chain = False , extend = hug . types . number , accept_context = True ) def check_if_string_has_right_value ( value , context ): if str ( context [ 'the_only_right_number' ]) not in value : raise ValueError ( 'The value does not contain the only right number' ) return value Marshmallow schema Marshmallow library also have a concept of the context, so hug also populates the context here. class MarshmallowContextSchema ( Schema ): name = fields . String () @validates_schema def check_context ( self , data ): self . context [ 'marshmallow' ] += 1 @hug.get () def made_up_hello ( test : MarshmallowContextSchema ()): return 'hi' What can be a context? Basically, the answer is everything. For example you can keep all the necessary database sessions in the context and also you can keep there all the resources that need to be dealt with after the execution of the endpoint. In delete_context function you can resolve all the dependencies between the databases' management. See the examples to see what can be achieved. Do not forget to add your own example if you find an another usage!","title":"Custom Context"},{"location":"documentation/CUSTOM_CONTEXT/#context-factory-in-hug","text":"There is a concept of a 'context' in falcon, which is a dict that lives through the whole request. It is used to integrate for example SQLAlchemy library. However, in hug's case you would expect the context to work in each interface, not only the http one based on falcon. That is why hug provides its own context, that can be used in all interfaces. If you want to see the context in action, see the examples.","title":"Context factory in hug"},{"location":"documentation/CUSTOM_CONTEXT/#create-context","text":"By default, the hug creates also a simple dict object as the context. However, you are able to define your own context by using the context_factory decorator. @hug.create_context () def context_factory ( * args , ** kwargs ): return dict () Arguments that are provided to the factory are almost the same as the ones provided to the directive (api, api_version, interface and interface specific arguments). For exact arguments, go to the interface definition.","title":"Create context"},{"location":"documentation/CUSTOM_CONTEXT/#delete-context","text":"After the call is finished, the context is deleted. If you want to do something else with the context at the end, you can override the default behaviour by the delete_context decorator. @hug.delete_context () def delete_context ( context , exception = None , errors = None , lacks_requirement = None ): pass This function takes the context and some arguments that informs us about the result of the call's execution. If the call missed the requirements, the reason will be in lacks_requirements, errors will contain the result of the validation (None if call has passed the validation) and exception if there was any exception in the call. Note that if you use cli interface, the errors will contain a string with the first not passed validation. Otherwise, you will get a dict with errors.","title":"Delete context"},{"location":"documentation/CUSTOM_CONTEXT/#where-can-i-use-the-context","text":"The context can be used in the authentication, directives and validation. The function used as an api endpoint should not get to the context directly, only using the directives.","title":"Where can I use the context?"},{"location":"documentation/CUSTOM_CONTEXT/#authentication","text":"To use the context in the authentication function, you need to add an additional argument as the context. Using the context, you can for example check if the credentials meet the criteria basing on the connection with the database. Here are the examples: @hug.authentication.basic def context_basic_authentication ( username , password , context ): if username == context [ 'username' ] and password == context [ 'password' ]: return True @hug.authentication.api_key def context_api_key_authentication ( api_key , context ): if api_key == 'Bacon' : return 'Timothy' @hug.authentication.token def context_token_authentication ( token , context ): if token == precomptoken : return 'Timothy'","title":"Authentication"},{"location":"documentation/CUSTOM_CONTEXT/#directives","text":"Here is an example of a directive that has access to the context: @hug.directive () def custom_directive ( context = None , ** kwargs ): return 'custom'","title":"Directives"},{"location":"documentation/CUSTOM_CONTEXT/#validation","text":"","title":"Validation"},{"location":"documentation/CUSTOM_CONTEXT/#hug-types","text":"You can get the context by creating your own custom hug type. You can extend a regular hug type, as in example below: @hug.type ( chain = True , extend = hug . types . number , accept_context = True ) def check_if_near_the_right_number ( value , context ): the_only_right_number = context [ 'the_only_right_number' ] if value not in [ the_only_right_number - 1 , the_only_right_number , the_only_right_number + 1 , ]: raise ValueError ( 'Not near the right number' ) return value You can also chain extend a custom hug type that you created before. Keep in mind that if you marked that the type that you are extending is using the context, all the types that are extending it should also use the context. @hug.type ( chain = True , extend = check_if_near_the_right_number , accept_context = True ) def check_if_the_only_right_number ( value , context ): if value != context [ 'the_only_right_number' ]: raise ValueError ( 'Not the right number' ) return value It is possible to extend a hug type without the chain option, but still using the context: @hug.type ( chain = False , extend = hug . types . number , accept_context = True ) def check_if_string_has_right_value ( value , context ): if str ( context [ 'the_only_right_number' ]) not in value : raise ValueError ( 'The value does not contain the only right number' ) return value","title":"Hug types"},{"location":"documentation/CUSTOM_CONTEXT/#marshmallow-schema","text":"Marshmallow library also have a concept of the context, so hug also populates the context here. class MarshmallowContextSchema ( Schema ): name = fields . String () @validates_schema def check_context ( self , data ): self . context [ 'marshmallow' ] += 1 @hug.get () def made_up_hello ( test : MarshmallowContextSchema ()): return 'hi'","title":"Marshmallow schema"},{"location":"documentation/CUSTOM_CONTEXT/#what-can-be-a-context","text":"Basically, the answer is everything. For example you can keep all the necessary database sessions in the context and also you can keep there all the resources that need to be dealt with after the execution of the endpoint. In delete_context function you can resolve all the dependencies between the databases' management. See the examples to see what can be achieved. Do not forget to add your own example if you find an another usage!","title":"What can be a context?"},{"location":"documentation/DIRECTIVES/","text":"hug directives (automatic argument injection) Oftentimes you'll find yourself needing something particular to an interface (say a header, a session, or content_type), but don't want to tie your function to a single interface. To support this, hug introduces the concept of directives . In hug, directives are simply arguments that have been registered to automatically provide a parameter value based on knowledge known to the interface. For example, this is the built-in session directive: @ hug . directive () def session ( context_name = ' session ' , request = None , ** kwargs ) : \"\"\" Returns the session associated with the current request \"\"\" return request and request . context . get ( context_name , None ) or None Then, when using this directive in your code, you can either specify the directive via type annotation: @hug . get () def my_endpoint ( session : hug . directives . session ) : session # is here automatically , without needing to be passed in Or by prefixing the argument with hug_ : @hug . get () def my_endpoint ( hug_session ) : session # is here automatically , without needing to be passed in You can then specify a different location for the hug session, simply by providing a default for the argument: @hug . get () def my_endpoint ( hug_session = 'alternative_session_key' ) : session # is here automatically , without needing to be passed in Built-in directives hug provides a handful of directives for commonly needed attributes: hug.directives.Timer (hug_timer=precision): Stores the time the interface was initially called, returns how much time has passed since the function was called, if casted as a float. Automatically converts to the time taken when returned as part of a JSON structure. The default value specifies the float precision desired when keeping track of the time passed. hug.directives.module (hug_module): Passes along the module that contains the API associated with this endpoint. hug.directives.api (hug_api): Passes along the hug API singleton associated with this endpoint. hug.directives.api_version (hug_api_version): Passes along the version of the API being called. hug.directives.documentation (hug_documentation): Generates and passes along the entire set of documentation for the API that contains the endpoint. hug.directives.session (hug_session=context_name): Passes along the session associated with the current request. The default value provides a different key whose value is stored on the request.context object. hug.directives.user (hug_user): Passes along the user object associated with the request. hug.directives.CurrentAPI (hug_current_api): Passes along a smart, version-aware API caller, to enable calling other functions within your API, with reassurance that the correct function is being called for the version of the API being requested. Building custom directives hug provides the @hug.directive() to enable creation of new directives. It takes one argument: apply_globally, which defaults to False. If you set this parameter to True, the hug directive will be automatically made available as a magic hug_ argument on all endpoints outside of your defined API. This is not a concern if you're applying directives via type annotation. The most basic directive will take an optional default value, as well as **kwargs: @ hug . directive () def basic ( default = False , ** kwargs ) : return str ( default ) + ' there! ' This directive could then be used like this: @ hug . local () def endpoint ( hug_basic = ' hi ' ) : return hug_basic assert endpoint () == ' hi there! ' It's important to always accept **kwargs for directive functions, as each interface gets to decide its own set of keyword arguments to send to the directive, which can then be used to pull in information for the directive. Common directive key word parameters Independent of interface, the following key word arguments will be passed to the directive: interface - The interface that the directive is being run through. Useful for conditionally injecting data (via the decorator) depending on the interface it is being called through, as demonstrated at the bottom of this section. api - The API singleton associated with this endpoint. Interface Example: @ directive () def my_directive ( default = None , interface = None , ** kwargs ) : if interface == hug . interface . CLI : return ' CLI specific ' elif interface == hug . interface . HTTP : return ' HTTP specific ' elif interface == hug . interface . Local : return ' Local ' return ' unknown ' HTTP directive key word parameters Directives are passed the following additional keyword parameters when they are being run through an HTTP interface: response : The HTTP response object that will be returned for this request. request : The HTTP request object that caused this interface to be called. api_version : The version of the endpoint being hit. CLI directive key word parameters Directives get one additional argument when they are run through a command line interface: argparse : The argparse instance created to parse command line arguments.","title":"Directives"},{"location":"documentation/DIRECTIVES/#hug-directives-automatic-argument-injection","text":"Oftentimes you'll find yourself needing something particular to an interface (say a header, a session, or content_type), but don't want to tie your function to a single interface. To support this, hug introduces the concept of directives . In hug, directives are simply arguments that have been registered to automatically provide a parameter value based on knowledge known to the interface. For example, this is the built-in session directive: @ hug . directive () def session ( context_name = ' session ' , request = None , ** kwargs ) : \"\"\" Returns the session associated with the current request \"\"\" return request and request . context . get ( context_name , None ) or None Then, when using this directive in your code, you can either specify the directive via type annotation: @hug . get () def my_endpoint ( session : hug . directives . session ) : session # is here automatically , without needing to be passed in Or by prefixing the argument with hug_ : @hug . get () def my_endpoint ( hug_session ) : session # is here automatically , without needing to be passed in You can then specify a different location for the hug session, simply by providing a default for the argument: @hug . get () def my_endpoint ( hug_session = 'alternative_session_key' ) : session # is here automatically , without needing to be passed in","title":"hug directives (automatic argument injection)"},{"location":"documentation/DIRECTIVES/#built-in-directives","text":"hug provides a handful of directives for commonly needed attributes: hug.directives.Timer (hug_timer=precision): Stores the time the interface was initially called, returns how much time has passed since the function was called, if casted as a float. Automatically converts to the time taken when returned as part of a JSON structure. The default value specifies the float precision desired when keeping track of the time passed. hug.directives.module (hug_module): Passes along the module that contains the API associated with this endpoint. hug.directives.api (hug_api): Passes along the hug API singleton associated with this endpoint. hug.directives.api_version (hug_api_version): Passes along the version of the API being called. hug.directives.documentation (hug_documentation): Generates and passes along the entire set of documentation for the API that contains the endpoint. hug.directives.session (hug_session=context_name): Passes along the session associated with the current request. The default value provides a different key whose value is stored on the request.context object. hug.directives.user (hug_user): Passes along the user object associated with the request. hug.directives.CurrentAPI (hug_current_api): Passes along a smart, version-aware API caller, to enable calling other functions within your API, with reassurance that the correct function is being called for the version of the API being requested.","title":"Built-in directives"},{"location":"documentation/DIRECTIVES/#building-custom-directives","text":"hug provides the @hug.directive() to enable creation of new directives. It takes one argument: apply_globally, which defaults to False. If you set this parameter to True, the hug directive will be automatically made available as a magic hug_ argument on all endpoints outside of your defined API. This is not a concern if you're applying directives via type annotation. The most basic directive will take an optional default value, as well as **kwargs: @ hug . directive () def basic ( default = False , ** kwargs ) : return str ( default ) + ' there! ' This directive could then be used like this: @ hug . local () def endpoint ( hug_basic = ' hi ' ) : return hug_basic assert endpoint () == ' hi there! ' It's important to always accept **kwargs for directive functions, as each interface gets to decide its own set of keyword arguments to send to the directive, which can then be used to pull in information for the directive.","title":"Building custom directives"},{"location":"documentation/DIRECTIVES/#common-directive-key-word-parameters","text":"Independent of interface, the following key word arguments will be passed to the directive: interface - The interface that the directive is being run through. Useful for conditionally injecting data (via the decorator) depending on the interface it is being called through, as demonstrated at the bottom of this section. api - The API singleton associated with this endpoint. Interface Example: @ directive () def my_directive ( default = None , interface = None , ** kwargs ) : if interface == hug . interface . CLI : return ' CLI specific ' elif interface == hug . interface . HTTP : return ' HTTP specific ' elif interface == hug . interface . Local : return ' Local ' return ' unknown '","title":"Common directive key word parameters"},{"location":"documentation/DIRECTIVES/#http-directive-key-word-parameters","text":"Directives are passed the following additional keyword parameters when they are being run through an HTTP interface: response : The HTTP response object that will be returned for this request. request : The HTTP request object that caused this interface to be called. api_version : The version of the endpoint being hit.","title":"HTTP directive key word parameters"},{"location":"documentation/DIRECTIVES/#cli-directive-key-word-parameters","text":"Directives get one additional argument when they are run through a command line interface: argparse : The argparse instance created to parse command line arguments.","title":"CLI directive key word parameters"},{"location":"documentation/OUTPUT_FORMATS/","text":"hug output formats Every endpoint that is exposed through an externally facing interface will need to return data in a standard, easily understandable format. The default output format for all hug APIs is JSON. However, you may explicitly specify a different default output_format for a particular API: hug . API ( __name__ ). http . output_format = hug . output_format . html or: @hug . default_output_format () def my_output_formatter ( data , request , response ) : # Custom output formatting code By default, this only applies to the output format of HTTP responses. To change the output format of the command line interface: @hug . default_output_format ( cli = True , http = False ) def my_output_formatter ( data , request , response ) : # Custom output formatting code To specify an output_format for a specific endpoint, simply specify the output format within its router: @ hug . get ( output = hug . output_format . html ) def my_endpoint () : return # HTML generating code goes here You can use route chaining to specify an output format for a group of endpoints within an API: html = hug . get ( output = hug . output_format . html ) @ html def my_endpoint_1 () : return # HTML generating code goes here @ html . urls ( ' / ' ) def root () : return # HTML generating code goes here Finally, an output format may be a collection of different output formats that get used conditionally. For example, using the built-in suffix output format: suffix_output = hug . output_format . suffix ( { ' .js ' : hug . output_format . json , ' .html ' : hug . output_format . html } ) @ hug . get (( ' my_endpoint.js ' , ' my_endoint.html ' ) , output = suffix_output ) def my_endpoint () : return '' In this case, if the endpoint is accessed via my_endpoint.js, the output type will be JSON; however if it's accessed via my_endoint.html, the output type will be HTML. You can also change the default output format globally for all APIs with either: @hug . default_output_format ( apply_globally = True , cli = True , http = True ) def my_output_formatter ( data , request , response ) : # Custom output formatting code or: hug . defaults . output_format = hug . output_format . html # for HTTP hug . defaults . cli_output_format = hug . output_format . html # for the CLI Note that when extending APIs, changing the default output format globally must be done before importing the modules of any of the sub-APIs: hug . defaults . cli_output_format = hug . output_format . html from my_app import my_sub_api @hug.extend_api () def extended (): return [ my_sub_api ] Built-in hug output formats hug provides a large catalog of built-in output formats, which can be used to build useful APIs right away: hug.output_format.json : The default hug output formatter for all endpoints; outputs in Javascript Serialized Object Notation (JSON). hug.output_format.text : Outputs in a plain text format. hug.output_format.html : Outputs Hyper Text Markup Language (HTML). hug.output_format.json_camelcase : Outputs in the JSON format, but first converts all keys to camelCase to better conform to Javascript coding standards. hug.output_format.pretty_json : Outputs in the JSON format, with extra whitespace to improve human readability. hug.output_format.image(format) : Outputs an image (of the specified format). There are convenience calls in the form `hug.output_format.{FORMAT}_image for the following image types: 'png', 'jpg', 'bmp', 'eps', 'gif', 'im', 'jpeg', 'msp', 'pcx', 'ppm', 'spider', 'tiff', 'webp', 'xbm', 'cur', 'dcx', 'fli', 'flc', 'gbr', 'gd', 'ico', 'icns', 'imt', 'iptc', 'naa', 'mcidas', 'mpo', 'pcd', 'psd', 'sgi', 'tga', 'wal', 'xpm', and 'svg'. Automatically works on returned file names, streams, or objects that produce an image on read, save, or render. hug.output_format.video(video_type, video_mime, doc) : Streams a video back to the user in the specified format. There are convenience calls in the form `hug.output_format.{FORMAT}_video for the following video types: 'flv', 'mp4', 'm3u8', 'ts', '3gp', 'mov', 'avi', and 'wmv'. Automatically works on returned file names, streams, or objects that produce a video on read, save, or render. hug.output_format.file : Will dynamically determine and stream a file based on its content. Automatically works on returned file names and streams. hug.output_format.on_content_type(handlers={content_type: output_format}, default=None) : Dynamically changes the output format based on the request content type. hug.output_format.suffix(handlers={suffix: output_format}, default=None) : Dynamically changes the output format based on a suffix at the end of the requested path. hug.output_format.prefix(handlers={suffix: output_format}, default=None) : Dynamically changes the output format based on a prefix at the beginning of the requested path. Creating a custom output format An output format is simply a function with a content type attached that takes a data argument, and optionally a request and response, and returns properly encoded and formatted data: @ hug . format . content_type ( ' file/text ' ) def format_as_text ( data , request = None , response = None ) : return str ( data ) . encode ( ' utf8 ' ) A common pattern is to only apply the output format. Validation errors aren't passed in, since it's hard to deal with this for several formats (such as images), and it may make more sense to simply return the error as JSON. hug makes this pattern simple, as well, with the hug.output_format.on_valid decorator: @ hug . output_format . on_valid ( ' file/text ' ) def format_as_text_when_valid ( data , request = None , response = None ) : return str ( data ) . encode ( ' utf8 ' )","title":"Output Formats"},{"location":"documentation/OUTPUT_FORMATS/#hug-output-formats","text":"Every endpoint that is exposed through an externally facing interface will need to return data in a standard, easily understandable format. The default output format for all hug APIs is JSON. However, you may explicitly specify a different default output_format for a particular API: hug . API ( __name__ ). http . output_format = hug . output_format . html or: @hug . default_output_format () def my_output_formatter ( data , request , response ) : # Custom output formatting code By default, this only applies to the output format of HTTP responses. To change the output format of the command line interface: @hug . default_output_format ( cli = True , http = False ) def my_output_formatter ( data , request , response ) : # Custom output formatting code To specify an output_format for a specific endpoint, simply specify the output format within its router: @ hug . get ( output = hug . output_format . html ) def my_endpoint () : return # HTML generating code goes here You can use route chaining to specify an output format for a group of endpoints within an API: html = hug . get ( output = hug . output_format . html ) @ html def my_endpoint_1 () : return # HTML generating code goes here @ html . urls ( ' / ' ) def root () : return # HTML generating code goes here Finally, an output format may be a collection of different output formats that get used conditionally. For example, using the built-in suffix output format: suffix_output = hug . output_format . suffix ( { ' .js ' : hug . output_format . json , ' .html ' : hug . output_format . html } ) @ hug . get (( ' my_endpoint.js ' , ' my_endoint.html ' ) , output = suffix_output ) def my_endpoint () : return '' In this case, if the endpoint is accessed via my_endpoint.js, the output type will be JSON; however if it's accessed via my_endoint.html, the output type will be HTML. You can also change the default output format globally for all APIs with either: @hug . default_output_format ( apply_globally = True , cli = True , http = True ) def my_output_formatter ( data , request , response ) : # Custom output formatting code or: hug . defaults . output_format = hug . output_format . html # for HTTP hug . defaults . cli_output_format = hug . output_format . html # for the CLI Note that when extending APIs, changing the default output format globally must be done before importing the modules of any of the sub-APIs: hug . defaults . cli_output_format = hug . output_format . html from my_app import my_sub_api @hug.extend_api () def extended (): return [ my_sub_api ]","title":"hug output formats"},{"location":"documentation/OUTPUT_FORMATS/#built-in-hug-output-formats","text":"hug provides a large catalog of built-in output formats, which can be used to build useful APIs right away: hug.output_format.json : The default hug output formatter for all endpoints; outputs in Javascript Serialized Object Notation (JSON). hug.output_format.text : Outputs in a plain text format. hug.output_format.html : Outputs Hyper Text Markup Language (HTML). hug.output_format.json_camelcase : Outputs in the JSON format, but first converts all keys to camelCase to better conform to Javascript coding standards. hug.output_format.pretty_json : Outputs in the JSON format, with extra whitespace to improve human readability. hug.output_format.image(format) : Outputs an image (of the specified format). There are convenience calls in the form `hug.output_format.{FORMAT}_image for the following image types: 'png', 'jpg', 'bmp', 'eps', 'gif', 'im', 'jpeg', 'msp', 'pcx', 'ppm', 'spider', 'tiff', 'webp', 'xbm', 'cur', 'dcx', 'fli', 'flc', 'gbr', 'gd', 'ico', 'icns', 'imt', 'iptc', 'naa', 'mcidas', 'mpo', 'pcd', 'psd', 'sgi', 'tga', 'wal', 'xpm', and 'svg'. Automatically works on returned file names, streams, or objects that produce an image on read, save, or render. hug.output_format.video(video_type, video_mime, doc) : Streams a video back to the user in the specified format. There are convenience calls in the form `hug.output_format.{FORMAT}_video for the following video types: 'flv', 'mp4', 'm3u8', 'ts', '3gp', 'mov', 'avi', and 'wmv'. Automatically works on returned file names, streams, or objects that produce a video on read, save, or render. hug.output_format.file : Will dynamically determine and stream a file based on its content. Automatically works on returned file names and streams. hug.output_format.on_content_type(handlers={content_type: output_format}, default=None) : Dynamically changes the output format based on the request content type. hug.output_format.suffix(handlers={suffix: output_format}, default=None) : Dynamically changes the output format based on a suffix at the end of the requested path. hug.output_format.prefix(handlers={suffix: output_format}, default=None) : Dynamically changes the output format based on a prefix at the beginning of the requested path.","title":"Built-in hug output formats"},{"location":"documentation/OUTPUT_FORMATS/#creating-a-custom-output-format","text":"An output format is simply a function with a content type attached that takes a data argument, and optionally a request and response, and returns properly encoded and formatted data: @ hug . format . content_type ( ' file/text ' ) def format_as_text ( data , request = None , response = None ) : return str ( data ) . encode ( ' utf8 ' ) A common pattern is to only apply the output format. Validation errors aren't passed in, since it's hard to deal with this for several formats (such as images), and it may make more sense to simply return the error as JSON. hug makes this pattern simple, as well, with the hug.output_format.on_valid decorator: @ hug . output_format . on_valid ( ' file/text ' ) def format_as_text_when_valid ( data , request = None , response = None ) : return str ( data ) . encode ( ' utf8 ' )","title":"Creating a custom output format"},{"location":"documentation/ROUTING/","text":"Routing in hug The most basic function of any framework meant to enable external interaction with an API, is routing how the external interaction will correspond to internal function calls and business logic. hug provides flexible and powerful routers that aim to scale intuitively from simple use-cases to complex. To enable this all hug routers share 3 attributes: Can be used directly as function decorators Can be used separately from the function Can be stored, modified, and chained before being used And, while hug uses functions in most of its examples, it supports applying routes to methods and objects as well. All hug routers enforce type annotation and enable automatic argument supplying via directives. Using a router as a decorator The most basic use case is to simply define the route directly above the function you need to expose as a decorator: import hug @hug.get ( '/home' ) def root (): return 'Welcome home!' This is clear, explicit, and obvious. As such, this is recommended for most basic APIs. Declaring a router separate from a function Sometimes, in more complex use-cases, it's necessary to define routing separate from where the code itself is defined. hug aims to make this as easy and intuitive as it can be: Internal API: # internal . py def root () : return ' Welcome home! ' External API: # external.py import hug import internal router = hug . route . API ( __name__ ) router . get ( '/home' )( internal . root ) Or, alternatively: # external.py import hug import internal api = hug . API ( __name__ ) hug . get ( '/home' , api = api )( internal . root ) Chaining routers for easy re-use A very common scenario when using hug routers, because they are so powerful, is duplication between routers. For instance: if you decide you want every route to return the 404 page when a validation error occurs or you want to require validation for a collection of routes. hug makes this extremely simple by allowing all routes to be chained and reused: import hug api = hug . get ( on_invalid = hug . redirect . not_found ) @api.urls ( '/do-math' , examples = 'number_1=1&number_2=2' ) def math ( number_1 : hug . types . number , number_2 : hug . types . number ): return number_1 + number_2 @api def happy_birthday ( name , age : hug . types . number ): \"\"\"Says happy birthday to a user\"\"\" return \"Happy {age} Birthday {name}!\" . format ( ** locals ()) It's important to note that to chain you simply call the argument you would normally pass in to the routers init function as a method on the existing router. Then you pass in any additional parameters you would like to override as **kwargs - as shown in the math example above. Common router parameters There are a few parameters that are shared between all router types, as they are globally applicable to all currently supported interfaces: api : The API to register the route with. You can always retrieve the API singleton for the current module by doing hug.API(__name__) transform : A function to call on the the data returned by the function to transform it in some way specific to this interface output : An output format to apply to the outputted data (after return and optional transformation) requires : A list or single function that must all return True for the function to execute when called via this interface (commonly used for authentication) HTTP Routers in addition to hug.http hug includes convenience decorators for all common HTTP METHODS ( hug.connect , hug.delete , hug.get , hug.head , hug.options , hug.patch , hug.post , hug.put , hug.get_post , hug.put_post , and hug.trace ). These methods are functionally the same as calling @hug.http(accept=(METHOD, )) and are otherwise identical to the http router. urls : A list of or a single URL that should be routed to the function. Supports defining variables within the URL that will automatically be passed to the function when {} notation is found in the URL: /website/{page} . Defaults to the name of the function being routed to. accept : A list of or a single HTTP METHOD value to accept. Defaults to all common HTTP methods. examples : A list of or a single example set of parameters in URL query param format. For example: examples=\"argument_1=x&argument_2=y\" versions : A list of or a single integer version of the API this endpoint supports. To support a range of versions the Python builtin range function can be used. suffixes : A list of or a single suffix to add to the end of all URLs using this router. prefixes : A list of or a single prefix to add before all URLs using this router. response_headers : An optional dictionary of response headers to set automatically on every request to this endpoint. status : An optional status code to automatically apply to the response on every request to this endpoint. parse_body : If True and the format of the request body matches one known by hug, hug will run the specified input formatter on the request body before passing it as an argument to the routed function. Defaults to True . on_invalid : A transformation function to run outputed data through, only if the request fails validation. Defaults to the endpoints specified general transform function, can be set to not run at all by setting to None . output_invalid : Specifies an output format to attach to the endpoint only on the case that validation fails. Defaults to the endpoints specified output format. raise_on_invalid : If set to true, instead of collecting validation errors in a dictionary, hug will simply raise them as they occur. Handling for 404 Responses By default, Hug will call documentation_404() if a user tries to access a nonexistant route when serving. If you want to specify something different, you can use the \"sink\" decorator, such as in the example below. The @hug.sink() decorator serves as a \"catch all\" for unassigned routes. import hug @hug.sink ( '/all' ) def my_sink ( request ): return request . path . replace ( '/all' , '' ) In this case, the server routes requests to anything that's no an assigned route to the landing page. To test the functionality of your sink decorator, serve your application locally, then attempt to access an unassigned route. Using this code, if you try to access localhost:8000/this-route-is-invalid , you will be rerouted to localhost:8000 . CLI Routing Any endpoint can also be exposed to the command line as well, using @hug.cli : name : The name that should execute the command from the command line. Defaults to the name of the function being routed. version : The optional version associated with this command line application. doc : Documentation to provide to users of this command line tool. Defaults to the functions doc string. Local Routing By default all hug APIs are already valid local APIs. However, sometimes it can be useful to apply type annotations and/or directives to local use as well. For these cases hug provides @hug.local : validate : Apply type annotations to local use of the function. Defaults to True . directives : Apply directives to local use of the function. Defaults to True . version : Specify a version of the API for local use. If versions are being used, this generally should be the latest supported. on_invalid : A transformation function to run outputed data through, only if the request fails validation. Defaults to the endpoints specified general transform function, can be set to not run at all by setting to None . output_invalid : Specifies an output format to attach to the endpoint only on the case that validation fails. Defaults to the endpoints specified output format. raise_on_invalid : If set to True , instead of collecting validation errors in a dictionary, hug will simply raise them as they occur. NOTE: unlike all other routers, this modifies the function in-place","title":"Routing"},{"location":"documentation/ROUTING/#routing-in-hug","text":"The most basic function of any framework meant to enable external interaction with an API, is routing how the external interaction will correspond to internal function calls and business logic. hug provides flexible and powerful routers that aim to scale intuitively from simple use-cases to complex. To enable this all hug routers share 3 attributes: Can be used directly as function decorators Can be used separately from the function Can be stored, modified, and chained before being used And, while hug uses functions in most of its examples, it supports applying routes to methods and objects as well. All hug routers enforce type annotation and enable automatic argument supplying via directives.","title":"Routing in hug"},{"location":"documentation/ROUTING/#using-a-router-as-a-decorator","text":"The most basic use case is to simply define the route directly above the function you need to expose as a decorator: import hug @hug.get ( '/home' ) def root (): return 'Welcome home!' This is clear, explicit, and obvious. As such, this is recommended for most basic APIs.","title":"Using a router as a decorator"},{"location":"documentation/ROUTING/#declaring-a-router-separate-from-a-function","text":"Sometimes, in more complex use-cases, it's necessary to define routing separate from where the code itself is defined. hug aims to make this as easy and intuitive as it can be: Internal API: # internal . py def root () : return ' Welcome home! ' External API: # external.py import hug import internal router = hug . route . API ( __name__ ) router . get ( '/home' )( internal . root ) Or, alternatively: # external.py import hug import internal api = hug . API ( __name__ ) hug . get ( '/home' , api = api )( internal . root )","title":"Declaring a router separate from a function"},{"location":"documentation/ROUTING/#chaining-routers-for-easy-re-use","text":"A very common scenario when using hug routers, because they are so powerful, is duplication between routers. For instance: if you decide you want every route to return the 404 page when a validation error occurs or you want to require validation for a collection of routes. hug makes this extremely simple by allowing all routes to be chained and reused: import hug api = hug . get ( on_invalid = hug . redirect . not_found ) @api.urls ( '/do-math' , examples = 'number_1=1&number_2=2' ) def math ( number_1 : hug . types . number , number_2 : hug . types . number ): return number_1 + number_2 @api def happy_birthday ( name , age : hug . types . number ): \"\"\"Says happy birthday to a user\"\"\" return \"Happy {age} Birthday {name}!\" . format ( ** locals ()) It's important to note that to chain you simply call the argument you would normally pass in to the routers init function as a method on the existing router. Then you pass in any additional parameters you would like to override as **kwargs - as shown in the math example above.","title":"Chaining routers for easy re-use"},{"location":"documentation/ROUTING/#common-router-parameters","text":"There are a few parameters that are shared between all router types, as they are globally applicable to all currently supported interfaces: api : The API to register the route with. You can always retrieve the API singleton for the current module by doing hug.API(__name__) transform : A function to call on the the data returned by the function to transform it in some way specific to this interface output : An output format to apply to the outputted data (after return and optional transformation) requires : A list or single function that must all return True for the function to execute when called via this interface (commonly used for authentication)","title":"Common router parameters"},{"location":"documentation/ROUTING/#http-routers","text":"in addition to hug.http hug includes convenience decorators for all common HTTP METHODS ( hug.connect , hug.delete , hug.get , hug.head , hug.options , hug.patch , hug.post , hug.put , hug.get_post , hug.put_post , and hug.trace ). These methods are functionally the same as calling @hug.http(accept=(METHOD, )) and are otherwise identical to the http router. urls : A list of or a single URL that should be routed to the function. Supports defining variables within the URL that will automatically be passed to the function when {} notation is found in the URL: /website/{page} . Defaults to the name of the function being routed to. accept : A list of or a single HTTP METHOD value to accept. Defaults to all common HTTP methods. examples : A list of or a single example set of parameters in URL query param format. For example: examples=\"argument_1=x&argument_2=y\" versions : A list of or a single integer version of the API this endpoint supports. To support a range of versions the Python builtin range function can be used. suffixes : A list of or a single suffix to add to the end of all URLs using this router. prefixes : A list of or a single prefix to add before all URLs using this router. response_headers : An optional dictionary of response headers to set automatically on every request to this endpoint. status : An optional status code to automatically apply to the response on every request to this endpoint. parse_body : If True and the format of the request body matches one known by hug, hug will run the specified input formatter on the request body before passing it as an argument to the routed function. Defaults to True . on_invalid : A transformation function to run outputed data through, only if the request fails validation. Defaults to the endpoints specified general transform function, can be set to not run at all by setting to None . output_invalid : Specifies an output format to attach to the endpoint only on the case that validation fails. Defaults to the endpoints specified output format. raise_on_invalid : If set to true, instead of collecting validation errors in a dictionary, hug will simply raise them as they occur.","title":"HTTP Routers"},{"location":"documentation/ROUTING/#handling-for-404-responses","text":"By default, Hug will call documentation_404() if a user tries to access a nonexistant route when serving. If you want to specify something different, you can use the \"sink\" decorator, such as in the example below. The @hug.sink() decorator serves as a \"catch all\" for unassigned routes. import hug @hug.sink ( '/all' ) def my_sink ( request ): return request . path . replace ( '/all' , '' ) In this case, the server routes requests to anything that's no an assigned route to the landing page. To test the functionality of your sink decorator, serve your application locally, then attempt to access an unassigned route. Using this code, if you try to access localhost:8000/this-route-is-invalid , you will be rerouted to localhost:8000 .","title":"Handling for 404 Responses"},{"location":"documentation/ROUTING/#cli-routing","text":"Any endpoint can also be exposed to the command line as well, using @hug.cli : name : The name that should execute the command from the command line. Defaults to the name of the function being routed. version : The optional version associated with this command line application. doc : Documentation to provide to users of this command line tool. Defaults to the functions doc string.","title":"CLI Routing"},{"location":"documentation/ROUTING/#local-routing","text":"By default all hug APIs are already valid local APIs. However, sometimes it can be useful to apply type annotations and/or directives to local use as well. For these cases hug provides @hug.local : validate : Apply type annotations to local use of the function. Defaults to True . directives : Apply directives to local use of the function. Defaults to True . version : Specify a version of the API for local use. If versions are being used, this generally should be the latest supported. on_invalid : A transformation function to run outputed data through, only if the request fails validation. Defaults to the endpoints specified general transform function, can be set to not run at all by setting to None . output_invalid : Specifies an output format to attach to the endpoint only on the case that validation fails. Defaults to the endpoints specified output format. raise_on_invalid : If set to True , instead of collecting validation errors in a dictionary, hug will simply raise them as they occur. NOTE: unlike all other routers, this modifies the function in-place","title":"Local Routing"},{"location":"documentation/TYPE_ANNOTATIONS/","text":"Type annotations in hug hug leverages Python3 type annotations for validation and API specification. Within the context of hug, annotations should be set to one of 4 things: A cast function, built-in, or your own (str, int, etc) that takes a value casts it and then returns it, raising an exception if it is not in a format that can be cast into the desired type A hug type (hug.types.text, hug.types.number, etc.). These are essentially built-in cast functions that provide more contextual information, and good default error messages A marshmallow type and/or schema. In hug 2.0.0 Marshmallow is a first class citizen in hug, and all fields and schemas defined with it can be used in hug as type annotations A string. When a basic Python string is set as the type annotation it is used by hug to generate documentation, but does not get applied during the validation phase For example: import hug @hug.get () def hello ( first_name : hug . types . text , last_name : 'Family Name' , age : int ): print ( \"Hi {0} {1}!\" . format ( first_name , last_name ) is a valid hug endpoint. Any time a type annotation raises an exception during casting of a type, it is seen as a failure. Otherwise the cast is assumed successful with the returned type replacing the passed-in parameter. By default, all errors are collected in an errors dictionary and returned as the output of the endpoint before the routed function ever gets called. To change how errors are returned you can transform them via the on_invalid route option, and specify a specific output format for errors by specifying the output_invalid route option. Or, if you prefer, you can keep hug from handling the validation errors at all by passing in raise_on_invalid=True to the route. Built in hug types hug provides several built-in types for common API use cases: number : Validates that a whole number was passed in float_number : Validates that a valid floating point number was passed in decimal : Validates and converts the provided value into a Python Decimal object uuid : Validates that the provided value is a valid UUID text : Validates that the provided value is a single string parameter multiple : Ensures the parameter is passed in as a list (even if only one value is passed in) boolean : A basic naive HTTP style boolean where no value passed in is seen as False and any value passed in (even if its false ) is seen as True smart_boolean : A smarter, but more computentionally expensive, boolean that checks the content of the value for common true / false formats (true, True, t, 1) or (false, False, f, 0) delimited_list(delimiter) : splits up the passed in value based on the provided delimiter and then passes it to the function as a list one_of(values) : Validates that the passed in value is one of those specified mapping(dict_of_passed_in_to_desired_values) : Like one_of , but with a dictionary of acceptable values, to converted value. multi(types) : Allows passing in multiple acceptable types for a parameter, short circuiting on the first acceptable one in_range(lower, upper, convert=number) : Accepts a number within a lower and upper bound of acceptable values less_than(limit, convert=number) : Accepts a number within a lower and upper bound of acceptable values greater_than(minimum, convert=number) : Accepts a value above a given minimum length(lower, upper, convert=text) : Accepts a a value that is within a specific length limit shorter_than(limit, convert=text) : Accepts a text value shorter than the specified length limit longer_than(limit, convert=text) : Accepts a value up to the specified limit cut_off(limit, convert=text) : Cuts off the provided value at the specified index Extending and creating new hug types The most obvious way to extend a hug type is to simply inherit from the base type defined in hug.types and then override __call__ to override how the cast function, or override __init__ to override what parameters the type takes: import hug class TheAnswer ( hug . types . Text ): \"\"\"My new documentation\"\"\" def __call__ ( self , value ): value = super () . __call__ ( value ) if value != 'fourty-two' : raise ValueError ( 'Value is not the answer to everything.' ) return value If you simply want to perform additional conversion after a base type is finished, or modify its documentation, the most succinct way is the hug.type decorator: import hug @hug.type ( extend = hug . types . number ) def the_answer ( value ): \"\"\"My new documentation\"\"\" if value != 42 : raise ValueError ( 'Value is not the answer to everything.' ) return value Marshmallow integration Marshmallow is an advanced serialization, deserialization, and validation library. Hug supports using marshmallow fields and schemas as input types. Here is a simple example of an API that does datetime addition. import datetime as dt import hug from marshmallow import fields from marshmallow.validate import Range @hug.get ( '/dateadd' , examples = \"value=1973-04-10&addend=63\" ) def dateadd ( value : fields . Date (), addend : fields . Int ( validate = Range ( min = 1 ))): \"\"\"Add a value to a date.\"\"\" delta = dt . timedelta ( days = addend ) result = value + delta return { 'result' : result }","title":"Type Annotations"},{"location":"documentation/TYPE_ANNOTATIONS/#type-annotations-in-hug","text":"hug leverages Python3 type annotations for validation and API specification. Within the context of hug, annotations should be set to one of 4 things: A cast function, built-in, or your own (str, int, etc) that takes a value casts it and then returns it, raising an exception if it is not in a format that can be cast into the desired type A hug type (hug.types.text, hug.types.number, etc.). These are essentially built-in cast functions that provide more contextual information, and good default error messages A marshmallow type and/or schema. In hug 2.0.0 Marshmallow is a first class citizen in hug, and all fields and schemas defined with it can be used in hug as type annotations A string. When a basic Python string is set as the type annotation it is used by hug to generate documentation, but does not get applied during the validation phase For example: import hug @hug.get () def hello ( first_name : hug . types . text , last_name : 'Family Name' , age : int ): print ( \"Hi {0} {1}!\" . format ( first_name , last_name ) is a valid hug endpoint. Any time a type annotation raises an exception during casting of a type, it is seen as a failure. Otherwise the cast is assumed successful with the returned type replacing the passed-in parameter. By default, all errors are collected in an errors dictionary and returned as the output of the endpoint before the routed function ever gets called. To change how errors are returned you can transform them via the on_invalid route option, and specify a specific output format for errors by specifying the output_invalid route option. Or, if you prefer, you can keep hug from handling the validation errors at all by passing in raise_on_invalid=True to the route.","title":"Type annotations in hug"},{"location":"documentation/TYPE_ANNOTATIONS/#built-in-hug-types","text":"hug provides several built-in types for common API use cases: number : Validates that a whole number was passed in float_number : Validates that a valid floating point number was passed in decimal : Validates and converts the provided value into a Python Decimal object uuid : Validates that the provided value is a valid UUID text : Validates that the provided value is a single string parameter multiple : Ensures the parameter is passed in as a list (even if only one value is passed in) boolean : A basic naive HTTP style boolean where no value passed in is seen as False and any value passed in (even if its false ) is seen as True smart_boolean : A smarter, but more computentionally expensive, boolean that checks the content of the value for common true / false formats (true, True, t, 1) or (false, False, f, 0) delimited_list(delimiter) : splits up the passed in value based on the provided delimiter and then passes it to the function as a list one_of(values) : Validates that the passed in value is one of those specified mapping(dict_of_passed_in_to_desired_values) : Like one_of , but with a dictionary of acceptable values, to converted value. multi(types) : Allows passing in multiple acceptable types for a parameter, short circuiting on the first acceptable one in_range(lower, upper, convert=number) : Accepts a number within a lower and upper bound of acceptable values less_than(limit, convert=number) : Accepts a number within a lower and upper bound of acceptable values greater_than(minimum, convert=number) : Accepts a value above a given minimum length(lower, upper, convert=text) : Accepts a a value that is within a specific length limit shorter_than(limit, convert=text) : Accepts a text value shorter than the specified length limit longer_than(limit, convert=text) : Accepts a value up to the specified limit cut_off(limit, convert=text) : Cuts off the provided value at the specified index","title":"Built in hug types"},{"location":"documentation/TYPE_ANNOTATIONS/#extending-and-creating-new-hug-types","text":"The most obvious way to extend a hug type is to simply inherit from the base type defined in hug.types and then override __call__ to override how the cast function, or override __init__ to override what parameters the type takes: import hug class TheAnswer ( hug . types . Text ): \"\"\"My new documentation\"\"\" def __call__ ( self , value ): value = super () . __call__ ( value ) if value != 'fourty-two' : raise ValueError ( 'Value is not the answer to everything.' ) return value If you simply want to perform additional conversion after a base type is finished, or modify its documentation, the most succinct way is the hug.type decorator: import hug @hug.type ( extend = hug . types . number ) def the_answer ( value ): \"\"\"My new documentation\"\"\" if value != 42 : raise ValueError ( 'Value is not the answer to everything.' ) return value","title":"Extending and creating new hug types"},{"location":"documentation/TYPE_ANNOTATIONS/#marshmallow-integration","text":"Marshmallow is an advanced serialization, deserialization, and validation library. Hug supports using marshmallow fields and schemas as input types. Here is a simple example of an API that does datetime addition. import datetime as dt import hug from marshmallow import fields from marshmallow.validate import Range @hug.get ( '/dateadd' , examples = \"value=1973-04-10&addend=63\" ) def dateadd ( value : fields . Date (), addend : fields . Int ( validate = Range ( min = 1 ))): \"\"\"Add a value to a date.\"\"\" delta = dt . timedelta ( days = addend ) result = value + delta return { 'result' : result }","title":"Marshmallow integration"},{"location":"examples/docker_compose_with_mongodb/","text":"mongodb + hug microservice Run with sudo /path/to/docker-compose up --build Add data with something that can POST, e.g. curl http://localhost:8000/new -d name=\"my name\" -d description=\"a description\" Visit localhost:8000/ to see all the current data Rejoice!","title":"mongodb + hug microservice"},{"location":"examples/docker_compose_with_mongodb/#mongodb-hug-microservice","text":"Run with sudo /path/to/docker-compose up --build Add data with something that can POST, e.g. curl http://localhost:8000/new -d name=\"my name\" -d description=\"a description\" Visit localhost:8000/ to see all the current data Rejoice!","title":"mongodb + hug microservice"},{"location":"examples/docker_nginx/","text":"Docker/NGINX with Hug Example of a Docker image containing a Python project utilizing NGINX, Gunicorn, and Hug. This example provides a stack that operates as follows: Client <-> NGINX <-> Gunicorn <-> Python API ( Hug ) Getting started Clone/copy this directory to your local machine, navigate to said directory, then: For production: This is an \"immutable\" build that will require restarting of the container for changes to reflect. $ make prod For development: This is a \"mutable\" build, which enables us to make changes to our Python project, and changes will reflect in real time! $ make dev Once the docker images are running, navigate to localhost:8000 . A hello world message should be visible!","title":"Docker/NGINX with Hug"},{"location":"examples/docker_nginx/#dockernginx-with-hug","text":"Example of a Docker image containing a Python project utilizing NGINX, Gunicorn, and Hug. This example provides a stack that operates as follows: Client <-> NGINX <-> Gunicorn <-> Python API ( Hug )","title":"Docker/NGINX with Hug"},{"location":"examples/docker_nginx/#getting-started","text":"Clone/copy this directory to your local machine, navigate to said directory, then: For production: This is an \"immutable\" build that will require restarting of the container for changes to reflect. $ make prod For development: This is a \"mutable\" build, which enables us to make changes to our Python project, and changes will reflect in real time! $ make dev Once the docker images are running, navigate to localhost:8000 . A hello world message should be visible!","title":"Getting started"},{"location":"examples/multiple_files/","text":"Splitting the API into multiple files Example of an API defined in multiple Python modules and combined together using the extend_api() helper. Run with hug -f api.py . There are three API endpoints: - http://localhost:8000/ \u2013 say_hi() from api.py - http://localhost:8000/part1 \u2013 part1() from part_1.py - http://localhost:8000/part2 \u2013 part2() from part_2.py","title":"Splitting the API into multiple files"},{"location":"examples/multiple_files/#splitting-the-api-into-multiple-files","text":"Example of an API defined in multiple Python modules and combined together using the extend_api() helper. Run with hug -f api.py . There are three API endpoints: - http://localhost:8000/ \u2013 say_hi() from api.py - http://localhost:8000/part1 \u2013 part1() from part_1.py - http://localhost:8000/part2 \u2013 part2() from part_2.py","title":"Splitting the API into multiple files"},{"location":"reference/hug/","text":"Module hug hug/ init .py Everyone needs a hug every once in a while. Even API developers. Hug aims to make developing Python driven APIs as simple as possible, but no simpler. Hug's Design Objectives: Make developing a Python driven API as succint as a written definition. The framework should encourage code that self-documents. It should be fast. Never should a developer feel the need to look somewhere else for performance reasons. Writing tests for APIs written on-top of Hug should be easy and intuitive. Magic done once, in an API, is better then pushing the problem set to the user of the API. Be the basis for next generation Python APIs, embracing the latest technology. Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/__init__.py Everyone needs a hug every once in a while . Even API developers . Hug aims to make developing Python driven APIs as simple as possible , but no simpler . Hug ' s Design Objectives: - Make developing a Python driven API as succint as a written definition . - The framework should encourage code that self - documents . - It should be fast . Never should a developer feel the need to look somewhere else for performance reasons . - Writing tests for APIs written on - top of Hug should be easy and intuitive . - Magic done once , in an API , is better then pushing the problem set to the user of the API . - Be the basis for next generation Python APIs , embracing the latest technology . Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from falcon import * from hug import ( directives , exceptions , format , input_format , introspect , middleware , output_format , redirect , route , test , transform , types , use , validate , ) from hug . _version import current from hug . api import API from hug . decorators import ( context_factory , default_input_format , default_output_format , delete_context , directive , extend_api , middleware_class , reqresp_middleware , request_middleware , response_middleware , startup , wraps , ) from hug . route import ( call , cli , connect , delete , exception , get , get_post , head , http , local , not_found , object , options , patch , post , put , sink , static , trace , ) from hug . types import create as type # The following imports must be imported last ; in particular, defaults to have access to all modules from hug import authentication # isort : skip from hug import development_runner # isort : skip from hug import defaults # isort : skip try : # pragma : no cover - defaulting to uvloop if it is installed import uvloop import asyncio asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ()) except ( ImportError , AttributeError ) : pass __version__ = current Sub-modules hug.api hug.authentication hug.decorators hug.defaults hug.development_runner hug.directives hug.exceptions hug.format hug.input_format hug.interface hug.introspect hug.json_module hug.middleware hug.output_format hug.redirect hug.route hug.routing hug.store hug.test hug.this hug.transform hug.types hug.use hug.validate Variables COMBINED_METHODS DEFAULT_MEDIA_TYPE HTTP_100 HTTP_101 HTTP_102 HTTP_200 HTTP_201 HTTP_202 HTTP_203 HTTP_204 HTTP_205 HTTP_206 HTTP_207 HTTP_208 HTTP_226 HTTP_300 HTTP_301 HTTP_302 HTTP_303 HTTP_304 HTTP_305 HTTP_307 HTTP_308 HTTP_400 HTTP_401 HTTP_402 HTTP_403 HTTP_404 HTTP_405 HTTP_406 HTTP_407 HTTP_408 HTTP_409 HTTP_410 HTTP_411 HTTP_412 HTTP_413 HTTP_414 HTTP_415 HTTP_416 HTTP_417 HTTP_418 HTTP_422 HTTP_423 HTTP_424 HTTP_426 HTTP_428 HTTP_429 HTTP_431 HTTP_451 HTTP_500 HTTP_501 HTTP_502 HTTP_503 HTTP_504 HTTP_505 HTTP_507 HTTP_508 HTTP_511 HTTP_701 HTTP_702 HTTP_703 HTTP_710 HTTP_711 HTTP_712 HTTP_719 HTTP_720 HTTP_721 HTTP_722 HTTP_723 HTTP_724 HTTP_725 HTTP_726 HTTP_727 HTTP_740 HTTP_741 HTTP_742 HTTP_743 HTTP_744 HTTP_745 HTTP_748 HTTP_749 HTTP_750 HTTP_753 HTTP_754 HTTP_755 HTTP_759 HTTP_771 HTTP_772 HTTP_773 HTTP_774 HTTP_776 HTTP_777 HTTP_778 HTTP_779 HTTP_780 HTTP_781 HTTP_782 HTTP_783 HTTP_784 HTTP_785 HTTP_786 HTTP_791 HTTP_792 HTTP_797 HTTP_799 HTTP_ACCEPTED HTTP_ALREADY_REPORTED HTTP_BAD_GATEWAY HTTP_BAD_REQUEST HTTP_CONFLICT HTTP_CONTINUE HTTP_CREATED HTTP_EXPECTATION_FAILED HTTP_FAILED_DEPENDENCY HTTP_FORBIDDEN HTTP_FOUND HTTP_GATEWAY_TIMEOUT HTTP_GONE HTTP_HTTP_VERSION_NOT_SUPPORTED HTTP_IM_A_TEAPOT HTTP_IM_USED HTTP_INSUFFICIENT_STORAGE HTTP_INTERNAL_SERVER_ERROR HTTP_LENGTH_REQUIRED HTTP_LOCKED HTTP_LOOP_DETECTED HTTP_METHODS HTTP_METHOD_NOT_ALLOWED HTTP_MOVED_PERMANENTLY HTTP_MULTIPLE_CHOICES HTTP_MULTI_STATUS HTTP_NETWORK_AUTHENTICATION_REQUIRED HTTP_NON_AUTHORITATIVE_INFORMATION HTTP_NOT_ACCEPTABLE HTTP_NOT_FOUND HTTP_NOT_IMPLEMENTED HTTP_NOT_MODIFIED HTTP_NO_CONTENT HTTP_OK HTTP_PARTIAL_CONTENT HTTP_PAYMENT_REQUIRED HTTP_PERMANENT_REDIRECT HTTP_PRECONDITION_FAILED HTTP_PRECONDITION_REQUIRED HTTP_PROCESSING HTTP_PROXY_AUTHENTICATION_REQUIRED HTTP_REQUESTED_RANGE_NOT_SATISFIABLE HTTP_REQUEST_ENTITY_TOO_LARGE HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE HTTP_REQUEST_TIMEOUT HTTP_REQUEST_URI_TOO_LONG HTTP_RESET_CONTENT HTTP_SEE_OTHER HTTP_SERVICE_UNAVAILABLE HTTP_SWITCHING_PROTOCOLS HTTP_TEMPORARY_REDIRECT HTTP_TOO_MANY_REQUESTS HTTP_UNAUTHORIZED HTTP_UNAVAILABLE_FOR_LEGAL_REASONS HTTP_UNPROCESSABLE_ENTITY HTTP_UNSUPPORTED_MEDIA_TYPE HTTP_UPGRADE_REQUIRED HTTP_USE_PROXY MEDIA_GIF MEDIA_HTML MEDIA_JPEG MEDIA_JS MEDIA_JSON MEDIA_MSGPACK MEDIA_PNG MEDIA_TEXT MEDIA_XML MEDIA_YAML WEBDAV_METHODS connect current delete get get_post head options patch post put trace","title":"Index"},{"location":"reference/hug/#module-hug","text":"hug/ init .py Everyone needs a hug every once in a while. Even API developers. Hug aims to make developing Python driven APIs as simple as possible, but no simpler. Hug's Design Objectives: Make developing a Python driven API as succint as a written definition. The framework should encourage code that self-documents. It should be fast. Never should a developer feel the need to look somewhere else for performance reasons. Writing tests for APIs written on-top of Hug should be easy and intuitive. Magic done once, in an API, is better then pushing the problem set to the user of the API. Be the basis for next generation Python APIs, embracing the latest technology. Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/__init__.py Everyone needs a hug every once in a while . Even API developers . Hug aims to make developing Python driven APIs as simple as possible , but no simpler . Hug ' s Design Objectives: - Make developing a Python driven API as succint as a written definition . - The framework should encourage code that self - documents . - It should be fast . Never should a developer feel the need to look somewhere else for performance reasons . - Writing tests for APIs written on - top of Hug should be easy and intuitive . - Magic done once , in an API , is better then pushing the problem set to the user of the API . - Be the basis for next generation Python APIs , embracing the latest technology . Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from falcon import * from hug import ( directives , exceptions , format , input_format , introspect , middleware , output_format , redirect , route , test , transform , types , use , validate , ) from hug . _version import current from hug . api import API from hug . decorators import ( context_factory , default_input_format , default_output_format , delete_context , directive , extend_api , middleware_class , reqresp_middleware , request_middleware , response_middleware , startup , wraps , ) from hug . route import ( call , cli , connect , delete , exception , get , get_post , head , http , local , not_found , object , options , patch , post , put , sink , static , trace , ) from hug . types import create as type # The following imports must be imported last ; in particular, defaults to have access to all modules from hug import authentication # isort : skip from hug import development_runner # isort : skip from hug import defaults # isort : skip try : # pragma : no cover - defaulting to uvloop if it is installed import uvloop import asyncio asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ()) except ( ImportError , AttributeError ) : pass __version__ = current","title":"Module hug"},{"location":"reference/hug/#sub-modules","text":"hug.api hug.authentication hug.decorators hug.defaults hug.development_runner hug.directives hug.exceptions hug.format hug.input_format hug.interface hug.introspect hug.json_module hug.middleware hug.output_format hug.redirect hug.route hug.routing hug.store hug.test hug.this hug.transform hug.types hug.use hug.validate","title":"Sub-modules"},{"location":"reference/hug/#variables","text":"COMBINED_METHODS DEFAULT_MEDIA_TYPE HTTP_100 HTTP_101 HTTP_102 HTTP_200 HTTP_201 HTTP_202 HTTP_203 HTTP_204 HTTP_205 HTTP_206 HTTP_207 HTTP_208 HTTP_226 HTTP_300 HTTP_301 HTTP_302 HTTP_303 HTTP_304 HTTP_305 HTTP_307 HTTP_308 HTTP_400 HTTP_401 HTTP_402 HTTP_403 HTTP_404 HTTP_405 HTTP_406 HTTP_407 HTTP_408 HTTP_409 HTTP_410 HTTP_411 HTTP_412 HTTP_413 HTTP_414 HTTP_415 HTTP_416 HTTP_417 HTTP_418 HTTP_422 HTTP_423 HTTP_424 HTTP_426 HTTP_428 HTTP_429 HTTP_431 HTTP_451 HTTP_500 HTTP_501 HTTP_502 HTTP_503 HTTP_504 HTTP_505 HTTP_507 HTTP_508 HTTP_511 HTTP_701 HTTP_702 HTTP_703 HTTP_710 HTTP_711 HTTP_712 HTTP_719 HTTP_720 HTTP_721 HTTP_722 HTTP_723 HTTP_724 HTTP_725 HTTP_726 HTTP_727 HTTP_740 HTTP_741 HTTP_742 HTTP_743 HTTP_744 HTTP_745 HTTP_748 HTTP_749 HTTP_750 HTTP_753 HTTP_754 HTTP_755 HTTP_759 HTTP_771 HTTP_772 HTTP_773 HTTP_774 HTTP_776 HTTP_777 HTTP_778 HTTP_779 HTTP_780 HTTP_781 HTTP_782 HTTP_783 HTTP_784 HTTP_785 HTTP_786 HTTP_791 HTTP_792 HTTP_797 HTTP_799 HTTP_ACCEPTED HTTP_ALREADY_REPORTED HTTP_BAD_GATEWAY HTTP_BAD_REQUEST HTTP_CONFLICT HTTP_CONTINUE HTTP_CREATED HTTP_EXPECTATION_FAILED HTTP_FAILED_DEPENDENCY HTTP_FORBIDDEN HTTP_FOUND HTTP_GATEWAY_TIMEOUT HTTP_GONE HTTP_HTTP_VERSION_NOT_SUPPORTED HTTP_IM_A_TEAPOT HTTP_IM_USED HTTP_INSUFFICIENT_STORAGE HTTP_INTERNAL_SERVER_ERROR HTTP_LENGTH_REQUIRED HTTP_LOCKED HTTP_LOOP_DETECTED HTTP_METHODS HTTP_METHOD_NOT_ALLOWED HTTP_MOVED_PERMANENTLY HTTP_MULTIPLE_CHOICES HTTP_MULTI_STATUS HTTP_NETWORK_AUTHENTICATION_REQUIRED HTTP_NON_AUTHORITATIVE_INFORMATION HTTP_NOT_ACCEPTABLE HTTP_NOT_FOUND HTTP_NOT_IMPLEMENTED HTTP_NOT_MODIFIED HTTP_NO_CONTENT HTTP_OK HTTP_PARTIAL_CONTENT HTTP_PAYMENT_REQUIRED HTTP_PERMANENT_REDIRECT HTTP_PRECONDITION_FAILED HTTP_PRECONDITION_REQUIRED HTTP_PROCESSING HTTP_PROXY_AUTHENTICATION_REQUIRED HTTP_REQUESTED_RANGE_NOT_SATISFIABLE HTTP_REQUEST_ENTITY_TOO_LARGE HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE HTTP_REQUEST_TIMEOUT HTTP_REQUEST_URI_TOO_LONG HTTP_RESET_CONTENT HTTP_SEE_OTHER HTTP_SERVICE_UNAVAILABLE HTTP_SWITCHING_PROTOCOLS HTTP_TEMPORARY_REDIRECT HTTP_TOO_MANY_REQUESTS HTTP_UNAUTHORIZED HTTP_UNAVAILABLE_FOR_LEGAL_REASONS HTTP_UNPROCESSABLE_ENTITY HTTP_UNSUPPORTED_MEDIA_TYPE HTTP_UPGRADE_REQUIRED HTTP_USE_PROXY MEDIA_GIF MEDIA_HTML MEDIA_JPEG MEDIA_JS MEDIA_JSON MEDIA_MSGPACK MEDIA_PNG MEDIA_TEXT MEDIA_XML MEDIA_YAML WEBDAV_METHODS connect current delete get get_post head options patch post put trace","title":"Variables"},{"location":"reference/hug/api/","text":"Module hug.api hug/api.py Defines the dynamically generated Hug API object that is responsible for storing all routes and state within a module Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\"hug/api.py Defines the dynamically generated Hug API object that is responsible for storing all routes and state within a module Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software \"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from __ future__ import absolute_import import asyncio import sys from collections import OrderedDict , namedtuple from distutils . util import strtobool from functools import partial from itertools import chain from types import ModuleType from wsgiref . simple_server import make_server import falcon from falcon import HTTP_METHODS import hug . defaults import hug . output_format from hug import introspect from hug . _ version import current INTRO = \"\" \" /#######################################################################\\\\ ` . ---- `` .. -------.. `` . ----. :/:::::--:---------:--::::://. . +::::----##/-/oo+:-##----::::// ` //::-------/oosoo-------::://. ## ## ## ## ##### . -:------./++o / o-.------::- ` ``` ## ## ## ## ## ` ----.-./+o+:..----. ` . :///. ######## ## ## ## ``` ` ----.-::::::------ ` . -:::://. ## ## ## ## ## #### ://::--. ``` -: `` ... -----... ` ` :- -::::::-. ` ## ## ## ## ## ## :/:::::::::-:- ````` . :::::-. ` ## ## #### ###### `` . --:::::::. . :::. ` `` .. ::. . :: EMBRACE THE APIs OF THE FUTURE ::- .:- -:: ` ::- VERSION { 0 } ` ::- -:: ` -::- ` -::- \\########################################################################/ Copyright ( C ) 2016 Timothy Edmund Crosley Under the MIT License \"\"\".format( current ) class InterfaceAPI(object): \"\"\" Defines the per - interface API which defines all shared information for a specific interface , and how it should be exposed \"\"\" __slots__ = (\" api \",) def __init__(self, api): self.api = api class HTTPInterfaceAPI(InterfaceAPI): \"\"\" Defines the HTTP interface specific API \"\"\" __slots__ = ( \" routes \", \" versions \", \" base_url \", \" falcon \", \" _ output_format \", \" _ input_format \", \" versioned \", \" _ middleware \", \" _ not_found_handlers \", \" sinks \", \" _ not_found \", \" _ exception_handlers \", ) def __init__(self, api, base_url=\"\"): super().__init__(api) self.versions = set() self.routes = OrderedDict() self.sinks = OrderedDict() self.versioned = OrderedDict() self.base_url = base_url @property def output_format(self): return getattr(self, \" _ output_format \", hug.defaults.output_format) @output_format.setter def output_format(self, formatter): self._output_format = formatter @property def not_found(self): \"\"\" Returns the active not found handler \"\"\" return getattr(self, \" _ not_found \", self.base_404) def urls(self): \"\"\" Returns a generator of all URLs attached to this API \"\"\" for base_url, mapping in self.routes.items(): for url, _ in mapping.items(): yield base_url + url def handlers(self): \"\"\" Returns all registered handlers attached to this API \"\"\" used = [] for _base_url, mapping in self.routes.items(): for _url, methods in mapping.items(): for _method, versions in methods.items(): for _version, handler in versions.items(): if not handler in used: used.append(handler) yield handler def input_format(self, content_type): \"\"\" Returns the set input_format handler for the given content_type \"\"\" return getattr(self, \" _ input_format \", {}).get( content_type, hug.defaults.input_format.get(content_type, None) ) def set_input_format(self, content_type, handler): \"\"\" Sets an input format handler for this Hug API , given the specified content_type \"\"\" if getattr(self, \" _ input_format \", None) is None: self._input_format = {} self._input_format[content_type] = handler @property def middleware(self): return getattr(self, \" _ middleware \", None) def add_middleware(self, middleware): \"\"\" Adds a middleware object used to process all incoming requests against the API \"\"\" if self.middleware is None: self._middleware = [] self.middleware.append(middleware) def add_sink(self, sink, url, base_url=\"\"): base_url = base_url or self.base_url self.sinks.setdefault(base_url, OrderedDict()) self.sinks[base_url][url] = sink def exception_handlers(self, version=None): if not hasattr(self, \" _ exception_handlers \"): return None return self._exception_handlers.get(version, self._exception_handlers.get(None, None)) def add_exception_handler(self, exception_type, error_handler, versions=(None,)): \"\"\" Adds a error handler to the hug api \"\"\" versions = (versions,) if not isinstance(versions, (tuple, list)) else versions if not hasattr(self, \" _ exception_handlers \"): self._exception_handlers = {} for version in versions: placement = self._exception_handlers.setdefault(version, OrderedDict()) placement[exception_type] = (error_handler,) + placement.get(exception_type, tuple()) def extend(self, http_api, route=\"\", base_url=\"\", **kwargs): \"\"\" Adds handlers from a different Hug API to this one - to create a single API \"\"\" self.versions.update(http_api.versions) base_url = base_url or self.base_url for _router_base_url, routes in http_api.routes.items(): self.routes.setdefault(base_url, OrderedDict()) for item_route, handler in routes.items(): for _method, versions in handler.items(): for _version, function in versions.items(): function.interface.api = self.api self.routes[base_url].setdefault(route + item_route, {}).update(handler) for _sink_base_url, sinks in http_api.sinks.items(): for url, sink in sinks.items(): self.add_sink(sink, route + url, base_url=base_url) for middleware in http_api.middleware or (): self.add_middleware(middleware) for version, handler in getattr(http_api, \" _ exception_handlers \", {}).items(): for exception_type, exception_handlers in handler.items(): target_exception_handlers = self.exception_handlers(version) or {} for exception_handler in exception_handlers: if exception_type not in target_exception_handlers: self.add_exception_handler(exception_type, exception_handler, version) for input_format, input_format_handler in getattr(http_api, \" _ input_format \", {}).items(): if not input_format in getattr(self, \" _ input_format \", {}): self.set_input_format(input_format, input_format_handler) for version, handler in http_api.not_found_handlers.items(): if version not in self.not_found_handlers: self.set_not_found_handler(handler, version) @property def not_found_handlers(self): return getattr(self, \" _ not_found_handlers \", {}) def set_not_found_handler(self, handler, version=None): \"\"\" Sets the not_found handler for the specified version of the api \"\"\" if not self.not_found_handlers: self._not_found_handlers = {} self.not_found_handlers[version] = handler def documentation(self, base_url=None, api_version=None, prefix=\"\"): \"\"\" Generates and returns documentation for this API endpoint \"\"\" documentation = OrderedDict() base_url = self.base_url if base_url is None else base_url overview = self.api.doc if overview: documentation[\" overview \"] = overview version_dict = OrderedDict() versions = self.versions versions_list = list(versions) if None in versions_list: versions_list.remove(None) if False in versions_list: versions_list.remove(False) if api_version is None and len(versions_list) > 0: api_version = max(versions_list) documentation[\" version \"] = api_version elif api_version is not None: documentation[\" version \"] = api_version if versions_list: documentation[\" versions \"] = versions_list for router_base_url, routes in self.routes.items(): for url, methods in routes.items(): for method, method_versions in methods.items(): for version, handler in method_versions.items(): if getattr(handler, \" private \", False): continue if version is None: applies_to = versions else: applies_to = (version,) for version in applies_to: if api_version and version != api_version: continue if base_url and router_base_url != base_url: continue doc = version_dict.setdefault(url, OrderedDict()) doc[method] = handler.documentation( doc.get(method, None), version=version, prefix=prefix, base_url=router_base_url, url=url, ) documentation[\" handlers \"] = version_dict return documentation def serve(self, host=\"\", port=8000, no_documentation=False, display_intro=True): \"\"\" Runs the basic hug development server against this API \"\"\" if no_documentation: api = self.server(None) else: api = self.server() if display_intro: print(INTRO) httpd = make_server(host, port, api) print(\" Serving on { 0 } : { 1 }... \".format(host, port)) httpd.serve_forever() @staticmethod def base_404(request, response, *args, **kwargs): \"\"\" Defines the base 404 handler \"\"\" response.status = falcon.HTTP_NOT_FOUND def determine_version(self, request, api_version=None): \"\"\" Determines the appropriate version given the set api_version , the request header , and URL query params \"\"\" if api_version is False: api_version = None for version in self.versions: if version and \" v { 0 } \".format(version) in request.path: api_version = version break request_version = set() if api_version is not None: request_version.add(api_version) version_header = request.get_header(\" X - API - VERSION \") if version_header: request_version.add(version_header) version_param = request.get_param(\" api_version \") if version_param is not None: request_version.add(version_param) if len(request_version) > 1: raise ValueError(\" You are requesting conflicting versions \") return next(iter(request_version or (None,))) def documentation_404(self, base_url=None): \"\"\" Returns a smart 404 page that contains documentation for the written API \"\"\" base_url = self.base_url if base_url is None else base_url def handle_404(request, response, *args, **kwargs): url_prefix = request.forwarded_uri[:-1] if request.path and request.path != \" / \": url_prefix = request.forwarded_uri.split(request.path)[0] to_return = OrderedDict() to_return[\" 404 \"] = ( \" The API call you tried to make was not defined . \" \" Here ' s a definition of the API to help you get going : ) \" ) to_return[\" documentation \"] = self.documentation( base_url, self.determine_version(request, False), prefix=url_prefix ) if self.output_format == hug.output_format.json: response.data = hug.output_format.json(to_return, indent=4, separators=(\" , \", \" : \")) response.content_type = \" application / json ; charset = utf - 8 \" else: response.data = self.output_format(to_return, request=request, response=response) response.content_type = self.output_format.content_type response.status = falcon.HTTP_NOT_FOUND handle_404.interface = True return handle_404 def version_router( self, request, response, api_version=None, versions=None, not_found=None, **kwargs ): \"\"\" Intelligently routes a request to the correct handler based on the version being requested \"\"\" versions = {} if versions is None else versions request_version = self.determine_version(request, api_version) if request_version: request_version = int(request_version) versions.get(request_version or False, versions.get(None, not_found))( request, response, api_version=api_version, **kwargs ) def server(self, default_not_found=True, base_url=None): \"\"\" Returns a WSGI compatible API server for the given Hug API module \"\"\" falcon_api = self.falcon = falcon.API(middleware=self.middleware) if not self.api.future: falcon_api.req_options.keep_blank_qs_values = False falcon_api.req_options.auto_parse_qs_csv = True falcon_api.req_options.strip_url_path_trailing_slash = True default_not_found = self.documentation_404() if default_not_found is True else None base_url = self.base_url if base_url is None else base_url not_found_handler = default_not_found self.api._ensure_started() if self.not_found_handlers: if len(self.not_found_handlers) == 1 and None in self.not_found_handlers: not_found_handler = self.not_found_handlers[None] else: not_found_handler = partial( self.version_router, api_version=False, versions=self.not_found_handlers, not_found=default_not_found, ) not_found_handler.interface = True if not_found_handler: falcon_api.add_sink(not_found_handler) self._not_found = not_found_handler for sink_base_url, sinks in self.sinks.items(): for url, extra_sink in sinks.items(): falcon_api.add_sink(extra_sink, sink_base_url + url + \" ( ? P < path>.* ) \") for router_base_url, routes in self.routes.items(): for url, methods in routes.items(): router = {} for method, versions in methods.items(): method_function = \" on_ { 0 } \".format(method.lower()) if len(versions) == 1 and None in versions.keys(): router[method_function] = versions[None] else: router[method_function] = partial( self.version_router, versions=versions, not_found=not_found_handler ) router = namedtuple(\" Router \", router.keys())(**router) falcon_api.add_route(router_base_url + url, router) if self.versions and self.versions != (None,): falcon_api.add_route(router_base_url + \" / v { api_version } \" + url, router) def error_serializer(request, response, error): response.content_type = self.output_format.content_type response.body = self.output_format( {\" errors \": {error.title: error.description}}, request, response ) falcon_api.set_error_serializer(error_serializer) return falcon_api HTTPInterfaceAPI.base_404.interface = True class CLIInterfaceAPI(InterfaceAPI): \"\"\" Defines the CLI interface specific API \"\"\" __slots__ = (\" commands \", \" error_exit_codes \", \" _ output_format \") def __init__(self, api, version=\"\", error_exit_codes=False): super().__init__(api) self.commands = {} self.error_exit_codes = error_exit_codes def __call__(self, args=None): \"\"\" Routes to the correct command line tool \"\"\" self.api._ensure_started() args = sys.argv if args is None else args if not len(args) > 1 or not args[1] in self.commands: print(str(self)) return sys.exit(1) command = args.pop(1) result = self.commands.get(command)() if self.error_exit_codes and bool(strtobool(result.decode(\" utf - 8 \"))) is False: sys.exit(1) def handlers(self): \"\"\" Returns all registered handlers attached to this API \"\"\" return self.commands.values() def extend(self, cli_api, command_prefix=\"\", sub_command=\"\", **kwargs): \"\"\" Extends this CLI api with the commands present in the provided cli_api object \"\"\" if sub_command and command_prefix: raise ValueError( \" It is not currently supported to provide both a command_prefix and sub_command \" ) if sub_command: self.commands[sub_command] = cli_api else: for name, command in cli_api.commands.items(): self.commands[\" {}{} \".format(command_prefix, name)] = command @property def output_format(self): return getattr(self, \" _ output_format \", hug.defaults.cli_output_format) @output_format.setter def output_format(self, formatter): self._output_format = formatter def __str__(self): output = \" { 0 } \\n\\nAvailable Commands :\\n\\n \".format(self.api.doc or self.api.name) for command_name, command in self.commands.items(): command_string = \" - {}{} \".format( command_name, \" : \" + str(command).replace(\" \\n \", \" \") if str(command) else \"\" ) output += command_string[:77] + \" ... \" if len(command_string) > 80 else command_string output += \" \\n \" return output class ModuleSingleton(type): \"\"\" Defines the module level __ hug__ singleton \"\"\" def __call__(cls, module=None, *args, **kwargs): if isinstance(module, API): return module if type(module) == str: if module not in sys.modules: sys.modules[module] = ModuleType(module) module = sys.modules[module] elif module is None: return super().__call__(*args, **kwargs) if not \" __ hug__ \" in module.__dict__: def api_auto_instantiate(*args, **kwargs): if not hasattr(module, \" __ hug_serving__ \"): module.__hug_wsgi__ = module.__hug__.http.server() module.__hug_serving__ = True return module.__hug_wsgi__(*args, **kwargs) module.__hug__ = super().__call__(module, *args, **kwargs) module.__hug_wsgi__ = api_auto_instantiate return module.__hug__ class API(object, metaclass=ModuleSingleton): \"\"\" Stores the information necessary to expose API calls within this module externally \"\"\" __slots__ = ( \" module \", \" _ directives \", \" _ http \", \" _ cli \", \" _ context \", \" _ context_factory \", \" _ delete_context \", \" _ startup_handlers \", \" started \", \" name \", \" doc \", \" future \", \" cli_error_exit_codes \", ) def __init__(self, module=None, name=\"\", doc=\"\", cli_error_exit_codes=False, future=False): self.module = module if module: self.name = name or module.__name__ or \"\" self.doc = doc or module.__doc__ or \"\" else: self.name = name self.doc = doc self.started = False self.cli_error_exit_codes = cli_error_exit_codes self.future = future def directives(self): \"\"\" Returns all directives applicable to this Hug API \"\"\" directive_sources = chain( hug.defaults.directives.items(), getattr(self, \" _ directives \", {}).items() ) return { \" hug_ \" + directive_name: directive for directive_name, directive in directive_sources } def directive(self, name, default=None): \"\"\" Returns the loaded directive with the specified name , or default if passed name is not present \"\"\" return getattr(self, \" _ directives \", {}).get( name, hug.defaults.directives.get(name, default) ) def add_directive(self, directive): self._directives = getattr(self, \" _ directives \", {}) self._directives[directive.__name__] = directive def handlers(self): \"\"\" Returns all registered handlers attached to this API \"\"\" if getattr(self, \" _ http \", None): yield from self.http.handlers() if getattr(self, \" _ cli \", None): yield from self.cli.handlers() @property def http(self): if not hasattr(self, \" _ http \"): self._http = HTTPInterfaceAPI(self) return self._http @property def cli(self): if not hasattr(self, \" _ cli \"): self._cli = CLIInterfaceAPI(self, error_exit_codes=self.cli_error_exit_codes) return self._cli @property def context_factory(self): return getattr(self, \" _ context_factory \", hug.defaults.context_factory) @context_factory.setter def context_factory(self, context_factory_): self._context_factory = context_factory_ @property def delete_context(self): return getattr(self, \" _ delete_context \", hug.defaults.delete_context) @delete_context.setter def delete_context(self, delete_context_): self._delete_context = delete_context_ @property def context(self): if not hasattr(self, \" _ context \"): self._context = {} return self._context def extend(self, api, route=\"\", base_url=\"\", http=True, cli=True, **kwargs): \"\"\" Adds handlers from a different Hug API to this one - to create a single API \"\"\" api = API(api) if http and hasattr(api, \" _ http \"): self.http.extend(api.http, route, base_url, **kwargs) if cli and hasattr(api, \" _ cli \"): self.cli.extend(api.cli, **kwargs) for directive in getattr(api, \" _ directives \", {}).values(): self.add_directive(directive) for startup_handler in api.startup_handlers or (): self.add_startup_handler(startup_handler) def add_startup_handler(self, handler): \"\"\" Adds a startup handler to the hug api \"\"\" if not self.startup_handlers: self._startup_handlers = [] self.startup_handlers.append(handler) def _ensure_started(self): \"\"\" Marks the API as started and runs all startup handlers \"\"\" if not self.started: async_handlers = [ startup_handler for startup_handler in self.startup_handlers if introspect.is_coroutine(startup_handler) ] if async_handlers: loop = asyncio.get_event_loop() loop.run_until_complete( asyncio.gather(*[handler(self) for handler in async_handlers], loop=loop) ) for startup_handler in self.startup_handlers: if not startup_handler in async_handlers: startup_handler(self) @property def startup_handlers(self): return getattr(self, \" _ startup_handlers \", ()) def from_object(obj): \"\"\" Returns a Hug API instance from a given object ( function , class , instance ) \"\" \" return API ( obj . __ module__ ) Variables HTTP_METHODS INTRO current Functions from_object def ( obj ) Returns a Hug API instance from a given object (function, class, instance) View Source def from_object ( obj ) : \"\"\" Returns a Hug API instance from a given object (function, class, instance) \"\"\" return API ( obj . __module__ ) Classes API class ( module = None , name = '' , doc = '' , cli_error_exit_codes = False , future = False ) Stores the information necessary to expose API calls within this module externally View Source class API ( object , metaclass = ModuleSingleton ) : \"\"\" Stores the information necessary to expose API calls within this module externally \"\"\" __slots__ = ( \" module \" , \" _directives \" , \" _http \" , \" _cli \" , \" _context \" , \" _context_factory \" , \" _delete_context \" , \" _startup_handlers \" , \" started \" , \" name \" , \" doc \" , \" future \" , \" cli_error_exit_codes \" , ) def __init__ ( self , module = None , name = \"\" , doc = \"\" , cli_error_exit_codes = False , future = False ) : self . module = module if module : self . name = name or module . __name__ or \"\" self . doc = doc or module . __doc__ or \"\" else : self . name = name self . doc = doc self . started = False self . cli_error_exit_codes = cli_error_exit_codes self . future = future def directives ( self ) : \"\"\" Returns all directives applicable to this Hug API \"\"\" directive_sources = chain ( hug . defaults . directives . items () , getattr ( self , \" _directives \" , {} ) . items () ) return { \" hug_ \" + directive_name : directive for directive_name , directive in directive_sources } def directive ( self , name , default = None ) : \"\"\" Returns the loaded directive with the specified name, or default if passed name is not present \"\"\" return getattr ( self , \" _directives \" , {} ) . get ( name , hug . defaults . directives . get ( name , default ) ) def add_directive ( self , directive ) : self . _directives = getattr ( self , \" _directives \" , {} ) self . _directives [ directive . __name__ ] = directive def handlers ( self ) : \"\"\" Returns all registered handlers attached to this API \"\"\" if getattr ( self , \" _http \" , None ) : yield from self . http . handlers () if getattr ( self , \" _cli \" , None ) : yield from self . cli . handlers () @ property def http ( self ) : if not hasattr ( self , \" _http \" ) : self . _http = HTTPInterfaceAPI ( self ) return self . _http @ property def cli ( self ) : if not hasattr ( self , \" _cli \" ) : self . _cli = CLIInterfaceAPI ( self , error_exit_codes = self . cli_error_exit_codes ) return self . _cli @ property def context_factory ( self ) : return getattr ( self , \" _context_factory \" , hug . defaults . context_factory ) @ context_factory . setter def context_factory ( self , context_factory_ ) : self . _context_factory = context_factory_ @ property def delete_context ( self ) : return getattr ( self , \" _delete_context \" , hug . defaults . delete_context ) @ delete_context . setter def delete_context ( self , delete_context_ ) : self . _delete_context = delete_context_ @ property def context ( self ) : if not hasattr ( self , \" _context \" ) : self . _context = {} return self . _context def extend ( self , api , route = \"\" , base_url = \"\" , http = True , cli = True , ** kwargs ) : \"\"\" Adds handlers from a different Hug API to this one - to create a single API \"\"\" api = API ( api ) if http and hasattr ( api , \" _http \" ) : self . http . extend ( api . http , route , base_url , ** kwargs ) if cli and hasattr ( api , \" _cli \" ) : self . cli . extend ( api . cli , ** kwargs ) for directive in getattr ( api , \" _directives \" , {} ) . values () : self . add_directive ( directive ) for startup_handler in api . startup_handlers or () : self . add_startup_handler ( startup_handler ) def add_startup_handler ( self , handler ) : \"\"\" Adds a startup handler to the hug api \"\"\" if not self . startup_handlers : self . _startup_handlers = [] self . startup_handlers . append ( handler ) def _ensure_started ( self ) : \"\"\" Marks the API as started and runs all startup handlers \"\"\" if not self . started : async_handlers = [ startup_handler for startup_handler in self . startup_handlers if introspect . is_coroutine ( startup_handler ) ] if async_handlers : loop = asyncio . get_event_loop () loop . run_until_complete ( asyncio . gather ( * [ handler ( self ) for handler in async_handlers ], loop = loop ) ) for startup_handler in self . startup_handlers : if not startup_handler in async_handlers : startup_handler ( self ) @ property def startup_handlers ( self ) : return getattr ( self , \" _startup_handlers \" , ()) CLIInterfaceAPI class ( api , version = '' , error_exit_codes = False ) Defines the CLI interface specific API View Source class CLIInterfaceAPI ( InterfaceAPI ) : \"\"\" Defines the CLI interface specific API \"\"\" __slots__ = ( \" commands \" , \" error_exit_codes \" , \" _output_format \" ) def __init__ ( self , api , version = \"\" , error_exit_codes = False ) : super () . __init__ ( api ) self . commands = {} self . error_exit_codes = error_exit_codes def __call__ ( self , args = None ) : \"\"\" Routes to the correct command line tool \"\"\" self . api . _ensure_started () args = sys . argv if args is None else args if not len ( args ) > 1 or not args [ 1 ] in self . commands : print ( str ( self )) return sys . exit ( 1 ) command = args . pop ( 1 ) result = self . commands . get ( command )() if self . error_exit_codes and bool ( strtobool ( result . decode ( \" utf-8 \" ))) is False : sys . exit ( 1 ) def handlers ( self ) : \"\"\" Returns all registered handlers attached to this API \"\"\" return self . commands . values () def extend ( self , cli_api , command_prefix = \"\" , sub_command = \"\" , ** kwargs ) : \"\"\" Extends this CLI api with the commands present in the provided cli_api object \"\"\" if sub_command and command_prefix : raise ValueError ( \" It is not currently supported to provide both a command_prefix and sub_command \" ) if sub_command : self . commands [ sub_command ] = cli_api else : for name , command in cli_api . commands . items () : self . commands [ \" {}{} \" . format ( command_prefix , name ) ] = command @ property def output_format ( self ) : return getattr ( self , \" _output_format \" , hug . defaults . cli_output_format ) @ output_format . setter def output_format ( self , formatter ) : self . _output_format = formatter def __str__ ( self ) : output = \" {0} \\n\\n Available Commands: \\n\\n \" . format ( self . api . doc or self . api . name ) for command_name , command in self . commands . items () : command_string = \" - {}{} \" . format ( command_name , \" : \" + str ( command ) . replace ( \" \\n \" , \" \" ) if str ( command ) else \"\" ) output += command_string [: 77 ] + \" ... \" if len ( command_string ) > 80 else command_string output += \" \\n \" return output Ancestors (in MRO) hug.api.InterfaceAPI HTTPInterfaceAPI class ( api , base_url = '' ) Defines the HTTP interface specific API View Source class HTTPInterfaceAPI ( InterfaceAPI ) : \"\"\"Defines the HTTP interface specific API\"\"\" __ slots__ = ( \"routes\" , \"versions\" , \"base_url\" , \"falcon\" , \"_output_format\" , \"_input_format\" , \"versioned\" , \"_middleware\" , \"_not_found_handlers\" , \"sinks\" , \"_not_found\" , \"_exception_handlers\" , ) def __ init__ ( self , api , base_url= \"\" ) : super (). __ init__ ( api ) self . versions = set () self . routes = OrderedDict () self . sinks = OrderedDict () self . versioned = OrderedDict () self . base_url = base_url @property def output_format ( self ) : return getattr ( self , \"_output_format\" , hug . defaults . output_format ) @output_format . setter def output_format ( self , formatter ) : self . _ output_format = formatter @property def not_found ( self ) : \"\"\"Returns the active not found handler\"\"\" return getattr ( self , \"_not_found\" , self . base_404 ) def urls ( self ) : \"\"\"Returns a generator of all URLs attached to this API\"\"\" for base_url , mapping in self . routes . items () : for url , _ in mapping . items () : yield base_url + url def handlers ( self ) : \"\"\"Returns all registered handlers attached to this API\"\"\" used = [] for _ base_url , mapping in self . routes . items () : for _ url , methods in mapping . items () : for _ method , versions in methods . items () : for _ version , handler in versions . items () : if not handler in used : used . append ( handler ) yield handler def input_format ( self , content_type ) : \"\"\"Returns the set input_format handler for the given content_type\"\"\" return getattr ( self , \"_input_format\" , {}). get ( content_type , hug . defaults . input_format . get ( content_type , None ) ) def set_input_format ( self , content_type , handler ) : \"\"\"Sets an input format handler for this Hug API, given the specified content_type\"\"\" if getattr ( self , \"_input_format\" , None ) is None : self . _ input_format = {} self . _ input_format [ content_type ] = handler @property def middleware ( self ) : return getattr ( self , \"_middleware\" , None ) def add_middleware ( self , middleware ) : \"\"\"Adds a middleware object used to process all incoming requests against the API\"\"\" if self . middleware is None : self . _ middleware = [] self . middleware . append ( middleware ) def add_sink ( self , sink , url , base_url= \"\" ) : base_url = base_url or self . base_url self . sinks . setdefault ( base_url , OrderedDict ()) self . sinks [ base_url ][ url ] = sink def exception_handlers ( self , version = None ) : if not hasattr ( self , \"_exception_handlers\" ) : return None return self . _ exception_handlers . get ( version , self . _ exception_handlers . get ( None , None )) def add_exception_handler ( self , exception_type , error_handler , versions= ( None ,)) : \"\"\"Adds a error handler to the hug api\"\"\" versions = ( versions ,) if not isinstance ( versions , ( tuple , list )) else versions if not hasattr ( self , \"_exception_handlers\" ) : self . _ exception_handlers = {} for version in versions : placement = self . _ exception_handlers . setdefault ( version , OrderedDict ()) placement [ exception_type ] = ( error_handler ,) + placement . get ( exception_type , tuple ()) def extend ( self , http_api , route= \"\" , base_url= \"\" , **kwargs ) : \"\"\"Adds handlers from a different Hug API to this one - to create a single API\"\"\" self . versions . update ( http_api . versions ) base_url = base_url or self . base_url for _ router_base_url , routes in http_api . routes . items () : self . routes . setdefault ( base_url , OrderedDict ()) for item_route , handler in routes . items () : for _ method , versions in handler . items () : for _ version , function in versions . items () : function . interface . api = self . api self . routes [ base_url ]. setdefault ( route + item_route , {}). update ( handler ) for _ sink_base_url , sinks in http_api . sinks . items () : for url , sink in sinks . items () : self . add_sink ( sink , route + url , base_url = base_url ) for middleware in http_api . middleware or () : self . add_middleware ( middleware ) for version , handler in getattr ( http_api , \"_exception_handlers\" , {}). items () : for exception_type , exception_handlers in handler . items () : target_exception_handlers = self . exception_handlers ( version ) or {} for exception_handler in exception_handlers: if exception_type not in target_exception_handlers: self . add_exception_handler ( exception_type , exception_handler , version ) for input_format , input_format_handler in getattr ( http_api , \"_input_format\" , {}). items () : if not input_format in getattr ( self , \"_input_format\" , {}) : self . set_input_format ( input_format , input_format_handler ) for version , handler in http_api . not_found_handlers . items () : if version not in self . not_found_handlers: self . set_not_found_handler ( handler , version ) @property def not_found_handlers ( self ) : return getattr ( self , \"_not_found_handlers\" , {}) def set_not_found_handler ( self , handler , version = None ) : \"\"\"Sets the not_found handler for the specified version of the api\"\"\" if not self . not_found_handlers: self . _ not_found_handlers = {} self . not_found_handlers [ version ] = handler def documentation ( self , base_url = None , api_version = None , prefix= \"\" ) : \"\"\"Generates and returns documentation for this API endpoint\"\"\" documentation = OrderedDict () base_url = self . base_url if base_url is None else base_url overview = self . api . doc if overview : documentation [ \"overview\" ] = overview version_dict = OrderedDict () versions = self . versions versions_list = list ( versions ) if None in versions_list: versions_list . remove ( None ) if False in versions_list: versions_list . remove ( False ) if api_version is None and len ( versions_list ) > 0 : api_version = max ( versions_list ) documentation [ \"version\" ] = api_version elif api_version is not None : documentation [ \"version\" ] = api_version if versions_list: documentation [ \"versions\" ] = versions_list for router_base_url , routes in self . routes . items () : for url , methods in routes . items () : for method , method_versions in methods . items () : for version , handler in method_versions . items () : if getattr ( handler , \"private\" , False ) : continue if version is None : applies_to = versions else : applies_to = ( version ,) for version in applies_to: if api_version and version ! = api_version: continue if base_url and router_base_url ! = base_url: continue doc = version_dict . setdefault ( url , OrderedDict ()) doc [ method ] = handler . documentation ( doc . get ( method , None ), version = version , prefix = prefix , base_url = router_base_url , url = url , ) documentation [ \"handlers\" ] = version_dict return documentation def serve ( self , host= \"\" , port = 8000 , no_documentation = False , display_intro = True ) : \"\"\"Runs the basic hug development server against this API\"\"\" if no_documentation: api = self . server ( None ) else : api = self . server () if display_intro: print ( INTRO ) httpd = make_server ( host , port , api ) print ( \"Serving on {0}:{1}...\" . format ( host , port )) httpd . serve_forever () @staticmethod def base_404 ( request , response , * args , **kwargs ) : \"\"\"Defines the base 404 handler\"\"\" response . status = falcon . HTTP_NOT_FOUND def determine_version ( self , request , api_version = None ) : \"\"\"Determines the appropriate version given the set api_version, the request header, and URL query params\"\"\" if api_version is False : api_version = None for version in self . versions : if version and \"v{0}\" . format ( version ) in request . path : api_version = version break request_version = set () if api_version is not None : request_version . add ( api_version ) version_header = request . get_header ( \"X-API-VERSION\" ) if version_header: request_version . add ( version_header ) version_param = request . get_param ( \"api_version\" ) if version_param is not None : request_version . add ( version_param ) if len ( request_version ) > 1 : raise ValueError ( \"You are requesting conflicting versions\" ) return next ( iter ( request_version or ( None ,))) def documentation_404 ( self , base_url = None ) : \"\"\"Returns a smart 404 page that contains documentation for the written API\"\"\" base_url = self . base_url if base_url is None else base_url def handle_404 ( request , response , * args , **kwargs ) : url_prefix = request . forwarded_uri [:- 1 ] if request . path and request . path ! = \"/\" : url_prefix = request . forwarded_uri . split ( request . path )[ 0 ] to_return = OrderedDict () to_return [ \"404\" ] = ( \"The API call you tried to make was not defined. \" \"Here's a definition of the API to help you get going :)\" ) to_return [ \"documentation\" ] = self . documentation ( base_url , self . determine_version ( request , False ), prefix = url_prefix ) if self . output_format == hug . output_format . json : response . data = hug . output_format . json ( to_return , indent = 4 , separators= ( \",\" , \": \" )) response . content_type = \"application/json; charset=utf-8\" else : response . data = self . output_format ( to_return , request = request , response = response ) response . content_type = self . output_format . content_type response . status = falcon . HTTP_NOT_FOUND handle_404 . interface = True return handle_404 def version_router ( self , request , response , api_version = None , versions = None , not_found = None , **kwargs ) : \"\"\"Intelligently routes a request to the correct handler based on the version being requested\"\"\" versions = {} if versions is None else versions request_version = self . determine_version ( request , api_version ) if request_version: request_version = int ( request_version ) versions . get ( request_version or False , versions . get ( None , not_found ))( request , response , api_version = api_version , **kwargs ) def server ( self , default_not_found = True , base_url = None ) : \"\"\"Returns a WSGI compatible API server for the given Hug API module\"\"\" falcon_api = self . falcon = falcon . API ( middleware = self . middleware ) if not self . api . future : falcon_api . req_options . keep_blank_qs_values = False falcon_api . req_options . auto_parse_qs_csv = True falcon_api . req_options . strip_url_path_trailing_slash = True default_not_found = self . documentation_404 () if default_not_found is True else None base_url = self . base_url if base_url is None else base_url not_found_handler = default_not_found self . api . _ ensure_started () if self . not_found_handlers: if len ( self . not_found_handlers ) == 1 and None in self . not_found_handlers: not_found_handler = self . not_found_handlers [ None ] else : not_found_handler = partial ( self . version_router , api_version = False , versions = self . not_found_handlers , not_found = default_not_found , ) not_found_handler . interface = True if not_found_handler: falcon_api . add_sink ( not_found_handler ) self . _ not_found = not_found_handler for sink_base_url , sinks in self . sinks . items () : for url , extra_sink in sinks . items () : falcon_api . add_sink ( extra_sink , sink_base_url + url + \"(?P<path>.*)\" ) for router_base_url , routes in self . routes . items () : for url , methods in routes . items () : router = {} for method , versions in methods . items () : method_function = \"on_{0}\" . format ( method . lower ()) if len ( versions ) == 1 and None in versions . keys () : router [ method_function ] = versions [ None ] else : router [ method_function ] = partial ( self . version_router , versions = versions , not_found = not_found_handler ) router = namedtuple ( \"Router\" , router . keys ())( **router ) falcon_api . add_route ( router_base_url + url , router ) if self . versions and self . versions ! = ( None ,) : falcon_api . add_route ( router_base_url + \"/v{api_version}\" + url , router ) def error_serializer ( request , response , error ) : response . content_type = self . output_format . content_type response . body = self . output_format ( { \"errors\" : { error . title : error . description }}, request , response ) falcon_api . set_error_serializer ( error_serializer ) return falcon_api Ancestors (in MRO) hug.api.InterfaceAPI InterfaceAPI class ( api ) Defines the per-interface API which defines all shared information for a specific interface, and how it should be exposed View Source class InterfaceAPI ( object ) : \"\"\" Defines the per-interface API which defines all shared information for a specific interface, and how it should be exposed \"\"\" __slots__ = ( \" api \" , ) def __init__ ( self , api ) : self . api = api Descendants hug.api.HTTPInterfaceAPI hug.api.CLIInterfaceAPI ModuleSingleton class ( / , * args , ** kwargs ) Defines the module level hug singleton View Source class ModuleSingleton ( type ) : \"\"\" Defines the module level __hug__ singleton \"\"\" def __call__ ( cls , module = None , * args , ** kwargs ) : if isinstance ( module , API ) : return module if type ( module ) == str : if module not in sys . modules : sys . modules [ module ] = ModuleType ( module ) module = sys . modules [ module ] elif module is None : return super () . __call__ ( * args , ** kwargs ) if not \" __hug__ \" in module . __dict__ : def api_auto_instantiate ( * args , ** kwargs ) : if not hasattr ( module , \" __hug_serving__ \" ) : module . __hug_wsgi__ = module . __hug__ . http . server () module . __hug_serving__ = True return module . __hug_wsgi__ ( * args , ** kwargs ) module . __hug__ = super () . __call__ ( module , * args , ** kwargs ) module . __hug_wsgi__ = api_auto_instantiate return module . __hug__ Ancestors (in MRO) builtins.type","title":"API"},{"location":"reference/hug/api/#module-hugapi","text":"hug/api.py Defines the dynamically generated Hug API object that is responsible for storing all routes and state within a module Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\"hug/api.py Defines the dynamically generated Hug API object that is responsible for storing all routes and state within a module Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software \"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from __ future__ import absolute_import import asyncio import sys from collections import OrderedDict , namedtuple from distutils . util import strtobool from functools import partial from itertools import chain from types import ModuleType from wsgiref . simple_server import make_server import falcon from falcon import HTTP_METHODS import hug . defaults import hug . output_format from hug import introspect from hug . _ version import current INTRO = \"\" \" /#######################################################################\\\\ ` . ---- `` .. -------.. `` . ----. :/:::::--:---------:--::::://. . +::::----##/-/oo+:-##----::::// ` //::-------/oosoo-------::://. ## ## ## ## ##### . -:------./++o / o-.------::- ` ``` ## ## ## ## ## ` ----.-./+o+:..----. ` . :///. ######## ## ## ## ``` ` ----.-::::::------ ` . -:::://. ## ## ## ## ## #### ://::--. ``` -: `` ... -----... ` ` :- -::::::-. ` ## ## ## ## ## ## :/:::::::::-:- ````` . :::::-. ` ## ## #### ###### `` . --:::::::. . :::. ` `` .. ::. . :: EMBRACE THE APIs OF THE FUTURE ::- .:- -:: ` ::- VERSION { 0 } ` ::- -:: ` -::- ` -::- \\########################################################################/ Copyright ( C ) 2016 Timothy Edmund Crosley Under the MIT License \"\"\".format( current ) class InterfaceAPI(object): \"\"\" Defines the per - interface API which defines all shared information for a specific interface , and how it should be exposed \"\"\" __slots__ = (\" api \",) def __init__(self, api): self.api = api class HTTPInterfaceAPI(InterfaceAPI): \"\"\" Defines the HTTP interface specific API \"\"\" __slots__ = ( \" routes \", \" versions \", \" base_url \", \" falcon \", \" _ output_format \", \" _ input_format \", \" versioned \", \" _ middleware \", \" _ not_found_handlers \", \" sinks \", \" _ not_found \", \" _ exception_handlers \", ) def __init__(self, api, base_url=\"\"): super().__init__(api) self.versions = set() self.routes = OrderedDict() self.sinks = OrderedDict() self.versioned = OrderedDict() self.base_url = base_url @property def output_format(self): return getattr(self, \" _ output_format \", hug.defaults.output_format) @output_format.setter def output_format(self, formatter): self._output_format = formatter @property def not_found(self): \"\"\" Returns the active not found handler \"\"\" return getattr(self, \" _ not_found \", self.base_404) def urls(self): \"\"\" Returns a generator of all URLs attached to this API \"\"\" for base_url, mapping in self.routes.items(): for url, _ in mapping.items(): yield base_url + url def handlers(self): \"\"\" Returns all registered handlers attached to this API \"\"\" used = [] for _base_url, mapping in self.routes.items(): for _url, methods in mapping.items(): for _method, versions in methods.items(): for _version, handler in versions.items(): if not handler in used: used.append(handler) yield handler def input_format(self, content_type): \"\"\" Returns the set input_format handler for the given content_type \"\"\" return getattr(self, \" _ input_format \", {}).get( content_type, hug.defaults.input_format.get(content_type, None) ) def set_input_format(self, content_type, handler): \"\"\" Sets an input format handler for this Hug API , given the specified content_type \"\"\" if getattr(self, \" _ input_format \", None) is None: self._input_format = {} self._input_format[content_type] = handler @property def middleware(self): return getattr(self, \" _ middleware \", None) def add_middleware(self, middleware): \"\"\" Adds a middleware object used to process all incoming requests against the API \"\"\" if self.middleware is None: self._middleware = [] self.middleware.append(middleware) def add_sink(self, sink, url, base_url=\"\"): base_url = base_url or self.base_url self.sinks.setdefault(base_url, OrderedDict()) self.sinks[base_url][url] = sink def exception_handlers(self, version=None): if not hasattr(self, \" _ exception_handlers \"): return None return self._exception_handlers.get(version, self._exception_handlers.get(None, None)) def add_exception_handler(self, exception_type, error_handler, versions=(None,)): \"\"\" Adds a error handler to the hug api \"\"\" versions = (versions,) if not isinstance(versions, (tuple, list)) else versions if not hasattr(self, \" _ exception_handlers \"): self._exception_handlers = {} for version in versions: placement = self._exception_handlers.setdefault(version, OrderedDict()) placement[exception_type] = (error_handler,) + placement.get(exception_type, tuple()) def extend(self, http_api, route=\"\", base_url=\"\", **kwargs): \"\"\" Adds handlers from a different Hug API to this one - to create a single API \"\"\" self.versions.update(http_api.versions) base_url = base_url or self.base_url for _router_base_url, routes in http_api.routes.items(): self.routes.setdefault(base_url, OrderedDict()) for item_route, handler in routes.items(): for _method, versions in handler.items(): for _version, function in versions.items(): function.interface.api = self.api self.routes[base_url].setdefault(route + item_route, {}).update(handler) for _sink_base_url, sinks in http_api.sinks.items(): for url, sink in sinks.items(): self.add_sink(sink, route + url, base_url=base_url) for middleware in http_api.middleware or (): self.add_middleware(middleware) for version, handler in getattr(http_api, \" _ exception_handlers \", {}).items(): for exception_type, exception_handlers in handler.items(): target_exception_handlers = self.exception_handlers(version) or {} for exception_handler in exception_handlers: if exception_type not in target_exception_handlers: self.add_exception_handler(exception_type, exception_handler, version) for input_format, input_format_handler in getattr(http_api, \" _ input_format \", {}).items(): if not input_format in getattr(self, \" _ input_format \", {}): self.set_input_format(input_format, input_format_handler) for version, handler in http_api.not_found_handlers.items(): if version not in self.not_found_handlers: self.set_not_found_handler(handler, version) @property def not_found_handlers(self): return getattr(self, \" _ not_found_handlers \", {}) def set_not_found_handler(self, handler, version=None): \"\"\" Sets the not_found handler for the specified version of the api \"\"\" if not self.not_found_handlers: self._not_found_handlers = {} self.not_found_handlers[version] = handler def documentation(self, base_url=None, api_version=None, prefix=\"\"): \"\"\" Generates and returns documentation for this API endpoint \"\"\" documentation = OrderedDict() base_url = self.base_url if base_url is None else base_url overview = self.api.doc if overview: documentation[\" overview \"] = overview version_dict = OrderedDict() versions = self.versions versions_list = list(versions) if None in versions_list: versions_list.remove(None) if False in versions_list: versions_list.remove(False) if api_version is None and len(versions_list) > 0: api_version = max(versions_list) documentation[\" version \"] = api_version elif api_version is not None: documentation[\" version \"] = api_version if versions_list: documentation[\" versions \"] = versions_list for router_base_url, routes in self.routes.items(): for url, methods in routes.items(): for method, method_versions in methods.items(): for version, handler in method_versions.items(): if getattr(handler, \" private \", False): continue if version is None: applies_to = versions else: applies_to = (version,) for version in applies_to: if api_version and version != api_version: continue if base_url and router_base_url != base_url: continue doc = version_dict.setdefault(url, OrderedDict()) doc[method] = handler.documentation( doc.get(method, None), version=version, prefix=prefix, base_url=router_base_url, url=url, ) documentation[\" handlers \"] = version_dict return documentation def serve(self, host=\"\", port=8000, no_documentation=False, display_intro=True): \"\"\" Runs the basic hug development server against this API \"\"\" if no_documentation: api = self.server(None) else: api = self.server() if display_intro: print(INTRO) httpd = make_server(host, port, api) print(\" Serving on { 0 } : { 1 }... \".format(host, port)) httpd.serve_forever() @staticmethod def base_404(request, response, *args, **kwargs): \"\"\" Defines the base 404 handler \"\"\" response.status = falcon.HTTP_NOT_FOUND def determine_version(self, request, api_version=None): \"\"\" Determines the appropriate version given the set api_version , the request header , and URL query params \"\"\" if api_version is False: api_version = None for version in self.versions: if version and \" v { 0 } \".format(version) in request.path: api_version = version break request_version = set() if api_version is not None: request_version.add(api_version) version_header = request.get_header(\" X - API - VERSION \") if version_header: request_version.add(version_header) version_param = request.get_param(\" api_version \") if version_param is not None: request_version.add(version_param) if len(request_version) > 1: raise ValueError(\" You are requesting conflicting versions \") return next(iter(request_version or (None,))) def documentation_404(self, base_url=None): \"\"\" Returns a smart 404 page that contains documentation for the written API \"\"\" base_url = self.base_url if base_url is None else base_url def handle_404(request, response, *args, **kwargs): url_prefix = request.forwarded_uri[:-1] if request.path and request.path != \" / \": url_prefix = request.forwarded_uri.split(request.path)[0] to_return = OrderedDict() to_return[\" 404 \"] = ( \" The API call you tried to make was not defined . \" \" Here ' s a definition of the API to help you get going : ) \" ) to_return[\" documentation \"] = self.documentation( base_url, self.determine_version(request, False), prefix=url_prefix ) if self.output_format == hug.output_format.json: response.data = hug.output_format.json(to_return, indent=4, separators=(\" , \", \" : \")) response.content_type = \" application / json ; charset = utf - 8 \" else: response.data = self.output_format(to_return, request=request, response=response) response.content_type = self.output_format.content_type response.status = falcon.HTTP_NOT_FOUND handle_404.interface = True return handle_404 def version_router( self, request, response, api_version=None, versions=None, not_found=None, **kwargs ): \"\"\" Intelligently routes a request to the correct handler based on the version being requested \"\"\" versions = {} if versions is None else versions request_version = self.determine_version(request, api_version) if request_version: request_version = int(request_version) versions.get(request_version or False, versions.get(None, not_found))( request, response, api_version=api_version, **kwargs ) def server(self, default_not_found=True, base_url=None): \"\"\" Returns a WSGI compatible API server for the given Hug API module \"\"\" falcon_api = self.falcon = falcon.API(middleware=self.middleware) if not self.api.future: falcon_api.req_options.keep_blank_qs_values = False falcon_api.req_options.auto_parse_qs_csv = True falcon_api.req_options.strip_url_path_trailing_slash = True default_not_found = self.documentation_404() if default_not_found is True else None base_url = self.base_url if base_url is None else base_url not_found_handler = default_not_found self.api._ensure_started() if self.not_found_handlers: if len(self.not_found_handlers) == 1 and None in self.not_found_handlers: not_found_handler = self.not_found_handlers[None] else: not_found_handler = partial( self.version_router, api_version=False, versions=self.not_found_handlers, not_found=default_not_found, ) not_found_handler.interface = True if not_found_handler: falcon_api.add_sink(not_found_handler) self._not_found = not_found_handler for sink_base_url, sinks in self.sinks.items(): for url, extra_sink in sinks.items(): falcon_api.add_sink(extra_sink, sink_base_url + url + \" ( ? P < path>.* ) \") for router_base_url, routes in self.routes.items(): for url, methods in routes.items(): router = {} for method, versions in methods.items(): method_function = \" on_ { 0 } \".format(method.lower()) if len(versions) == 1 and None in versions.keys(): router[method_function] = versions[None] else: router[method_function] = partial( self.version_router, versions=versions, not_found=not_found_handler ) router = namedtuple(\" Router \", router.keys())(**router) falcon_api.add_route(router_base_url + url, router) if self.versions and self.versions != (None,): falcon_api.add_route(router_base_url + \" / v { api_version } \" + url, router) def error_serializer(request, response, error): response.content_type = self.output_format.content_type response.body = self.output_format( {\" errors \": {error.title: error.description}}, request, response ) falcon_api.set_error_serializer(error_serializer) return falcon_api HTTPInterfaceAPI.base_404.interface = True class CLIInterfaceAPI(InterfaceAPI): \"\"\" Defines the CLI interface specific API \"\"\" __slots__ = (\" commands \", \" error_exit_codes \", \" _ output_format \") def __init__(self, api, version=\"\", error_exit_codes=False): super().__init__(api) self.commands = {} self.error_exit_codes = error_exit_codes def __call__(self, args=None): \"\"\" Routes to the correct command line tool \"\"\" self.api._ensure_started() args = sys.argv if args is None else args if not len(args) > 1 or not args[1] in self.commands: print(str(self)) return sys.exit(1) command = args.pop(1) result = self.commands.get(command)() if self.error_exit_codes and bool(strtobool(result.decode(\" utf - 8 \"))) is False: sys.exit(1) def handlers(self): \"\"\" Returns all registered handlers attached to this API \"\"\" return self.commands.values() def extend(self, cli_api, command_prefix=\"\", sub_command=\"\", **kwargs): \"\"\" Extends this CLI api with the commands present in the provided cli_api object \"\"\" if sub_command and command_prefix: raise ValueError( \" It is not currently supported to provide both a command_prefix and sub_command \" ) if sub_command: self.commands[sub_command] = cli_api else: for name, command in cli_api.commands.items(): self.commands[\" {}{} \".format(command_prefix, name)] = command @property def output_format(self): return getattr(self, \" _ output_format \", hug.defaults.cli_output_format) @output_format.setter def output_format(self, formatter): self._output_format = formatter def __str__(self): output = \" { 0 } \\n\\nAvailable Commands :\\n\\n \".format(self.api.doc or self.api.name) for command_name, command in self.commands.items(): command_string = \" - {}{} \".format( command_name, \" : \" + str(command).replace(\" \\n \", \" \") if str(command) else \"\" ) output += command_string[:77] + \" ... \" if len(command_string) > 80 else command_string output += \" \\n \" return output class ModuleSingleton(type): \"\"\" Defines the module level __ hug__ singleton \"\"\" def __call__(cls, module=None, *args, **kwargs): if isinstance(module, API): return module if type(module) == str: if module not in sys.modules: sys.modules[module] = ModuleType(module) module = sys.modules[module] elif module is None: return super().__call__(*args, **kwargs) if not \" __ hug__ \" in module.__dict__: def api_auto_instantiate(*args, **kwargs): if not hasattr(module, \" __ hug_serving__ \"): module.__hug_wsgi__ = module.__hug__.http.server() module.__hug_serving__ = True return module.__hug_wsgi__(*args, **kwargs) module.__hug__ = super().__call__(module, *args, **kwargs) module.__hug_wsgi__ = api_auto_instantiate return module.__hug__ class API(object, metaclass=ModuleSingleton): \"\"\" Stores the information necessary to expose API calls within this module externally \"\"\" __slots__ = ( \" module \", \" _ directives \", \" _ http \", \" _ cli \", \" _ context \", \" _ context_factory \", \" _ delete_context \", \" _ startup_handlers \", \" started \", \" name \", \" doc \", \" future \", \" cli_error_exit_codes \", ) def __init__(self, module=None, name=\"\", doc=\"\", cli_error_exit_codes=False, future=False): self.module = module if module: self.name = name or module.__name__ or \"\" self.doc = doc or module.__doc__ or \"\" else: self.name = name self.doc = doc self.started = False self.cli_error_exit_codes = cli_error_exit_codes self.future = future def directives(self): \"\"\" Returns all directives applicable to this Hug API \"\"\" directive_sources = chain( hug.defaults.directives.items(), getattr(self, \" _ directives \", {}).items() ) return { \" hug_ \" + directive_name: directive for directive_name, directive in directive_sources } def directive(self, name, default=None): \"\"\" Returns the loaded directive with the specified name , or default if passed name is not present \"\"\" return getattr(self, \" _ directives \", {}).get( name, hug.defaults.directives.get(name, default) ) def add_directive(self, directive): self._directives = getattr(self, \" _ directives \", {}) self._directives[directive.__name__] = directive def handlers(self): \"\"\" Returns all registered handlers attached to this API \"\"\" if getattr(self, \" _ http \", None): yield from self.http.handlers() if getattr(self, \" _ cli \", None): yield from self.cli.handlers() @property def http(self): if not hasattr(self, \" _ http \"): self._http = HTTPInterfaceAPI(self) return self._http @property def cli(self): if not hasattr(self, \" _ cli \"): self._cli = CLIInterfaceAPI(self, error_exit_codes=self.cli_error_exit_codes) return self._cli @property def context_factory(self): return getattr(self, \" _ context_factory \", hug.defaults.context_factory) @context_factory.setter def context_factory(self, context_factory_): self._context_factory = context_factory_ @property def delete_context(self): return getattr(self, \" _ delete_context \", hug.defaults.delete_context) @delete_context.setter def delete_context(self, delete_context_): self._delete_context = delete_context_ @property def context(self): if not hasattr(self, \" _ context \"): self._context = {} return self._context def extend(self, api, route=\"\", base_url=\"\", http=True, cli=True, **kwargs): \"\"\" Adds handlers from a different Hug API to this one - to create a single API \"\"\" api = API(api) if http and hasattr(api, \" _ http \"): self.http.extend(api.http, route, base_url, **kwargs) if cli and hasattr(api, \" _ cli \"): self.cli.extend(api.cli, **kwargs) for directive in getattr(api, \" _ directives \", {}).values(): self.add_directive(directive) for startup_handler in api.startup_handlers or (): self.add_startup_handler(startup_handler) def add_startup_handler(self, handler): \"\"\" Adds a startup handler to the hug api \"\"\" if not self.startup_handlers: self._startup_handlers = [] self.startup_handlers.append(handler) def _ensure_started(self): \"\"\" Marks the API as started and runs all startup handlers \"\"\" if not self.started: async_handlers = [ startup_handler for startup_handler in self.startup_handlers if introspect.is_coroutine(startup_handler) ] if async_handlers: loop = asyncio.get_event_loop() loop.run_until_complete( asyncio.gather(*[handler(self) for handler in async_handlers], loop=loop) ) for startup_handler in self.startup_handlers: if not startup_handler in async_handlers: startup_handler(self) @property def startup_handlers(self): return getattr(self, \" _ startup_handlers \", ()) def from_object(obj): \"\"\" Returns a Hug API instance from a given object ( function , class , instance ) \"\" \" return API ( obj . __ module__ )","title":"Module hug.api"},{"location":"reference/hug/api/#variables","text":"HTTP_METHODS INTRO current","title":"Variables"},{"location":"reference/hug/api/#functions","text":"","title":"Functions"},{"location":"reference/hug/api/#from_object","text":"def ( obj ) Returns a Hug API instance from a given object (function, class, instance) View Source def from_object ( obj ) : \"\"\" Returns a Hug API instance from a given object (function, class, instance) \"\"\" return API ( obj . __module__ )","title":"from_object"},{"location":"reference/hug/api/#classes","text":"","title":"Classes"},{"location":"reference/hug/api/#api","text":"class ( module = None , name = '' , doc = '' , cli_error_exit_codes = False , future = False ) Stores the information necessary to expose API calls within this module externally View Source class API ( object , metaclass = ModuleSingleton ) : \"\"\" Stores the information necessary to expose API calls within this module externally \"\"\" __slots__ = ( \" module \" , \" _directives \" , \" _http \" , \" _cli \" , \" _context \" , \" _context_factory \" , \" _delete_context \" , \" _startup_handlers \" , \" started \" , \" name \" , \" doc \" , \" future \" , \" cli_error_exit_codes \" , ) def __init__ ( self , module = None , name = \"\" , doc = \"\" , cli_error_exit_codes = False , future = False ) : self . module = module if module : self . name = name or module . __name__ or \"\" self . doc = doc or module . __doc__ or \"\" else : self . name = name self . doc = doc self . started = False self . cli_error_exit_codes = cli_error_exit_codes self . future = future def directives ( self ) : \"\"\" Returns all directives applicable to this Hug API \"\"\" directive_sources = chain ( hug . defaults . directives . items () , getattr ( self , \" _directives \" , {} ) . items () ) return { \" hug_ \" + directive_name : directive for directive_name , directive in directive_sources } def directive ( self , name , default = None ) : \"\"\" Returns the loaded directive with the specified name, or default if passed name is not present \"\"\" return getattr ( self , \" _directives \" , {} ) . get ( name , hug . defaults . directives . get ( name , default ) ) def add_directive ( self , directive ) : self . _directives = getattr ( self , \" _directives \" , {} ) self . _directives [ directive . __name__ ] = directive def handlers ( self ) : \"\"\" Returns all registered handlers attached to this API \"\"\" if getattr ( self , \" _http \" , None ) : yield from self . http . handlers () if getattr ( self , \" _cli \" , None ) : yield from self . cli . handlers () @ property def http ( self ) : if not hasattr ( self , \" _http \" ) : self . _http = HTTPInterfaceAPI ( self ) return self . _http @ property def cli ( self ) : if not hasattr ( self , \" _cli \" ) : self . _cli = CLIInterfaceAPI ( self , error_exit_codes = self . cli_error_exit_codes ) return self . _cli @ property def context_factory ( self ) : return getattr ( self , \" _context_factory \" , hug . defaults . context_factory ) @ context_factory . setter def context_factory ( self , context_factory_ ) : self . _context_factory = context_factory_ @ property def delete_context ( self ) : return getattr ( self , \" _delete_context \" , hug . defaults . delete_context ) @ delete_context . setter def delete_context ( self , delete_context_ ) : self . _delete_context = delete_context_ @ property def context ( self ) : if not hasattr ( self , \" _context \" ) : self . _context = {} return self . _context def extend ( self , api , route = \"\" , base_url = \"\" , http = True , cli = True , ** kwargs ) : \"\"\" Adds handlers from a different Hug API to this one - to create a single API \"\"\" api = API ( api ) if http and hasattr ( api , \" _http \" ) : self . http . extend ( api . http , route , base_url , ** kwargs ) if cli and hasattr ( api , \" _cli \" ) : self . cli . extend ( api . cli , ** kwargs ) for directive in getattr ( api , \" _directives \" , {} ) . values () : self . add_directive ( directive ) for startup_handler in api . startup_handlers or () : self . add_startup_handler ( startup_handler ) def add_startup_handler ( self , handler ) : \"\"\" Adds a startup handler to the hug api \"\"\" if not self . startup_handlers : self . _startup_handlers = [] self . startup_handlers . append ( handler ) def _ensure_started ( self ) : \"\"\" Marks the API as started and runs all startup handlers \"\"\" if not self . started : async_handlers = [ startup_handler for startup_handler in self . startup_handlers if introspect . is_coroutine ( startup_handler ) ] if async_handlers : loop = asyncio . get_event_loop () loop . run_until_complete ( asyncio . gather ( * [ handler ( self ) for handler in async_handlers ], loop = loop ) ) for startup_handler in self . startup_handlers : if not startup_handler in async_handlers : startup_handler ( self ) @ property def startup_handlers ( self ) : return getattr ( self , \" _startup_handlers \" , ())","title":"API"},{"location":"reference/hug/api/#cliinterfaceapi","text":"class ( api , version = '' , error_exit_codes = False ) Defines the CLI interface specific API View Source class CLIInterfaceAPI ( InterfaceAPI ) : \"\"\" Defines the CLI interface specific API \"\"\" __slots__ = ( \" commands \" , \" error_exit_codes \" , \" _output_format \" ) def __init__ ( self , api , version = \"\" , error_exit_codes = False ) : super () . __init__ ( api ) self . commands = {} self . error_exit_codes = error_exit_codes def __call__ ( self , args = None ) : \"\"\" Routes to the correct command line tool \"\"\" self . api . _ensure_started () args = sys . argv if args is None else args if not len ( args ) > 1 or not args [ 1 ] in self . commands : print ( str ( self )) return sys . exit ( 1 ) command = args . pop ( 1 ) result = self . commands . get ( command )() if self . error_exit_codes and bool ( strtobool ( result . decode ( \" utf-8 \" ))) is False : sys . exit ( 1 ) def handlers ( self ) : \"\"\" Returns all registered handlers attached to this API \"\"\" return self . commands . values () def extend ( self , cli_api , command_prefix = \"\" , sub_command = \"\" , ** kwargs ) : \"\"\" Extends this CLI api with the commands present in the provided cli_api object \"\"\" if sub_command and command_prefix : raise ValueError ( \" It is not currently supported to provide both a command_prefix and sub_command \" ) if sub_command : self . commands [ sub_command ] = cli_api else : for name , command in cli_api . commands . items () : self . commands [ \" {}{} \" . format ( command_prefix , name ) ] = command @ property def output_format ( self ) : return getattr ( self , \" _output_format \" , hug . defaults . cli_output_format ) @ output_format . setter def output_format ( self , formatter ) : self . _output_format = formatter def __str__ ( self ) : output = \" {0} \\n\\n Available Commands: \\n\\n \" . format ( self . api . doc or self . api . name ) for command_name , command in self . commands . items () : command_string = \" - {}{} \" . format ( command_name , \" : \" + str ( command ) . replace ( \" \\n \" , \" \" ) if str ( command ) else \"\" ) output += command_string [: 77 ] + \" ... \" if len ( command_string ) > 80 else command_string output += \" \\n \" return output","title":"CLIInterfaceAPI"},{"location":"reference/hug/api/#ancestors-in-mro","text":"hug.api.InterfaceAPI","title":"Ancestors (in MRO)"},{"location":"reference/hug/api/#httpinterfaceapi","text":"class ( api , base_url = '' ) Defines the HTTP interface specific API View Source class HTTPInterfaceAPI ( InterfaceAPI ) : \"\"\"Defines the HTTP interface specific API\"\"\" __ slots__ = ( \"routes\" , \"versions\" , \"base_url\" , \"falcon\" , \"_output_format\" , \"_input_format\" , \"versioned\" , \"_middleware\" , \"_not_found_handlers\" , \"sinks\" , \"_not_found\" , \"_exception_handlers\" , ) def __ init__ ( self , api , base_url= \"\" ) : super (). __ init__ ( api ) self . versions = set () self . routes = OrderedDict () self . sinks = OrderedDict () self . versioned = OrderedDict () self . base_url = base_url @property def output_format ( self ) : return getattr ( self , \"_output_format\" , hug . defaults . output_format ) @output_format . setter def output_format ( self , formatter ) : self . _ output_format = formatter @property def not_found ( self ) : \"\"\"Returns the active not found handler\"\"\" return getattr ( self , \"_not_found\" , self . base_404 ) def urls ( self ) : \"\"\"Returns a generator of all URLs attached to this API\"\"\" for base_url , mapping in self . routes . items () : for url , _ in mapping . items () : yield base_url + url def handlers ( self ) : \"\"\"Returns all registered handlers attached to this API\"\"\" used = [] for _ base_url , mapping in self . routes . items () : for _ url , methods in mapping . items () : for _ method , versions in methods . items () : for _ version , handler in versions . items () : if not handler in used : used . append ( handler ) yield handler def input_format ( self , content_type ) : \"\"\"Returns the set input_format handler for the given content_type\"\"\" return getattr ( self , \"_input_format\" , {}). get ( content_type , hug . defaults . input_format . get ( content_type , None ) ) def set_input_format ( self , content_type , handler ) : \"\"\"Sets an input format handler for this Hug API, given the specified content_type\"\"\" if getattr ( self , \"_input_format\" , None ) is None : self . _ input_format = {} self . _ input_format [ content_type ] = handler @property def middleware ( self ) : return getattr ( self , \"_middleware\" , None ) def add_middleware ( self , middleware ) : \"\"\"Adds a middleware object used to process all incoming requests against the API\"\"\" if self . middleware is None : self . _ middleware = [] self . middleware . append ( middleware ) def add_sink ( self , sink , url , base_url= \"\" ) : base_url = base_url or self . base_url self . sinks . setdefault ( base_url , OrderedDict ()) self . sinks [ base_url ][ url ] = sink def exception_handlers ( self , version = None ) : if not hasattr ( self , \"_exception_handlers\" ) : return None return self . _ exception_handlers . get ( version , self . _ exception_handlers . get ( None , None )) def add_exception_handler ( self , exception_type , error_handler , versions= ( None ,)) : \"\"\"Adds a error handler to the hug api\"\"\" versions = ( versions ,) if not isinstance ( versions , ( tuple , list )) else versions if not hasattr ( self , \"_exception_handlers\" ) : self . _ exception_handlers = {} for version in versions : placement = self . _ exception_handlers . setdefault ( version , OrderedDict ()) placement [ exception_type ] = ( error_handler ,) + placement . get ( exception_type , tuple ()) def extend ( self , http_api , route= \"\" , base_url= \"\" , **kwargs ) : \"\"\"Adds handlers from a different Hug API to this one - to create a single API\"\"\" self . versions . update ( http_api . versions ) base_url = base_url or self . base_url for _ router_base_url , routes in http_api . routes . items () : self . routes . setdefault ( base_url , OrderedDict ()) for item_route , handler in routes . items () : for _ method , versions in handler . items () : for _ version , function in versions . items () : function . interface . api = self . api self . routes [ base_url ]. setdefault ( route + item_route , {}). update ( handler ) for _ sink_base_url , sinks in http_api . sinks . items () : for url , sink in sinks . items () : self . add_sink ( sink , route + url , base_url = base_url ) for middleware in http_api . middleware or () : self . add_middleware ( middleware ) for version , handler in getattr ( http_api , \"_exception_handlers\" , {}). items () : for exception_type , exception_handlers in handler . items () : target_exception_handlers = self . exception_handlers ( version ) or {} for exception_handler in exception_handlers: if exception_type not in target_exception_handlers: self . add_exception_handler ( exception_type , exception_handler , version ) for input_format , input_format_handler in getattr ( http_api , \"_input_format\" , {}). items () : if not input_format in getattr ( self , \"_input_format\" , {}) : self . set_input_format ( input_format , input_format_handler ) for version , handler in http_api . not_found_handlers . items () : if version not in self . not_found_handlers: self . set_not_found_handler ( handler , version ) @property def not_found_handlers ( self ) : return getattr ( self , \"_not_found_handlers\" , {}) def set_not_found_handler ( self , handler , version = None ) : \"\"\"Sets the not_found handler for the specified version of the api\"\"\" if not self . not_found_handlers: self . _ not_found_handlers = {} self . not_found_handlers [ version ] = handler def documentation ( self , base_url = None , api_version = None , prefix= \"\" ) : \"\"\"Generates and returns documentation for this API endpoint\"\"\" documentation = OrderedDict () base_url = self . base_url if base_url is None else base_url overview = self . api . doc if overview : documentation [ \"overview\" ] = overview version_dict = OrderedDict () versions = self . versions versions_list = list ( versions ) if None in versions_list: versions_list . remove ( None ) if False in versions_list: versions_list . remove ( False ) if api_version is None and len ( versions_list ) > 0 : api_version = max ( versions_list ) documentation [ \"version\" ] = api_version elif api_version is not None : documentation [ \"version\" ] = api_version if versions_list: documentation [ \"versions\" ] = versions_list for router_base_url , routes in self . routes . items () : for url , methods in routes . items () : for method , method_versions in methods . items () : for version , handler in method_versions . items () : if getattr ( handler , \"private\" , False ) : continue if version is None : applies_to = versions else : applies_to = ( version ,) for version in applies_to: if api_version and version ! = api_version: continue if base_url and router_base_url ! = base_url: continue doc = version_dict . setdefault ( url , OrderedDict ()) doc [ method ] = handler . documentation ( doc . get ( method , None ), version = version , prefix = prefix , base_url = router_base_url , url = url , ) documentation [ \"handlers\" ] = version_dict return documentation def serve ( self , host= \"\" , port = 8000 , no_documentation = False , display_intro = True ) : \"\"\"Runs the basic hug development server against this API\"\"\" if no_documentation: api = self . server ( None ) else : api = self . server () if display_intro: print ( INTRO ) httpd = make_server ( host , port , api ) print ( \"Serving on {0}:{1}...\" . format ( host , port )) httpd . serve_forever () @staticmethod def base_404 ( request , response , * args , **kwargs ) : \"\"\"Defines the base 404 handler\"\"\" response . status = falcon . HTTP_NOT_FOUND def determine_version ( self , request , api_version = None ) : \"\"\"Determines the appropriate version given the set api_version, the request header, and URL query params\"\"\" if api_version is False : api_version = None for version in self . versions : if version and \"v{0}\" . format ( version ) in request . path : api_version = version break request_version = set () if api_version is not None : request_version . add ( api_version ) version_header = request . get_header ( \"X-API-VERSION\" ) if version_header: request_version . add ( version_header ) version_param = request . get_param ( \"api_version\" ) if version_param is not None : request_version . add ( version_param ) if len ( request_version ) > 1 : raise ValueError ( \"You are requesting conflicting versions\" ) return next ( iter ( request_version or ( None ,))) def documentation_404 ( self , base_url = None ) : \"\"\"Returns a smart 404 page that contains documentation for the written API\"\"\" base_url = self . base_url if base_url is None else base_url def handle_404 ( request , response , * args , **kwargs ) : url_prefix = request . forwarded_uri [:- 1 ] if request . path and request . path ! = \"/\" : url_prefix = request . forwarded_uri . split ( request . path )[ 0 ] to_return = OrderedDict () to_return [ \"404\" ] = ( \"The API call you tried to make was not defined. \" \"Here's a definition of the API to help you get going :)\" ) to_return [ \"documentation\" ] = self . documentation ( base_url , self . determine_version ( request , False ), prefix = url_prefix ) if self . output_format == hug . output_format . json : response . data = hug . output_format . json ( to_return , indent = 4 , separators= ( \",\" , \": \" )) response . content_type = \"application/json; charset=utf-8\" else : response . data = self . output_format ( to_return , request = request , response = response ) response . content_type = self . output_format . content_type response . status = falcon . HTTP_NOT_FOUND handle_404 . interface = True return handle_404 def version_router ( self , request , response , api_version = None , versions = None , not_found = None , **kwargs ) : \"\"\"Intelligently routes a request to the correct handler based on the version being requested\"\"\" versions = {} if versions is None else versions request_version = self . determine_version ( request , api_version ) if request_version: request_version = int ( request_version ) versions . get ( request_version or False , versions . get ( None , not_found ))( request , response , api_version = api_version , **kwargs ) def server ( self , default_not_found = True , base_url = None ) : \"\"\"Returns a WSGI compatible API server for the given Hug API module\"\"\" falcon_api = self . falcon = falcon . API ( middleware = self . middleware ) if not self . api . future : falcon_api . req_options . keep_blank_qs_values = False falcon_api . req_options . auto_parse_qs_csv = True falcon_api . req_options . strip_url_path_trailing_slash = True default_not_found = self . documentation_404 () if default_not_found is True else None base_url = self . base_url if base_url is None else base_url not_found_handler = default_not_found self . api . _ ensure_started () if self . not_found_handlers: if len ( self . not_found_handlers ) == 1 and None in self . not_found_handlers: not_found_handler = self . not_found_handlers [ None ] else : not_found_handler = partial ( self . version_router , api_version = False , versions = self . not_found_handlers , not_found = default_not_found , ) not_found_handler . interface = True if not_found_handler: falcon_api . add_sink ( not_found_handler ) self . _ not_found = not_found_handler for sink_base_url , sinks in self . sinks . items () : for url , extra_sink in sinks . items () : falcon_api . add_sink ( extra_sink , sink_base_url + url + \"(?P<path>.*)\" ) for router_base_url , routes in self . routes . items () : for url , methods in routes . items () : router = {} for method , versions in methods . items () : method_function = \"on_{0}\" . format ( method . lower ()) if len ( versions ) == 1 and None in versions . keys () : router [ method_function ] = versions [ None ] else : router [ method_function ] = partial ( self . version_router , versions = versions , not_found = not_found_handler ) router = namedtuple ( \"Router\" , router . keys ())( **router ) falcon_api . add_route ( router_base_url + url , router ) if self . versions and self . versions ! = ( None ,) : falcon_api . add_route ( router_base_url + \"/v{api_version}\" + url , router ) def error_serializer ( request , response , error ) : response . content_type = self . output_format . content_type response . body = self . output_format ( { \"errors\" : { error . title : error . description }}, request , response ) falcon_api . set_error_serializer ( error_serializer ) return falcon_api","title":"HTTPInterfaceAPI"},{"location":"reference/hug/api/#ancestors-in-mro_1","text":"hug.api.InterfaceAPI","title":"Ancestors (in MRO)"},{"location":"reference/hug/api/#interfaceapi","text":"class ( api ) Defines the per-interface API which defines all shared information for a specific interface, and how it should be exposed View Source class InterfaceAPI ( object ) : \"\"\" Defines the per-interface API which defines all shared information for a specific interface, and how it should be exposed \"\"\" __slots__ = ( \" api \" , ) def __init__ ( self , api ) : self . api = api","title":"InterfaceAPI"},{"location":"reference/hug/api/#descendants","text":"hug.api.HTTPInterfaceAPI hug.api.CLIInterfaceAPI","title":"Descendants"},{"location":"reference/hug/api/#modulesingleton","text":"class ( / , * args , ** kwargs ) Defines the module level hug singleton View Source class ModuleSingleton ( type ) : \"\"\" Defines the module level __hug__ singleton \"\"\" def __call__ ( cls , module = None , * args , ** kwargs ) : if isinstance ( module , API ) : return module if type ( module ) == str : if module not in sys . modules : sys . modules [ module ] = ModuleType ( module ) module = sys . modules [ module ] elif module is None : return super () . __call__ ( * args , ** kwargs ) if not \" __hug__ \" in module . __dict__ : def api_auto_instantiate ( * args , ** kwargs ) : if not hasattr ( module , \" __hug_serving__ \" ) : module . __hug_wsgi__ = module . __hug__ . http . server () module . __hug_serving__ = True return module . __hug_wsgi__ ( * args , ** kwargs ) module . __hug__ = super () . __call__ ( module , * args , ** kwargs ) module . __hug_wsgi__ = api_auto_instantiate return module . __hug__","title":"ModuleSingleton"},{"location":"reference/hug/api/#ancestors-in-mro_2","text":"builtins.type","title":"Ancestors (in MRO)"},{"location":"reference/hug/authentication/","text":"Module hug.authentication hug/authentication.py Provides the basic built-in authentication helper functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/authentication.py Provides the basic built - in authentication helper functions Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import base64 import binascii from falcon import HTTPUnauthorized def authenticator ( function , challenges = ()) : \"\"\" Wraps authentication logic, verify_user through to the authentication function. The verify_user function passed in should accept an API key and return a user object to store in the request context if authentication succeeded . \"\"\" challenges = challenges or ( ' {} realm=\"simple\" ' . format ( function . __name__ ) , ) def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate return wrapper @ authenticator def basic ( request , response , verify_user , realm = \" simple \" , context = None , ** kwargs ) : \"\"\" Basic HTTP Authentication \"\"\" http_auth = request . auth response . set_header ( \" WWW-Authenticate \" , \" Basic \" ) if http_auth is None : return if isinstance ( http_auth , bytes ) : http_auth = http_auth . decode ( \" utf8 \" ) try : auth_type , user_and_key = http_auth . split ( \" \" , 1 ) except ValueError : raise HTTPUnauthorized ( \" Authentication Error \" , \" Authentication header is improperly formed \" , challenges = ( ' Basic realm=\"{}\" ' . format ( realm ) , ) , ) if auth_type . lower () == \" basic \" : try : user_id , key = ( base64 . decodebytes ( bytes ( user_and_key . strip () , \" utf8 \" )) . decode ( \" utf8 \" ) . split ( \" : \" , 1 ) ) try : user = verify_user ( user_id , key ) except TypeError : user = verify_user ( user_id , key , context ) if user : response . set_header ( \" WWW-Authenticate \" , \"\" ) return user except ( binascii . Error , ValueError ) : raise HTTPUnauthorized ( \" Authentication Error \" , \" Unable to determine user and password with provided encoding \" , challenges = ( ' Basic realm=\"{}\" ' . format ( realm ) , ) , ) return False @ authenticator def api_key ( request , response , verify_user , context = None , ** kwargs ) : \"\"\" API Key Header Authentication The verify_user function passed in to ths authenticator shall receive an API key as input , and return a user object to store in the request context if the request was successful . \"\"\" api_key = request . get_header ( \" X-Api-Key \" ) if api_key : try : user = verify_user ( api_key ) except TypeError : user = verify_user ( api_key , context ) if user : return user else : return False else : return None @ authenticator def token ( request , response , verify_user , context = None , ** kwargs ) : \"\"\" Token verification Checks for the Authorization header and verifies using the verify_user function \"\"\" token = request . get_header ( \" Authorization \" ) if token : try : verified_token = verify_user ( token ) except TypeError : verified_token = verify_user ( token , context ) if verified_token : return verified_token else : return False return None def verify ( user , password ) : \"\"\" Returns a simple verification callback that simply verifies that the users and password match that provided \"\"\" def verify_user ( user_name , user_password ) : if user_name == user and user_password == password : return user_name return False return verify_user Functions api_key def ( verify_user ) View Source def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate authenticator def ( function , challenges = () ) Wraps authentication logic, verify_user through to the authentication function. The verify_user function passed in should accept an API key and return a user object to store in the request context if authentication succeeded. View Source def authenticator ( function , challenges = ()) : \"\"\" Wraps authentication logic, verify_user through to the authentication function. The verify_user function passed in should accept an API key and return a user object to store in the request context if authentication succeeded . \"\"\" challenges = challenges or ( ' {} realm=\"simple\" ' . format ( function . __name__ ) , ) def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate return wrapper basic def ( verify_user ) View Source def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate token def ( verify_user ) View Source def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate verify def ( user , password ) Returns a simple verification callback that simply verifies that the users and password match that provided View Source def verify ( user , password ) : \"\"\" Returns a simple verification callback that simply verifies that the users and password match that provided \"\"\" def verify_user ( user_name , user_password ) : if user_name == user and user_password == password : return user_name return False return verify_user","title":"Authentication"},{"location":"reference/hug/authentication/#module-hugauthentication","text":"hug/authentication.py Provides the basic built-in authentication helper functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/authentication.py Provides the basic built - in authentication helper functions Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import base64 import binascii from falcon import HTTPUnauthorized def authenticator ( function , challenges = ()) : \"\"\" Wraps authentication logic, verify_user through to the authentication function. The verify_user function passed in should accept an API key and return a user object to store in the request context if authentication succeeded . \"\"\" challenges = challenges or ( ' {} realm=\"simple\" ' . format ( function . __name__ ) , ) def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate return wrapper @ authenticator def basic ( request , response , verify_user , realm = \" simple \" , context = None , ** kwargs ) : \"\"\" Basic HTTP Authentication \"\"\" http_auth = request . auth response . set_header ( \" WWW-Authenticate \" , \" Basic \" ) if http_auth is None : return if isinstance ( http_auth , bytes ) : http_auth = http_auth . decode ( \" utf8 \" ) try : auth_type , user_and_key = http_auth . split ( \" \" , 1 ) except ValueError : raise HTTPUnauthorized ( \" Authentication Error \" , \" Authentication header is improperly formed \" , challenges = ( ' Basic realm=\"{}\" ' . format ( realm ) , ) , ) if auth_type . lower () == \" basic \" : try : user_id , key = ( base64 . decodebytes ( bytes ( user_and_key . strip () , \" utf8 \" )) . decode ( \" utf8 \" ) . split ( \" : \" , 1 ) ) try : user = verify_user ( user_id , key ) except TypeError : user = verify_user ( user_id , key , context ) if user : response . set_header ( \" WWW-Authenticate \" , \"\" ) return user except ( binascii . Error , ValueError ) : raise HTTPUnauthorized ( \" Authentication Error \" , \" Unable to determine user and password with provided encoding \" , challenges = ( ' Basic realm=\"{}\" ' . format ( realm ) , ) , ) return False @ authenticator def api_key ( request , response , verify_user , context = None , ** kwargs ) : \"\"\" API Key Header Authentication The verify_user function passed in to ths authenticator shall receive an API key as input , and return a user object to store in the request context if the request was successful . \"\"\" api_key = request . get_header ( \" X-Api-Key \" ) if api_key : try : user = verify_user ( api_key ) except TypeError : user = verify_user ( api_key , context ) if user : return user else : return False else : return None @ authenticator def token ( request , response , verify_user , context = None , ** kwargs ) : \"\"\" Token verification Checks for the Authorization header and verifies using the verify_user function \"\"\" token = request . get_header ( \" Authorization \" ) if token : try : verified_token = verify_user ( token ) except TypeError : verified_token = verify_user ( token , context ) if verified_token : return verified_token else : return False return None def verify ( user , password ) : \"\"\" Returns a simple verification callback that simply verifies that the users and password match that provided \"\"\" def verify_user ( user_name , user_password ) : if user_name == user and user_password == password : return user_name return False return verify_user","title":"Module hug.authentication"},{"location":"reference/hug/authentication/#functions","text":"","title":"Functions"},{"location":"reference/hug/authentication/#api_key","text":"def ( verify_user ) View Source def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate","title":"api_key"},{"location":"reference/hug/authentication/#authenticator","text":"def ( function , challenges = () ) Wraps authentication logic, verify_user through to the authentication function. The verify_user function passed in should accept an API key and return a user object to store in the request context if authentication succeeded. View Source def authenticator ( function , challenges = ()) : \"\"\" Wraps authentication logic, verify_user through to the authentication function. The verify_user function passed in should accept an API key and return a user object to store in the request context if authentication succeeded . \"\"\" challenges = challenges or ( ' {} realm=\"simple\" ' . format ( function . __name__ ) , ) def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate return wrapper","title":"authenticator"},{"location":"reference/hug/authentication/#basic","text":"def ( verify_user ) View Source def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate","title":"basic"},{"location":"reference/hug/authentication/#token","text":"def ( verify_user ) View Source def wrapper ( verify_user ) : def authenticate ( request , response , ** kwargs ) : result = function ( request , response , verify_user , ** kwargs ) def authenticator_name () : try : return function . __doc__ . splitlines () [ 0 ] except AttributeError : return function . __name__ if result is None : raise HTTPUnauthorized ( \" Authentication Required \" , \" Please provide valid {0} credentials \" . format ( authenticator_name ()) , challenges = challenges , ) if result is False : raise HTTPUnauthorized ( \" Invalid Authentication \" , \" Provided {0} credentials were invalid \" . format ( authenticator_name ()) , challenges = challenges , ) request . context [ \" user \" ] = result return True authenticate . __doc__ = function . __doc__ return authenticate","title":"token"},{"location":"reference/hug/authentication/#verify","text":"def ( user , password ) Returns a simple verification callback that simply verifies that the users and password match that provided View Source def verify ( user , password ) : \"\"\" Returns a simple verification callback that simply verifies that the users and password match that provided \"\"\" def verify_user ( user_name , user_password ) : if user_name == user and user_password == password : return user_name return False return verify_user","title":"verify"},{"location":"reference/hug/decorators/","text":"Module hug.decorators hug/decorators.py Defines the method decorators at the core of Hug's approach to creating HTTP APIs Decorators for exposing python method as HTTP methods (get, post, etc) Decorators for setting the default output and input formats used throughout an API using the framework Decorator for registering a new directive method Decorator for including another API modules handlers into the current one, with opitonal prefix route Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/decorators.py Defines the method decorators at the core of Hug ' s approach to creating HTTP APIs - Decorators for exposing python method as HTTP methods ( get , post , etc ) - Decorators for setting the default output and input formats used throughout an API using the framework - Decorator for registering a new directive method - Decorator for including another API modules handlers into the current one , with opitonal prefix route Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import functools from collections import namedtuple from falcon import HTTP_METHODS import hug . api import hug . defaults import hug . output_format from hug import introspect from hug . format import underscore def default_output_format ( content_type = \" application/json \" , apply_globally = False , api = None , cli = False , http = True ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : if http : hug . defaults . output_format = formatter if cli : hug . defaults . cli_output_format = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) if http : apply_to_api . http . output_format = formatter if cli : apply_to_api . cli . output_format = formatter return formatter return decorator def default_input_format ( content_type = \" application/json \" , apply_globally = False , api = None ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : hug . defaults . input_format [ content_type ] = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) apply_to_api . http . set_input_format ( content_type , formatter ) return formatter return decorator def directive ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug directive \"\"\" def decorator ( directive_method ) : if apply_globally : hug . defaults . directives [ underscore ( directive_method . __name__ ) ] = directive_method else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( directive_method ) apply_to_api . add_directive ( directive_method ) directive_method . directive = True return directive_method return decorator def context_factory ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug context factory \"\"\" def decorator ( context_factory_ ) : if apply_globally : hug . defaults . context_factory = context_factory_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( context_factory_ ) apply_to_api . context_factory = context_factory_ return context_factory_ return decorator def delete_context ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug delete context function \"\"\" def decorator ( delete_context_ ) : if apply_globally : hug . defaults . delete_context = delete_context_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( delete_context_ ) apply_to_api . delete_context = delete_context_ return delete_context_ return decorator def startup ( api = None ) : \"\"\" Runs the provided function on startup, passing in an instance of the api \"\"\" def startup_wrapper ( startup_function ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( startup_function ) apply_to_api . add_startup_handler ( startup_function ) return startup_function return startup_wrapper def request_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_request ( self , request , response ) : return middleware_method ( request , response ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator def response_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every response \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_response ( self , request , response , resource , _req_succeeded ) : return middleware_method ( request , response , resource ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator def reqresp_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request and response \"\"\" def decorator ( middleware_generator ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_generator ) class MiddlewareRouter ( object ) : __slots__ = ( \" gen \" , ) def process_request ( self , request , response ) : self . gen = middleware_generator ( request ) return self . gen . __next__ () def process_response ( self , request , response , resource , _req_succeeded ) : return self . gen . send (( response , resource )) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_generator return decorator def middleware_class ( api = None ) : \"\"\" Registers a middleware class \"\"\" def decorator ( middleware_class ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_class ) apply_to_api . http . add_middleware ( middleware_class ()) return middleware_class return decorator def extend_api ( route = \"\" , api = None , base_url = \"\" , ** kwargs ) : \"\"\" Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access \"\"\" def decorator ( extend_with ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( extend_with ) for extended_api in extend_with () : apply_to_api . extend ( extended_api , route , base_url , ** kwargs ) return extend_with return decorator def wraps ( function ) : \"\"\" Enables building decorators around functions used for hug routes without changing their function signature \"\"\" def wrap ( decorator ) : decorator = functools . wraps ( function )( decorator ) if not hasattr ( function , \" original \" ) : decorator . original = function else : decorator . original = function . original delattr ( function , \" original \" ) return decorator return wrap def auto_kwargs ( function ) : \"\"\" Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts \"\"\" supported = introspect . arguments ( function ) @ wraps ( function ) def call_function ( * args , ** kwargs ) : return function ( * args , ** { key : value for key , value in kwargs . items () if key in supported } ) return call_function Variables HTTP_METHODS Functions auto_kwargs def ( function ) Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts View Source def auto_kwargs ( function ) : \"\"\" Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts \"\"\" supported = introspect . arguments ( function ) @ wraps ( function ) def call_function ( * args , ** kwargs ) : return function ( * args , ** { key : value for key , value in kwargs . items () if key in supported } ) return call_function context_factory def ( apply_globally = False , api = None ) A decorator that registers a single hug context factory View Source def context_factory ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug context factory \"\"\" def decorator ( context_factory_ ) : if apply_globally : hug . defaults . context_factory = context_factory_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( context_factory_ ) apply_to_api . context_factory = context_factory_ return context_factory_ return decorator default_input_format def ( content_type = 'application/json' , apply_globally = False , api = None ) A decorator that allows you to override the default output format for an API View Source def default_input_format ( content_type = \" application/json \" , apply_globally = False , api = None ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : hug . defaults . input_format [ content_type ] = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) apply_to_api . http . set_input_format ( content_type , formatter ) return formatter return decorator default_output_format def ( content_type = 'application/json' , apply_globally = False , api = None , cli = False , http = True ) A decorator that allows you to override the default output format for an API View Source def default_output_format ( content_type = \" application/json \" , apply_globally = False , api = None , cli = False , http = True ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : if http : hug . defaults . output_format = formatter if cli : hug . defaults . cli_output_format = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) if http : apply_to_api . http . output_format = formatter if cli : apply_to_api . cli . output_format = formatter return formatter return decorator delete_context def ( apply_globally = False , api = None ) A decorator that registers a single hug delete context function View Source def delete_context ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug delete context function \"\"\" def decorator ( delete_context_ ) : if apply_globally : hug . defaults . delete_context = delete_context_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( delete_context_ ) apply_to_api . delete_context = delete_context_ return delete_context_ return decorator directive def ( apply_globally = False , api = None ) A decorator that registers a single hug directive View Source def directive ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug directive \"\"\" def decorator ( directive_method ) : if apply_globally : hug . defaults . directives [ underscore ( directive_method . __name__ ) ] = directive_method else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( directive_method ) apply_to_api . add_directive ( directive_method ) directive_method . directive = True return directive_method return decorator extend_api def ( route = '' , api = None , base_url = '' , ** kwargs ) Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access View Source def extend_api ( route = \"\" , api = None , base_url = \"\" , ** kwargs ) : \"\"\" Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access \"\"\" def decorator ( extend_with ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( extend_with ) for extended_api in extend_with () : apply_to_api . extend ( extended_api , route , base_url , ** kwargs ) return extend_with return decorator middleware_class def ( api = None ) Registers a middleware class View Source def middleware_class ( api = None ) : \"\"\" Registers a middleware class \"\"\" def decorator ( middleware_class ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_class ) apply_to_api . http . add_middleware ( middleware_class ()) return middleware_class return decorator reqresp_middleware def ( api = None ) Registers a middleware function that will be called on every request and response View Source def reqresp_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request and response \"\"\" def decorator ( middleware_generator ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_generator ) class MiddlewareRouter ( object ) : __slots__ = ( \" gen \" , ) def process_request ( self , request , response ) : self . gen = middleware_generator ( request ) return self . gen . __next__ () def process_response ( self , request , response , resource , _req_succeeded ) : return self . gen . send (( response , resource )) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_generator return decorator request_middleware def ( api = None ) Registers a middleware function that will be called on every request View Source def request_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_request ( self , request , response ) : return middleware_method ( request , response ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator response_middleware def ( api = None ) Registers a middleware function that will be called on every response View Source def response_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every response \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_response ( self , request , response , resource , _req_succeeded ) : return middleware_method ( request , response , resource ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator startup def ( api = None ) Runs the provided function on startup, passing in an instance of the api View Source def startup ( api = None ) : \"\"\" Runs the provided function on startup, passing in an instance of the api \"\"\" def startup_wrapper ( startup_function ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( startup_function ) apply_to_api . add_startup_handler ( startup_function ) return startup_function return startup_wrapper wraps def ( function ) Enables building decorators around functions used for hug routes without changing their function signature View Source def wraps ( function ) : \"\"\" Enables building decorators around functions used for hug routes without changing their function signature \"\"\" def wrap ( decorator ) : decorator = functools . wraps ( function )( decorator ) if not hasattr ( function , \" original \" ) : decorator . original = function else : decorator . original = function . original delattr ( function , \" original \" ) return decorator return wrap","title":"Decorators"},{"location":"reference/hug/decorators/#module-hugdecorators","text":"hug/decorators.py Defines the method decorators at the core of Hug's approach to creating HTTP APIs Decorators for exposing python method as HTTP methods (get, post, etc) Decorators for setting the default output and input formats used throughout an API using the framework Decorator for registering a new directive method Decorator for including another API modules handlers into the current one, with opitonal prefix route Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/decorators.py Defines the method decorators at the core of Hug ' s approach to creating HTTP APIs - Decorators for exposing python method as HTTP methods ( get , post , etc ) - Decorators for setting the default output and input formats used throughout an API using the framework - Decorator for registering a new directive method - Decorator for including another API modules handlers into the current one , with opitonal prefix route Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import functools from collections import namedtuple from falcon import HTTP_METHODS import hug . api import hug . defaults import hug . output_format from hug import introspect from hug . format import underscore def default_output_format ( content_type = \" application/json \" , apply_globally = False , api = None , cli = False , http = True ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : if http : hug . defaults . output_format = formatter if cli : hug . defaults . cli_output_format = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) if http : apply_to_api . http . output_format = formatter if cli : apply_to_api . cli . output_format = formatter return formatter return decorator def default_input_format ( content_type = \" application/json \" , apply_globally = False , api = None ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : hug . defaults . input_format [ content_type ] = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) apply_to_api . http . set_input_format ( content_type , formatter ) return formatter return decorator def directive ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug directive \"\"\" def decorator ( directive_method ) : if apply_globally : hug . defaults . directives [ underscore ( directive_method . __name__ ) ] = directive_method else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( directive_method ) apply_to_api . add_directive ( directive_method ) directive_method . directive = True return directive_method return decorator def context_factory ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug context factory \"\"\" def decorator ( context_factory_ ) : if apply_globally : hug . defaults . context_factory = context_factory_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( context_factory_ ) apply_to_api . context_factory = context_factory_ return context_factory_ return decorator def delete_context ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug delete context function \"\"\" def decorator ( delete_context_ ) : if apply_globally : hug . defaults . delete_context = delete_context_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( delete_context_ ) apply_to_api . delete_context = delete_context_ return delete_context_ return decorator def startup ( api = None ) : \"\"\" Runs the provided function on startup, passing in an instance of the api \"\"\" def startup_wrapper ( startup_function ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( startup_function ) apply_to_api . add_startup_handler ( startup_function ) return startup_function return startup_wrapper def request_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_request ( self , request , response ) : return middleware_method ( request , response ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator def response_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every response \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_response ( self , request , response , resource , _req_succeeded ) : return middleware_method ( request , response , resource ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator def reqresp_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request and response \"\"\" def decorator ( middleware_generator ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_generator ) class MiddlewareRouter ( object ) : __slots__ = ( \" gen \" , ) def process_request ( self , request , response ) : self . gen = middleware_generator ( request ) return self . gen . __next__ () def process_response ( self , request , response , resource , _req_succeeded ) : return self . gen . send (( response , resource )) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_generator return decorator def middleware_class ( api = None ) : \"\"\" Registers a middleware class \"\"\" def decorator ( middleware_class ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_class ) apply_to_api . http . add_middleware ( middleware_class ()) return middleware_class return decorator def extend_api ( route = \"\" , api = None , base_url = \"\" , ** kwargs ) : \"\"\" Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access \"\"\" def decorator ( extend_with ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( extend_with ) for extended_api in extend_with () : apply_to_api . extend ( extended_api , route , base_url , ** kwargs ) return extend_with return decorator def wraps ( function ) : \"\"\" Enables building decorators around functions used for hug routes without changing their function signature \"\"\" def wrap ( decorator ) : decorator = functools . wraps ( function )( decorator ) if not hasattr ( function , \" original \" ) : decorator . original = function else : decorator . original = function . original delattr ( function , \" original \" ) return decorator return wrap def auto_kwargs ( function ) : \"\"\" Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts \"\"\" supported = introspect . arguments ( function ) @ wraps ( function ) def call_function ( * args , ** kwargs ) : return function ( * args , ** { key : value for key , value in kwargs . items () if key in supported } ) return call_function","title":"Module hug.decorators"},{"location":"reference/hug/decorators/#variables","text":"HTTP_METHODS","title":"Variables"},{"location":"reference/hug/decorators/#functions","text":"","title":"Functions"},{"location":"reference/hug/decorators/#auto_kwargs","text":"def ( function ) Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts View Source def auto_kwargs ( function ) : \"\"\" Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts \"\"\" supported = introspect . arguments ( function ) @ wraps ( function ) def call_function ( * args , ** kwargs ) : return function ( * args , ** { key : value for key , value in kwargs . items () if key in supported } ) return call_function","title":"auto_kwargs"},{"location":"reference/hug/decorators/#context_factory","text":"def ( apply_globally = False , api = None ) A decorator that registers a single hug context factory View Source def context_factory ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug context factory \"\"\" def decorator ( context_factory_ ) : if apply_globally : hug . defaults . context_factory = context_factory_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( context_factory_ ) apply_to_api . context_factory = context_factory_ return context_factory_ return decorator","title":"context_factory"},{"location":"reference/hug/decorators/#default_input_format","text":"def ( content_type = 'application/json' , apply_globally = False , api = None ) A decorator that allows you to override the default output format for an API View Source def default_input_format ( content_type = \" application/json \" , apply_globally = False , api = None ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : hug . defaults . input_format [ content_type ] = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) apply_to_api . http . set_input_format ( content_type , formatter ) return formatter return decorator","title":"default_input_format"},{"location":"reference/hug/decorators/#default_output_format","text":"def ( content_type = 'application/json' , apply_globally = False , api = None , cli = False , http = True ) A decorator that allows you to override the default output format for an API View Source def default_output_format ( content_type = \" application/json \" , apply_globally = False , api = None , cli = False , http = True ) : \"\"\" A decorator that allows you to override the default output format for an API \"\"\" def decorator ( formatter ) : formatter = hug . output_format . content_type ( content_type )( formatter ) if apply_globally : if http : hug . defaults . output_format = formatter if cli : hug . defaults . cli_output_format = formatter else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( formatter ) if http : apply_to_api . http . output_format = formatter if cli : apply_to_api . cli . output_format = formatter return formatter return decorator","title":"default_output_format"},{"location":"reference/hug/decorators/#delete_context","text":"def ( apply_globally = False , api = None ) A decorator that registers a single hug delete context function View Source def delete_context ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug delete context function \"\"\" def decorator ( delete_context_ ) : if apply_globally : hug . defaults . delete_context = delete_context_ else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( delete_context_ ) apply_to_api . delete_context = delete_context_ return delete_context_ return decorator","title":"delete_context"},{"location":"reference/hug/decorators/#directive","text":"def ( apply_globally = False , api = None ) A decorator that registers a single hug directive View Source def directive ( apply_globally = False , api = None ) : \"\"\" A decorator that registers a single hug directive \"\"\" def decorator ( directive_method ) : if apply_globally : hug . defaults . directives [ underscore ( directive_method . __name__ ) ] = directive_method else : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( directive_method ) apply_to_api . add_directive ( directive_method ) directive_method . directive = True return directive_method return decorator","title":"directive"},{"location":"reference/hug/decorators/#extend_api","text":"def ( route = '' , api = None , base_url = '' , ** kwargs ) Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access View Source def extend_api ( route = \"\" , api = None , base_url = \"\" , ** kwargs ) : \"\"\" Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access \"\"\" def decorator ( extend_with ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( extend_with ) for extended_api in extend_with () : apply_to_api . extend ( extended_api , route , base_url , ** kwargs ) return extend_with return decorator","title":"extend_api"},{"location":"reference/hug/decorators/#middleware_class","text":"def ( api = None ) Registers a middleware class View Source def middleware_class ( api = None ) : \"\"\" Registers a middleware class \"\"\" def decorator ( middleware_class ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_class ) apply_to_api . http . add_middleware ( middleware_class ()) return middleware_class return decorator","title":"middleware_class"},{"location":"reference/hug/decorators/#reqresp_middleware","text":"def ( api = None ) Registers a middleware function that will be called on every request and response View Source def reqresp_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request and response \"\"\" def decorator ( middleware_generator ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_generator ) class MiddlewareRouter ( object ) : __slots__ = ( \" gen \" , ) def process_request ( self , request , response ) : self . gen = middleware_generator ( request ) return self . gen . __next__ () def process_response ( self , request , response , resource , _req_succeeded ) : return self . gen . send (( response , resource )) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_generator return decorator","title":"reqresp_middleware"},{"location":"reference/hug/decorators/#request_middleware","text":"def ( api = None ) Registers a middleware function that will be called on every request View Source def request_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every request \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_request ( self , request , response ) : return middleware_method ( request , response ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator","title":"request_middleware"},{"location":"reference/hug/decorators/#response_middleware","text":"def ( api = None ) Registers a middleware function that will be called on every response View Source def response_middleware ( api = None ) : \"\"\" Registers a middleware function that will be called on every response \"\"\" def decorator ( middleware_method ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( middleware_method ) class MiddlewareRouter ( object ) : __slots__ = () def process_response ( self , request , response , resource , _req_succeeded ) : return middleware_method ( request , response , resource ) apply_to_api . http . add_middleware ( MiddlewareRouter ()) return middleware_method return decorator","title":"response_middleware"},{"location":"reference/hug/decorators/#startup","text":"def ( api = None ) Runs the provided function on startup, passing in an instance of the api View Source def startup ( api = None ) : \"\"\" Runs the provided function on startup, passing in an instance of the api \"\"\" def startup_wrapper ( startup_function ) : apply_to_api = hug . API ( api ) if api else hug . api . from_object ( startup_function ) apply_to_api . add_startup_handler ( startup_function ) return startup_function return startup_wrapper","title":"startup"},{"location":"reference/hug/decorators/#wraps","text":"def ( function ) Enables building decorators around functions used for hug routes without changing their function signature View Source def wraps ( function ) : \"\"\" Enables building decorators around functions used for hug routes without changing their function signature \"\"\" def wrap ( decorator ) : decorator = functools . wraps ( function )( decorator ) if not hasattr ( function , \" original \" ) : decorator . original = function else : decorator . original = function . original delattr ( function , \" original \" ) return decorator return wrap","title":"wraps"},{"location":"reference/hug/defaults/","text":"Module hug.defaults hug/defaults.py Defines and stores Hug's default handlers Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/defaults.py Defines and stores Hug ' s default handlers Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import hug output_format = hug . output_format . json cli_output_format = hug . output_format . text input_format = { \" application/json \" : hug . input_format . json , \" application/x-www-form-urlencoded \" : hug . input_format . urlencoded , \" multipart/form-data \" : hug . input_format . multipart , \" text/plain \" : hug . input_format . text , \" text/css \" : hug . input_format . text , \" text/html \" : hug . input_format . text , } directives = { \" timer \" : hug . directives . Timer , \" api \" : hug . directives . api , \" module \" : hug . directives . module , \" current_api \" : hug . directives . CurrentAPI , \" api_version \" : hug . directives . api_version , \" user \" : hug . directives . user , \" session \" : hug . directives . session , \" documentation \" : hug . directives . documentation , } def context_factory ( * args , ** kwargs ) : return dict () def delete_context ( context , exception = None , errors = None , lacks_requirement = None ) : del context Variables directives input_format Functions cli_output_format def ( content , ** kwargs ) Free form UTF-8 text View Source @ content_type ( \" text/plain; charset=utf-8 \" ) def text ( content , ** kwargs ) : \"\"\" Free form UTF-8 text \"\"\" if hasattr ( content , \" read \" ) : return content return str ( content ) . encode ( \" utf8 \" ) context_factory def ( * args , ** kwargs ) View Source def context_factory ( * args , ** kwargs ) : return dict () delete_context def ( context , exception = None , errors = None , lacks_requirement = None ) View Source def delete_context ( context , exception = None , errors = None , lacks_requirement = None ): del context output_format def ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) JSON (Javascript Serialized Object Notation) View Source @ content_type ( \" application/json; charset=utf-8 \" ) def json ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) \"\"\" if hasattr ( content , \" read \" ) : return content if isinstance ( content , tuple ) and getattr ( content , \" _fields \" , None ) : content = { field : getattr ( content , field ) for field in content . _fields } return json_converter . dumps ( content , default = _json_converter , ensure_ascii = ensure_ascii , ** kwargs ) . encode ( \" utf8 \" )","title":"Defaults"},{"location":"reference/hug/defaults/#module-hugdefaults","text":"hug/defaults.py Defines and stores Hug's default handlers Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/defaults.py Defines and stores Hug ' s default handlers Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import hug output_format = hug . output_format . json cli_output_format = hug . output_format . text input_format = { \" application/json \" : hug . input_format . json , \" application/x-www-form-urlencoded \" : hug . input_format . urlencoded , \" multipart/form-data \" : hug . input_format . multipart , \" text/plain \" : hug . input_format . text , \" text/css \" : hug . input_format . text , \" text/html \" : hug . input_format . text , } directives = { \" timer \" : hug . directives . Timer , \" api \" : hug . directives . api , \" module \" : hug . directives . module , \" current_api \" : hug . directives . CurrentAPI , \" api_version \" : hug . directives . api_version , \" user \" : hug . directives . user , \" session \" : hug . directives . session , \" documentation \" : hug . directives . documentation , } def context_factory ( * args , ** kwargs ) : return dict () def delete_context ( context , exception = None , errors = None , lacks_requirement = None ) : del context","title":"Module hug.defaults"},{"location":"reference/hug/defaults/#variables","text":"directives input_format","title":"Variables"},{"location":"reference/hug/defaults/#functions","text":"","title":"Functions"},{"location":"reference/hug/defaults/#cli_output_format","text":"def ( content , ** kwargs ) Free form UTF-8 text View Source @ content_type ( \" text/plain; charset=utf-8 \" ) def text ( content , ** kwargs ) : \"\"\" Free form UTF-8 text \"\"\" if hasattr ( content , \" read \" ) : return content return str ( content ) . encode ( \" utf8 \" )","title":"cli_output_format"},{"location":"reference/hug/defaults/#context_factory","text":"def ( * args , ** kwargs ) View Source def context_factory ( * args , ** kwargs ) : return dict ()","title":"context_factory"},{"location":"reference/hug/defaults/#delete_context","text":"def ( context , exception = None , errors = None , lacks_requirement = None ) View Source def delete_context ( context , exception = None , errors = None , lacks_requirement = None ): del context","title":"delete_context"},{"location":"reference/hug/defaults/#output_format","text":"def ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) JSON (Javascript Serialized Object Notation) View Source @ content_type ( \" application/json; charset=utf-8 \" ) def json ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) \"\"\" if hasattr ( content , \" read \" ) : return content if isinstance ( content , tuple ) and getattr ( content , \" _fields \" , None ) : content = { field : getattr ( content , field ) for field in content . _fields } return json_converter . dumps ( content , default = _json_converter , ensure_ascii = ensure_ascii , ** kwargs ) . encode ( \" utf8 \" )","title":"output_format"},{"location":"reference/hug/development_runner/","text":"Module hug.development_runner hug/development_runner.py Contains logic to enable execution of hug APIS locally from the command line for development use Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\"hug/development_runner.py Contains logic to enable execution of hug APIS locally from the command line for development use Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software \"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from __ future__ import absolute_import import importlib import os import subprocess import sys import tempfile import time from multiprocessing import Process from os . path import exists import _ thread as thread from hug . _ version import current from hug . api import API from hug . route import cli from hug . types import boolean , number INIT_MODULES = list ( sys . modules . keys ()) def _ start_api ( api_module , host , port , no_404_documentation , show_intro = True ) : API ( api_module ). http . serve ( host , port , no_404_documentation , show_intro ) @ cli ( version = current ) def hug ( file : \"A Python file that contains a Hug API\" = None , module : \"A Python module that contains a Hug API\" = None , host : \"Interface to bind to\" = \"\" , port : number = 8000 , no_404_documentation: boolean = False , manual_reload: boolean = False , interval : number = 1 , command : \"Run a command defined in the given module\" = None , silent : boolean = False , ) : \"\"\"Hug API Development Server\"\"\" api_module = None if file and module : print ( \"Error: can not define both a file and module source for Hug API.\" ) sys . exit ( 1 ) if file : sys . path . append ( os . path . dirname ( os . path . abspath ( file ))) sys . path . append ( os . getcwd ()) api_module = importlib . machinery . SourceFileLoader ( file . split ( \".\" )[ 0 ], file ). load_module () elif module : sys . path . append ( os . getcwd ()) api_module = importlib . import_module ( module ) if not api_module or not hasattr ( api_module , \"__hug__\" ) : print ( \"Error: must define a file name or module that contains a Hug API.\" ) sys . exit ( 1 ) api = API ( api_module , display_intro =not silent ) if command : if command not in api . cli . commands : print ( str ( api . cli )) sys . exit ( 1 ) flag_index = ( sys . argv . index ( \"-c\" ) if \"-c\" in sys . argv else sys . argv . index ( \"--command\" )) + 1 sys . argv = sys . argv [ flag_index: ] api . cli . commands [ command ]() return ran = False if not manual_reload: thread . start_new_thread ( reload_checker , ( interval ,)) while True : reload_checker . reloading = False time . sleep ( 1 ) try : _ start_api ( api_module , host , port , no_404_documentation , False if silent else not ran ) except KeyboardInterrupt : if not reload_checker . reloading : sys . exit ( 1 ) reload_checker . reloading = False ran = True for name in list ( sys . modules . keys ()) : if name not in INIT_MODULES : del sys . modules [ name ] if file : api_module = importlib . machinery . SourceFileLoader ( file . split ( \".\" )[ 0 ], file ). load_module () elif module : api_module = importlib . import_module ( module ) else : _ start_api ( api_module , host , port , no_404_documentation , not ran ) def reload_checker ( interval ) : while True : changed = False files = {} for module in list ( sys . modules . values ()) : path = getattr ( module , \"__file__\" , \"\" ) if not path : continue if path [ - 4 : ] in ( \".pyo\" , \".pyc\" ) : path = path [:- 1 ] if path and exists ( path ) : files [ path ] = os . stat ( path ). st_mtime while not changed : for path , last_modified in files . items () : if not exists ( path ) : print ( \"\\n> Reloading due to file removal: {}\" . format ( path )) changed = True elif os . stat ( path ). st_mtime > last_modified: print ( \"\\n> Reloading due to file change: {}\" . format ( path )) changed = True if changed : reload_checker . reloading = True thread . interrupt_main () time . sleep ( 5 ) break time . sleep ( interval ) Variables INIT_MODULES current Functions hug def ( file : 'A Python file that contains a Hug API' = None , module : 'A Python module that contains a Hug API' = None , host : 'Interface to bind to' = '' , port : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > = 8000 , no_404_documentation : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb908 > = False , manual_reload : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb908 > = False , interval : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > = 1 , command : 'Run a command defined in the given module' = None , silent : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb908 > = False ) Hug API Development Server View Source @ cli ( version = current ) def hug ( file : \" A Python file that contains a Hug API \" = None , module : \" A Python module that contains a Hug API \" = None , host : \" Interface to bind to \" = \"\" , port : number = 8000 , no_404_documentation : boolean = False , manual_reload : boolean = False , interval : number = 1 , command : \" Run a command defined in the given module \" = None , silent : boolean = False , ) : \"\"\" Hug API Development Server \"\"\" api_module = None if file and module : print ( \" Error: can not define both a file and module source for Hug API. \" ) sys . exit ( 1 ) if file : sys . path . append ( os . path . dirname ( os . path . abspath ( file ))) sys . path . append ( os . getcwd ()) api_module = importlib . machinery . SourceFileLoader ( file . split ( \" . \" ) [ 0 ], file ) . load_module () elif module : sys . path . append ( os . getcwd ()) api_module = importlib . import_module ( module ) if not api_module or not hasattr ( api_module , \" __hug__ \" ) : print ( \" Error: must define a file name or module that contains a Hug API. \" ) sys . exit ( 1 ) api = API ( api_module , display_intro = not silent ) if command : if command not in api . cli . commands : print ( str ( api . cli )) sys . exit ( 1 ) flag_index = ( sys . argv . index ( \" -c \" ) if \" -c \" in sys . argv else sys . argv . index ( \" --command \" )) + 1 sys . argv = sys . argv [ flag_index :] api . cli . commands [ command ] () return ran = False if not manual_reload : thread . start_new_thread ( reload_checker , ( interval , )) while True : reload_checker . reloading = False time . sleep ( 1 ) try : _start_api ( api_module , host , port , no_404_documentation , False if silent else not ran ) except KeyboardInterrupt : if not reload_checker . reloading : sys . exit ( 1 ) reload_checker . reloading = False ran = True for name in list ( sys . modules . keys ()) : if name not in INIT_MODULES : del sys . modules [ name ] if file : api_module = importlib . machinery . SourceFileLoader ( file . split ( \" . \" ) [ 0 ], file ) . load_module () elif module : api_module = importlib . import_module ( module ) else : _start_api ( api_module , host , port , no_404_documentation , not ran ) reload_checker def ( interval ) View Source def reload_checker ( interval ) : while True : changed = False files = {} for module in list ( sys . modules . values ()) : path = getattr ( module , \"__file__\" , \"\" ) if not path : continue if path [ - 4 : ] in ( \".pyo\" , \".pyc\" ) : path = path [:- 1 ] if path and exists ( path ) : files [ path ] = os . stat ( path ). st_mtime while not changed : for path , last_modified in files . items () : if not exists ( path ) : print ( \"\\n> Reloading due to file removal: {}\" . format ( path )) changed = True elif os . stat ( path ). st_mtime > last_modified: print ( \"\\n> Reloading due to file change: {}\" . format ( path )) changed = True if changed : reload_checker . reloading = True thread . interrupt_main () time . sleep ( 5 ) break time . sleep ( interval )","title":"Development Runner"},{"location":"reference/hug/development_runner/#module-hugdevelopment_runner","text":"hug/development_runner.py Contains logic to enable execution of hug APIS locally from the command line for development use Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\"hug/development_runner.py Contains logic to enable execution of hug APIS locally from the command line for development use Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software \"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from __ future__ import absolute_import import importlib import os import subprocess import sys import tempfile import time from multiprocessing import Process from os . path import exists import _ thread as thread from hug . _ version import current from hug . api import API from hug . route import cli from hug . types import boolean , number INIT_MODULES = list ( sys . modules . keys ()) def _ start_api ( api_module , host , port , no_404_documentation , show_intro = True ) : API ( api_module ). http . serve ( host , port , no_404_documentation , show_intro ) @ cli ( version = current ) def hug ( file : \"A Python file that contains a Hug API\" = None , module : \"A Python module that contains a Hug API\" = None , host : \"Interface to bind to\" = \"\" , port : number = 8000 , no_404_documentation: boolean = False , manual_reload: boolean = False , interval : number = 1 , command : \"Run a command defined in the given module\" = None , silent : boolean = False , ) : \"\"\"Hug API Development Server\"\"\" api_module = None if file and module : print ( \"Error: can not define both a file and module source for Hug API.\" ) sys . exit ( 1 ) if file : sys . path . append ( os . path . dirname ( os . path . abspath ( file ))) sys . path . append ( os . getcwd ()) api_module = importlib . machinery . SourceFileLoader ( file . split ( \".\" )[ 0 ], file ). load_module () elif module : sys . path . append ( os . getcwd ()) api_module = importlib . import_module ( module ) if not api_module or not hasattr ( api_module , \"__hug__\" ) : print ( \"Error: must define a file name or module that contains a Hug API.\" ) sys . exit ( 1 ) api = API ( api_module , display_intro =not silent ) if command : if command not in api . cli . commands : print ( str ( api . cli )) sys . exit ( 1 ) flag_index = ( sys . argv . index ( \"-c\" ) if \"-c\" in sys . argv else sys . argv . index ( \"--command\" )) + 1 sys . argv = sys . argv [ flag_index: ] api . cli . commands [ command ]() return ran = False if not manual_reload: thread . start_new_thread ( reload_checker , ( interval ,)) while True : reload_checker . reloading = False time . sleep ( 1 ) try : _ start_api ( api_module , host , port , no_404_documentation , False if silent else not ran ) except KeyboardInterrupt : if not reload_checker . reloading : sys . exit ( 1 ) reload_checker . reloading = False ran = True for name in list ( sys . modules . keys ()) : if name not in INIT_MODULES : del sys . modules [ name ] if file : api_module = importlib . machinery . SourceFileLoader ( file . split ( \".\" )[ 0 ], file ). load_module () elif module : api_module = importlib . import_module ( module ) else : _ start_api ( api_module , host , port , no_404_documentation , not ran ) def reload_checker ( interval ) : while True : changed = False files = {} for module in list ( sys . modules . values ()) : path = getattr ( module , \"__file__\" , \"\" ) if not path : continue if path [ - 4 : ] in ( \".pyo\" , \".pyc\" ) : path = path [:- 1 ] if path and exists ( path ) : files [ path ] = os . stat ( path ). st_mtime while not changed : for path , last_modified in files . items () : if not exists ( path ) : print ( \"\\n> Reloading due to file removal: {}\" . format ( path )) changed = True elif os . stat ( path ). st_mtime > last_modified: print ( \"\\n> Reloading due to file change: {}\" . format ( path )) changed = True if changed : reload_checker . reloading = True thread . interrupt_main () time . sleep ( 5 ) break time . sleep ( interval )","title":"Module hug.development_runner"},{"location":"reference/hug/development_runner/#variables","text":"INIT_MODULES current","title":"Variables"},{"location":"reference/hug/development_runner/#functions","text":"","title":"Functions"},{"location":"reference/hug/development_runner/#hug","text":"def ( file : 'A Python file that contains a Hug API' = None , module : 'A Python module that contains a Hug API' = None , host : 'Interface to bind to' = '' , port : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > = 8000 , no_404_documentation : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb908 > = False , manual_reload : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb908 > = False , interval : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > = 1 , command : 'Run a command defined in the given module' = None , silent : < hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb908 > = False ) Hug API Development Server View Source @ cli ( version = current ) def hug ( file : \" A Python file that contains a Hug API \" = None , module : \" A Python module that contains a Hug API \" = None , host : \" Interface to bind to \" = \"\" , port : number = 8000 , no_404_documentation : boolean = False , manual_reload : boolean = False , interval : number = 1 , command : \" Run a command defined in the given module \" = None , silent : boolean = False , ) : \"\"\" Hug API Development Server \"\"\" api_module = None if file and module : print ( \" Error: can not define both a file and module source for Hug API. \" ) sys . exit ( 1 ) if file : sys . path . append ( os . path . dirname ( os . path . abspath ( file ))) sys . path . append ( os . getcwd ()) api_module = importlib . machinery . SourceFileLoader ( file . split ( \" . \" ) [ 0 ], file ) . load_module () elif module : sys . path . append ( os . getcwd ()) api_module = importlib . import_module ( module ) if not api_module or not hasattr ( api_module , \" __hug__ \" ) : print ( \" Error: must define a file name or module that contains a Hug API. \" ) sys . exit ( 1 ) api = API ( api_module , display_intro = not silent ) if command : if command not in api . cli . commands : print ( str ( api . cli )) sys . exit ( 1 ) flag_index = ( sys . argv . index ( \" -c \" ) if \" -c \" in sys . argv else sys . argv . index ( \" --command \" )) + 1 sys . argv = sys . argv [ flag_index :] api . cli . commands [ command ] () return ran = False if not manual_reload : thread . start_new_thread ( reload_checker , ( interval , )) while True : reload_checker . reloading = False time . sleep ( 1 ) try : _start_api ( api_module , host , port , no_404_documentation , False if silent else not ran ) except KeyboardInterrupt : if not reload_checker . reloading : sys . exit ( 1 ) reload_checker . reloading = False ran = True for name in list ( sys . modules . keys ()) : if name not in INIT_MODULES : del sys . modules [ name ] if file : api_module = importlib . machinery . SourceFileLoader ( file . split ( \" . \" ) [ 0 ], file ) . load_module () elif module : api_module = importlib . import_module ( module ) else : _start_api ( api_module , host , port , no_404_documentation , not ran )","title":"hug"},{"location":"reference/hug/development_runner/#reload_checker","text":"def ( interval ) View Source def reload_checker ( interval ) : while True : changed = False files = {} for module in list ( sys . modules . values ()) : path = getattr ( module , \"__file__\" , \"\" ) if not path : continue if path [ - 4 : ] in ( \".pyo\" , \".pyc\" ) : path = path [:- 1 ] if path and exists ( path ) : files [ path ] = os . stat ( path ). st_mtime while not changed : for path , last_modified in files . items () : if not exists ( path ) : print ( \"\\n> Reloading due to file removal: {}\" . format ( path )) changed = True elif os . stat ( path ). st_mtime > last_modified: print ( \"\\n> Reloading due to file change: {}\" . format ( path )) changed = True if changed : reload_checker . reloading = True thread . interrupt_main () time . sleep ( 5 ) break time . sleep ( interval )","title":"reload_checker"},{"location":"reference/hug/directives/","text":"Module hug.directives hug/directives.py Defines the directives built into hug. Directives allow attaching behaviour to an API handler based simply on an argument it takes and that arguments default value. The directive gets called with the default supplied, ther request data, and api_version. The result of running the directive method is then set as the argument value. Directive attributes are always prefixed with 'hug_' Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/directives.py Defines the directives built into hug . Directives allow attaching behaviour to an API handler based simply on an argument it takes and that arguments default value . The directive gets called with the default supplied , ther request data , and api_version . The result of running the directive method is then set as the argument value . Directive attributes are always prefixed with ' hug_ ' Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from functools import partial from timeit import default_timer as python_timer from hug import introspect def _built_in_directive ( directive ) : \"\"\" Marks a callable as a built-in directive \"\"\" directive . directive = True return directive @ _built_in_directive class Timer ( object ) : \"\"\" Keeps track of time surpased since instantiation, outputed by doing float(instance) \"\"\" __slots__ = ( \" start \" , \" round_to \" ) def __init__ ( self , round_to = None , ** kwargs ) : self . start = python_timer () self . round_to = round_to def __float__ ( self ) : time_taken = python_timer () - self . start return round ( time_taken , self . round_to ) if self . round_to else time_taken def __int__ ( self ) : return int ( round ( float ( self ))) def __native_types__ ( self ) : return self . __float__ () def __str__ ( self ) : return str ( float ( self )) def __repr__ ( self ) : return \" {}({}) \" . format ( self . __class__ . __name__ , self ) @ _built_in_directive def module ( default = None , api = None , ** kwargs ) : \"\"\" Returns the module that is running this hug API function \"\"\" return api . module if api else default @ _built_in_directive def api ( default = None , api = None , ** kwargs ) : \"\"\" Returns the api instance in which this API function is being ran \"\"\" return api if api else default @ _built_in_directive def api_version ( default = None , api_version = None , ** kwargs ) : \"\"\" Returns the current api_version as a directive for use in both request and not request handling code \"\"\" return api_version @ _built_in_directive def documentation ( default = None , api_version = None , api = None , ** kwargs ) : \"\"\" returns documentation for the current api \"\"\" api_version = default or api_version if api : return api . http . documentation ( base_url = \"\" , api_version = api_version ) @ _built_in_directive def session ( context_name = \" session \" , request = None , ** kwargs ) : \"\"\" Returns the session associated with the current request \"\"\" return request and request . context . get ( context_name , None ) @ _built_in_directive def user ( default = None , request = None , ** kwargs ) : \"\"\" Returns the current logged in user \"\"\" return request and request . context . get ( \" user \" , None ) or default @ _built_in_directive def cors ( support = \" * \" , response = None , ** kwargs ) : \"\"\" Adds the the Access-Control-Allow-Origin header to this endpoint, with the specified support \"\"\" response and response . set_header ( \" Access-Control-Allow-Origin \" , support ) return support @ _built_in_directive class CurrentAPI ( object ) : \"\"\" Returns quick access to all api functions on the current version of the api \"\"\" __slots__ = ( \" api_version \" , \" api \" ) def __init__ ( self , default = None , api_version = None , ** kwargs ) : self . api_version = api_version self . api = api ( ** kwargs ) def __getattr__ ( self , name ) : function = self . api . http . versioned . get ( self . api_version , {} ) . get ( name , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( name , None ) if not function : raise AttributeError ( \" API Function {0} not found \" . format ( name )) accepts = function . interface . arguments if \" hug_api_version \" in accepts : function = partial ( function , hug_api_version = self . api_version ) if \" hug_current_api \" in accepts : function = partial ( function , hug_current_api = self ) return function Functions api def ( default = None , api = None , ** kwargs ) Returns the api instance in which this API function is being ran View Source @ _built_in_directive def api ( default = None , api = None , ** kwargs ) : \"\"\" Returns the api instance in which this API function is being ran \"\"\" return api if api else default api_version def ( default = None , api_version = None , ** kwargs ) Returns the current api_version as a directive for use in both request and not request handling code View Source @ _built_in_directive def api_version ( default = None , api_version = None , ** kwargs ) : \"\"\" Returns the current api_version as a directive for use in both request and not request handling code \"\"\" return api_version cors def ( support = '*' , response = None , ** kwargs ) Adds the the Access-Control-Allow-Origin header to this endpoint, with the specified support View Source @ _built_in_directive def cors ( support = \" * \" , response = None , ** kwargs ) : \"\"\" Adds the the Access-Control-Allow-Origin header to this endpoint, with the specified support \"\"\" response and response . set_header ( \" Access-Control-Allow-Origin \" , support ) return support documentation def ( default = None , api_version = None , api = None , ** kwargs ) returns documentation for the current api View Source @ _built_in_directive def documentation ( default = None , api_version = None , api = None , ** kwargs ) : \"\"\" returns documentation for the current api \"\"\" api_version = default or api_version if api : return api . http . documentation ( base_url = \"\" , api_version = api_version ) module def ( default = None , api = None , ** kwargs ) Returns the module that is running this hug API function View Source @ _built_in_directive def module ( default = None , api = None , ** kwargs ) : \"\"\" Returns the module that is running this hug API function \"\"\" return api . module if api else default session def ( context_name = 'session' , request = None , ** kwargs ) Returns the session associated with the current request View Source @ _built_in_directive def session ( context_name = \" session \" , request = None , ** kwargs ) : \"\"\" Returns the session associated with the current request \"\"\" return request and request . context . get ( context_name , None ) user def ( default = None , request = None , ** kwargs ) Returns the current logged in user View Source @ _built_in_directive def user ( default = None , request = None , ** kwargs ) : \"\"\" Returns the current logged in user \"\"\" return request and request . context . get ( \" user \" , None ) or default Classes CurrentAPI class ( default = None , api_version = None , ** kwargs ) Returns quick access to all api functions on the current version of the api View Source class CurrentAPI ( object ) : \"\"\" Returns quick access to all api functions on the current version of the api \"\"\" __slots__ = ( \" api_version \" , \" api \" ) def __init__ ( self , default = None , api_version = None , ** kwargs ) : self . api_version = api_version self . api = api ( ** kwargs ) def __getattr__ ( self , name ) : function = self . api . http . versioned . get ( self . api_version , {} ) . get ( name , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( name , None ) if not function : raise AttributeError ( \" API Function {0} not found \" . format ( name )) accepts = function . interface . arguments if \" hug_api_version \" in accepts : function = partial ( function , hug_api_version = self . api_version ) if \" hug_current_api \" in accepts : function = partial ( function , hug_current_api = self ) return function Timer class ( round_to = None , ** kwargs ) Keeps track of time surpased since instantiation, outputed by doing float(instance) View Source class Timer ( object ) : \"\"\" Keeps track of time surpased since instantiation, outputed by doing float(instance) \"\"\" __slots__ = ( \" start \" , \" round_to \" ) def __init__ ( self , round_to = None , ** kwargs ) : self . start = python_timer () self . round_to = round_to def __float__ ( self ) : time_taken = python_timer () - self . start return round ( time_taken , self . round_to ) if self . round_to else time_taken def __int__ ( self ) : return int ( round ( float ( self ))) def __native_types__ ( self ) : return self . __float__ () def __str__ ( self ) : return str ( float ( self )) def __repr__ ( self ) : return \" {}({}) \" . format ( self . __class__ . __name__ , self )","title":"Directives"},{"location":"reference/hug/directives/#module-hugdirectives","text":"hug/directives.py Defines the directives built into hug. Directives allow attaching behaviour to an API handler based simply on an argument it takes and that arguments default value. The directive gets called with the default supplied, ther request data, and api_version. The result of running the directive method is then set as the argument value. Directive attributes are always prefixed with 'hug_' Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/directives.py Defines the directives built into hug . Directives allow attaching behaviour to an API handler based simply on an argument it takes and that arguments default value . The directive gets called with the default supplied , ther request data , and api_version . The result of running the directive method is then set as the argument value . Directive attributes are always prefixed with ' hug_ ' Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from functools import partial from timeit import default_timer as python_timer from hug import introspect def _built_in_directive ( directive ) : \"\"\" Marks a callable as a built-in directive \"\"\" directive . directive = True return directive @ _built_in_directive class Timer ( object ) : \"\"\" Keeps track of time surpased since instantiation, outputed by doing float(instance) \"\"\" __slots__ = ( \" start \" , \" round_to \" ) def __init__ ( self , round_to = None , ** kwargs ) : self . start = python_timer () self . round_to = round_to def __float__ ( self ) : time_taken = python_timer () - self . start return round ( time_taken , self . round_to ) if self . round_to else time_taken def __int__ ( self ) : return int ( round ( float ( self ))) def __native_types__ ( self ) : return self . __float__ () def __str__ ( self ) : return str ( float ( self )) def __repr__ ( self ) : return \" {}({}) \" . format ( self . __class__ . __name__ , self ) @ _built_in_directive def module ( default = None , api = None , ** kwargs ) : \"\"\" Returns the module that is running this hug API function \"\"\" return api . module if api else default @ _built_in_directive def api ( default = None , api = None , ** kwargs ) : \"\"\" Returns the api instance in which this API function is being ran \"\"\" return api if api else default @ _built_in_directive def api_version ( default = None , api_version = None , ** kwargs ) : \"\"\" Returns the current api_version as a directive for use in both request and not request handling code \"\"\" return api_version @ _built_in_directive def documentation ( default = None , api_version = None , api = None , ** kwargs ) : \"\"\" returns documentation for the current api \"\"\" api_version = default or api_version if api : return api . http . documentation ( base_url = \"\" , api_version = api_version ) @ _built_in_directive def session ( context_name = \" session \" , request = None , ** kwargs ) : \"\"\" Returns the session associated with the current request \"\"\" return request and request . context . get ( context_name , None ) @ _built_in_directive def user ( default = None , request = None , ** kwargs ) : \"\"\" Returns the current logged in user \"\"\" return request and request . context . get ( \" user \" , None ) or default @ _built_in_directive def cors ( support = \" * \" , response = None , ** kwargs ) : \"\"\" Adds the the Access-Control-Allow-Origin header to this endpoint, with the specified support \"\"\" response and response . set_header ( \" Access-Control-Allow-Origin \" , support ) return support @ _built_in_directive class CurrentAPI ( object ) : \"\"\" Returns quick access to all api functions on the current version of the api \"\"\" __slots__ = ( \" api_version \" , \" api \" ) def __init__ ( self , default = None , api_version = None , ** kwargs ) : self . api_version = api_version self . api = api ( ** kwargs ) def __getattr__ ( self , name ) : function = self . api . http . versioned . get ( self . api_version , {} ) . get ( name , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( name , None ) if not function : raise AttributeError ( \" API Function {0} not found \" . format ( name )) accepts = function . interface . arguments if \" hug_api_version \" in accepts : function = partial ( function , hug_api_version = self . api_version ) if \" hug_current_api \" in accepts : function = partial ( function , hug_current_api = self ) return function","title":"Module hug.directives"},{"location":"reference/hug/directives/#functions","text":"","title":"Functions"},{"location":"reference/hug/directives/#api","text":"def ( default = None , api = None , ** kwargs ) Returns the api instance in which this API function is being ran View Source @ _built_in_directive def api ( default = None , api = None , ** kwargs ) : \"\"\" Returns the api instance in which this API function is being ran \"\"\" return api if api else default","title":"api"},{"location":"reference/hug/directives/#api_version","text":"def ( default = None , api_version = None , ** kwargs ) Returns the current api_version as a directive for use in both request and not request handling code View Source @ _built_in_directive def api_version ( default = None , api_version = None , ** kwargs ) : \"\"\" Returns the current api_version as a directive for use in both request and not request handling code \"\"\" return api_version","title":"api_version"},{"location":"reference/hug/directives/#cors","text":"def ( support = '*' , response = None , ** kwargs ) Adds the the Access-Control-Allow-Origin header to this endpoint, with the specified support View Source @ _built_in_directive def cors ( support = \" * \" , response = None , ** kwargs ) : \"\"\" Adds the the Access-Control-Allow-Origin header to this endpoint, with the specified support \"\"\" response and response . set_header ( \" Access-Control-Allow-Origin \" , support ) return support","title":"cors"},{"location":"reference/hug/directives/#documentation","text":"def ( default = None , api_version = None , api = None , ** kwargs ) returns documentation for the current api View Source @ _built_in_directive def documentation ( default = None , api_version = None , api = None , ** kwargs ) : \"\"\" returns documentation for the current api \"\"\" api_version = default or api_version if api : return api . http . documentation ( base_url = \"\" , api_version = api_version )","title":"documentation"},{"location":"reference/hug/directives/#module","text":"def ( default = None , api = None , ** kwargs ) Returns the module that is running this hug API function View Source @ _built_in_directive def module ( default = None , api = None , ** kwargs ) : \"\"\" Returns the module that is running this hug API function \"\"\" return api . module if api else default","title":"module"},{"location":"reference/hug/directives/#session","text":"def ( context_name = 'session' , request = None , ** kwargs ) Returns the session associated with the current request View Source @ _built_in_directive def session ( context_name = \" session \" , request = None , ** kwargs ) : \"\"\" Returns the session associated with the current request \"\"\" return request and request . context . get ( context_name , None )","title":"session"},{"location":"reference/hug/directives/#user","text":"def ( default = None , request = None , ** kwargs ) Returns the current logged in user View Source @ _built_in_directive def user ( default = None , request = None , ** kwargs ) : \"\"\" Returns the current logged in user \"\"\" return request and request . context . get ( \" user \" , None ) or default","title":"user"},{"location":"reference/hug/directives/#classes","text":"","title":"Classes"},{"location":"reference/hug/directives/#currentapi","text":"class ( default = None , api_version = None , ** kwargs ) Returns quick access to all api functions on the current version of the api View Source class CurrentAPI ( object ) : \"\"\" Returns quick access to all api functions on the current version of the api \"\"\" __slots__ = ( \" api_version \" , \" api \" ) def __init__ ( self , default = None , api_version = None , ** kwargs ) : self . api_version = api_version self . api = api ( ** kwargs ) def __getattr__ ( self , name ) : function = self . api . http . versioned . get ( self . api_version , {} ) . get ( name , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( name , None ) if not function : raise AttributeError ( \" API Function {0} not found \" . format ( name )) accepts = function . interface . arguments if \" hug_api_version \" in accepts : function = partial ( function , hug_api_version = self . api_version ) if \" hug_current_api \" in accepts : function = partial ( function , hug_current_api = self ) return function","title":"CurrentAPI"},{"location":"reference/hug/directives/#timer","text":"class ( round_to = None , ** kwargs ) Keeps track of time surpased since instantiation, outputed by doing float(instance) View Source class Timer ( object ) : \"\"\" Keeps track of time surpased since instantiation, outputed by doing float(instance) \"\"\" __slots__ = ( \" start \" , \" round_to \" ) def __init__ ( self , round_to = None , ** kwargs ) : self . start = python_timer () self . round_to = round_to def __float__ ( self ) : time_taken = python_timer () - self . start return round ( time_taken , self . round_to ) if self . round_to else time_taken def __int__ ( self ) : return int ( round ( float ( self ))) def __native_types__ ( self ) : return self . __float__ () def __str__ ( self ) : return str ( float ( self )) def __repr__ ( self ) : return \" {}({}) \" . format ( self . __class__ . __name__ , self )","title":"Timer"},{"location":"reference/hug/exceptions/","text":"Module hug.exceptions hug/exceptions.py Defines the custom exceptions that are part of, and support Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/exceptions.py Defines the custom exceptions that are part of , and support Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import class InvalidTypeData ( Exception ) : \"\"\" Should be raised when data passed in doesn't match a types expectations \"\"\" def __init__ ( self , message , reasons = None ) : self . message = message self . reasons = reasons class StoreKeyNotFound ( Exception ) : \"\"\" Should be raised when a store key has not been found inside a store \"\"\" class SessionNotFound ( StoreKeyNotFound ) : \"\"\" Should be raised when a session ID has not been found inside a session store \"\"\" pass Classes InvalidTypeData class ( message , reasons = None ) Should be raised when data passed in doesn't match a types expectations View Source class InvalidTypeData ( Exception ): \"\"\"Should be raised when data passed in doesn't match a types expectations\"\"\" def __init__ ( self , message , reasons = None ): self . message = message self . reasons = reasons Ancestors (in MRO) builtins.Exception builtins.BaseException SessionNotFound class ( / , * args , ** kwargs ) Should be raised when a session ID has not been found inside a session store View Source class SessionNotFound ( StoreKeyNotFound ): \"\"\"Should be raised when a session ID has not been found inside a session store\"\"\" pass Ancestors (in MRO) hug.exceptions.StoreKeyNotFound builtins.Exception builtins.BaseException StoreKeyNotFound class ( / , * args , ** kwargs ) Should be raised when a store key has not been found inside a store View Source class StoreKeyNotFound ( Exception ): \"\"\"Should be raised when a store key has not been found inside a store\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants hug.exceptions.SessionNotFound","title":"Exceptions"},{"location":"reference/hug/exceptions/#module-hugexceptions","text":"hug/exceptions.py Defines the custom exceptions that are part of, and support Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/exceptions.py Defines the custom exceptions that are part of , and support Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import class InvalidTypeData ( Exception ) : \"\"\" Should be raised when data passed in doesn't match a types expectations \"\"\" def __init__ ( self , message , reasons = None ) : self . message = message self . reasons = reasons class StoreKeyNotFound ( Exception ) : \"\"\" Should be raised when a store key has not been found inside a store \"\"\" class SessionNotFound ( StoreKeyNotFound ) : \"\"\" Should be raised when a session ID has not been found inside a session store \"\"\" pass","title":"Module hug.exceptions"},{"location":"reference/hug/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/hug/exceptions/#invalidtypedata","text":"class ( message , reasons = None ) Should be raised when data passed in doesn't match a types expectations View Source class InvalidTypeData ( Exception ): \"\"\"Should be raised when data passed in doesn't match a types expectations\"\"\" def __init__ ( self , message , reasons = None ): self . message = message self . reasons = reasons","title":"InvalidTypeData"},{"location":"reference/hug/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/hug/exceptions/#sessionnotfound","text":"class ( / , * args , ** kwargs ) Should be raised when a session ID has not been found inside a session store View Source class SessionNotFound ( StoreKeyNotFound ): \"\"\"Should be raised when a session ID has not been found inside a session store\"\"\" pass","title":"SessionNotFound"},{"location":"reference/hug/exceptions/#ancestors-in-mro_1","text":"hug.exceptions.StoreKeyNotFound builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/hug/exceptions/#storekeynotfound","text":"class ( / , * args , ** kwargs ) Should be raised when a store key has not been found inside a store View Source class StoreKeyNotFound ( Exception ): \"\"\"Should be raised when a store key has not been found inside a store\"\"\"","title":"StoreKeyNotFound"},{"location":"reference/hug/exceptions/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/hug/exceptions/#descendants","text":"hug.exceptions.SessionNotFound","title":"Descendants"},{"location":"reference/hug/format/","text":"Module hug.format hug/format.py Defines formatting utility methods that are common both to input and output formatting and aid in general formatting of fields and content Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/format.py Defines formatting utility methods that are common both to input and output formatting and aid in general formatting of fields and content Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import re from cgi import parse_header from hug import _empty as empty UNDERSCORE = ( re . compile ( \" (.)([A-Z][a-z]+) \" ) , re . compile ( \" ([a-z0-9])([A-Z]) \" )) def parse_content_type ( content_type ) : \"\"\" Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters) \"\"\" if content_type is not None and \" ; \" in content_type : return parse_header ( content_type ) return ( content_type , empty . dict ) def content_type ( content_type ) : \"\"\" Attaches the supplied content_type to a Hug formatting function \"\"\" def decorator ( method ) : method . content_type = content_type return method return decorator def underscore ( text ) : \"\"\" Converts text that may be camelcased into an underscored format \"\"\" return UNDERSCORE [ 1 ]. sub ( r \" \\1_\\2 \" , UNDERSCORE [ 0 ]. sub ( r \" \\1_\\2 \" , text )) . lower () def camelcase ( text ) : \"\"\" Converts text that may be underscored into a camelcase format \"\"\" return text [ 0 ] + \"\" . join ( text . title () . split ( \" _ \" )) [ 1 :] Variables UNDERSCORE Functions camelcase def ( text ) Converts text that may be underscored into a camelcase format View Source def camelcase ( text ) : \"\"\" Converts text that may be underscored into a camelcase format \"\"\" return text [ 0 ] + \"\" . join ( text . title () . split ( \" _ \" )) [ 1 :] content_type def ( content_type ) Attaches the supplied content_type to a Hug formatting function View Source def content_type ( content_type ) : \"\"\" Attaches the supplied content_type to a Hug formatting function \"\"\" def decorator ( method ) : method . content_type = content_type return method return decorator parse_content_type def ( content_type ) Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters) View Source def parse_content_type ( content_type ) : \"\"\" Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters) \"\"\" if content_type is not None and \" ; \" in content_type : return parse_header ( content_type ) return ( content_type , empty . dict ) underscore def ( text ) Converts text that may be camelcased into an underscored format View Source def underscore ( text ) : \"\"\" Converts text that may be camelcased into an underscored format \"\"\" return UNDERSCORE [ 1 ]. sub ( r \" \\1_\\2 \" , UNDERSCORE [ 0 ]. sub ( r \" \\1_\\2 \" , text )) . lower ()","title":"Format"},{"location":"reference/hug/format/#module-hugformat","text":"hug/format.py Defines formatting utility methods that are common both to input and output formatting and aid in general formatting of fields and content Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/format.py Defines formatting utility methods that are common both to input and output formatting and aid in general formatting of fields and content Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import re from cgi import parse_header from hug import _empty as empty UNDERSCORE = ( re . compile ( \" (.)([A-Z][a-z]+) \" ) , re . compile ( \" ([a-z0-9])([A-Z]) \" )) def parse_content_type ( content_type ) : \"\"\" Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters) \"\"\" if content_type is not None and \" ; \" in content_type : return parse_header ( content_type ) return ( content_type , empty . dict ) def content_type ( content_type ) : \"\"\" Attaches the supplied content_type to a Hug formatting function \"\"\" def decorator ( method ) : method . content_type = content_type return method return decorator def underscore ( text ) : \"\"\" Converts text that may be camelcased into an underscored format \"\"\" return UNDERSCORE [ 1 ]. sub ( r \" \\1_\\2 \" , UNDERSCORE [ 0 ]. sub ( r \" \\1_\\2 \" , text )) . lower () def camelcase ( text ) : \"\"\" Converts text that may be underscored into a camelcase format \"\"\" return text [ 0 ] + \"\" . join ( text . title () . split ( \" _ \" )) [ 1 :]","title":"Module hug.format"},{"location":"reference/hug/format/#variables","text":"UNDERSCORE","title":"Variables"},{"location":"reference/hug/format/#functions","text":"","title":"Functions"},{"location":"reference/hug/format/#camelcase","text":"def ( text ) Converts text that may be underscored into a camelcase format View Source def camelcase ( text ) : \"\"\" Converts text that may be underscored into a camelcase format \"\"\" return text [ 0 ] + \"\" . join ( text . title () . split ( \" _ \" )) [ 1 :]","title":"camelcase"},{"location":"reference/hug/format/#content_type","text":"def ( content_type ) Attaches the supplied content_type to a Hug formatting function View Source def content_type ( content_type ) : \"\"\" Attaches the supplied content_type to a Hug formatting function \"\"\" def decorator ( method ) : method . content_type = content_type return method return decorator","title":"content_type"},{"location":"reference/hug/format/#parse_content_type","text":"def ( content_type ) Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters) View Source def parse_content_type ( content_type ) : \"\"\" Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters) \"\"\" if content_type is not None and \" ; \" in content_type : return parse_header ( content_type ) return ( content_type , empty . dict )","title":"parse_content_type"},{"location":"reference/hug/format/#underscore","text":"def ( text ) Converts text that may be camelcased into an underscored format View Source def underscore ( text ) : \"\"\" Converts text that may be camelcased into an underscored format \"\"\" return UNDERSCORE [ 1 ]. sub ( r \" \\1_\\2 \" , UNDERSCORE [ 0 ]. sub ( r \" \\1_\\2 \" , text )) . lower ()","title":"underscore"},{"location":"reference/hug/input_format/","text":"Module hug.input_format hug/input_formats.py Defines the built-in Hug input_formatting handlers Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/input_formats.py Defines the built - in Hug input_formatting handlers Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import re from cgi import parse_multipart from urllib . parse import parse_qs as urlencoded_converter from falcon . util . uri import parse_query_string from hug . format import content_type , underscore from hug . json_module import json as json_converter @ content_type ( \" text/plain \" ) def text ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes plain text data \"\"\" return body . read () . decode ( charset ) @ content_type ( \" application/json \" ) def json ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes JSON formatted data, converting it into native Python objects \"\"\" return json_converter . loads ( text ( body , charset = charset )) def _underscore_dict ( dictionary ) : new_dictionary = {} for key , value in dictionary . items () : if isinstance ( value , dict ) : value = _underscore_dict ( value ) if isinstance ( key , str ) : key = underscore ( key ) new_dictionary [ key ] = value return new_dictionary def json_underscore ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Converts JSON formatted date to native Python objects. The keys in any JSON dict are transformed from camelcase to underscore separated words . \"\"\" return _underscore_dict ( json ( body , charset = charset )) @ content_type ( \" application/x-www-form-urlencoded \" ) def urlencoded ( body , charset = \" ascii \" , ** kwargs ) : \"\"\" Converts query strings into native Python objects \"\"\" return parse_query_string ( text ( body , charset = charset ) , False ) @ content_type ( \" multipart/form-data \" ) def multipart ( body , content_length = 0 , ** header_params ) : \"\"\" Converts multipart form data into native Python objects \"\"\" header_params . setdefault ( \" CONTENT-LENGTH \" , content_length ) if header_params and \" boundary \" in header_params : if type ( header_params [ \" boundary \" ] ) is str : header_params [ \" boundary \" ] = header_params [ \" boundary \" ]. encode () form = parse_multipart (( body . stream if hasattr ( body , \" stream \" ) else body ) , header_params ) for key , value in form . items () : if type ( value ) is list and len ( value ) is 1 : form [ key ] = value [ 0 ] return form Functions json def ( body , charset = 'utf-8' , ** kwargs ) Takes JSON formatted data, converting it into native Python objects View Source @ content_type ( \" application/json \" ) def json ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes JSON formatted data, converting it into native Python objects \"\"\" return json_converter . loads ( text ( body , charset = charset )) json_underscore def ( body , charset = 'utf-8' , ** kwargs ) Converts JSON formatted date to native Python objects. The keys in any JSON dict are transformed from camelcase to underscore separated words. View Source def json_underscore ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Converts JSON formatted date to native Python objects. The keys in any JSON dict are transformed from camelcase to underscore separated words . \"\"\" return _underscore_dict ( json ( body , charset = charset )) multipart def ( body , content_length = 0 , ** header_params ) Converts multipart form data into native Python objects View Source @ content_type ( \" multipart/form-data \" ) def multipart ( body , content_length = 0 , ** header_params ) : \"\"\" Converts multipart form data into native Python objects \"\"\" header_params . setdefault ( \" CONTENT-LENGTH \" , content_length ) if header_params and \" boundary \" in header_params : if type ( header_params [ \" boundary \" ] ) is str : header_params [ \" boundary \" ] = header_params [ \" boundary \" ]. encode () form = parse_multipart (( body . stream if hasattr ( body , \" stream \" ) else body ) , header_params ) for key , value in form . items () : if type ( value ) is list and len ( value ) is 1 : form [ key ] = value [ 0 ] return form text def ( body , charset = 'utf-8' , ** kwargs ) Takes plain text data View Source @ content_type ( \" text/plain \" ) def text ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes plain text data \"\"\" return body . read () . decode ( charset ) urlencoded def ( body , charset = 'ascii' , ** kwargs ) Converts query strings into native Python objects View Source @ content_type ( \" application/x-www-form-urlencoded \" ) def urlencoded ( body , charset = \" ascii \" , ** kwargs ) : \"\"\" Converts query strings into native Python objects \"\"\" return parse_query_string ( text ( body , charset = charset ) , False )","title":"Input Format"},{"location":"reference/hug/input_format/#module-huginput_format","text":"hug/input_formats.py Defines the built-in Hug input_formatting handlers Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/input_formats.py Defines the built - in Hug input_formatting handlers Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import re from cgi import parse_multipart from urllib . parse import parse_qs as urlencoded_converter from falcon . util . uri import parse_query_string from hug . format import content_type , underscore from hug . json_module import json as json_converter @ content_type ( \" text/plain \" ) def text ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes plain text data \"\"\" return body . read () . decode ( charset ) @ content_type ( \" application/json \" ) def json ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes JSON formatted data, converting it into native Python objects \"\"\" return json_converter . loads ( text ( body , charset = charset )) def _underscore_dict ( dictionary ) : new_dictionary = {} for key , value in dictionary . items () : if isinstance ( value , dict ) : value = _underscore_dict ( value ) if isinstance ( key , str ) : key = underscore ( key ) new_dictionary [ key ] = value return new_dictionary def json_underscore ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Converts JSON formatted date to native Python objects. The keys in any JSON dict are transformed from camelcase to underscore separated words . \"\"\" return _underscore_dict ( json ( body , charset = charset )) @ content_type ( \" application/x-www-form-urlencoded \" ) def urlencoded ( body , charset = \" ascii \" , ** kwargs ) : \"\"\" Converts query strings into native Python objects \"\"\" return parse_query_string ( text ( body , charset = charset ) , False ) @ content_type ( \" multipart/form-data \" ) def multipart ( body , content_length = 0 , ** header_params ) : \"\"\" Converts multipart form data into native Python objects \"\"\" header_params . setdefault ( \" CONTENT-LENGTH \" , content_length ) if header_params and \" boundary \" in header_params : if type ( header_params [ \" boundary \" ] ) is str : header_params [ \" boundary \" ] = header_params [ \" boundary \" ]. encode () form = parse_multipart (( body . stream if hasattr ( body , \" stream \" ) else body ) , header_params ) for key , value in form . items () : if type ( value ) is list and len ( value ) is 1 : form [ key ] = value [ 0 ] return form","title":"Module hug.input_format"},{"location":"reference/hug/input_format/#functions","text":"","title":"Functions"},{"location":"reference/hug/input_format/#json","text":"def ( body , charset = 'utf-8' , ** kwargs ) Takes JSON formatted data, converting it into native Python objects View Source @ content_type ( \" application/json \" ) def json ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes JSON formatted data, converting it into native Python objects \"\"\" return json_converter . loads ( text ( body , charset = charset ))","title":"json"},{"location":"reference/hug/input_format/#json_underscore","text":"def ( body , charset = 'utf-8' , ** kwargs ) Converts JSON formatted date to native Python objects. The keys in any JSON dict are transformed from camelcase to underscore separated words. View Source def json_underscore ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Converts JSON formatted date to native Python objects. The keys in any JSON dict are transformed from camelcase to underscore separated words . \"\"\" return _underscore_dict ( json ( body , charset = charset ))","title":"json_underscore"},{"location":"reference/hug/input_format/#multipart","text":"def ( body , content_length = 0 , ** header_params ) Converts multipart form data into native Python objects View Source @ content_type ( \" multipart/form-data \" ) def multipart ( body , content_length = 0 , ** header_params ) : \"\"\" Converts multipart form data into native Python objects \"\"\" header_params . setdefault ( \" CONTENT-LENGTH \" , content_length ) if header_params and \" boundary \" in header_params : if type ( header_params [ \" boundary \" ] ) is str : header_params [ \" boundary \" ] = header_params [ \" boundary \" ]. encode () form = parse_multipart (( body . stream if hasattr ( body , \" stream \" ) else body ) , header_params ) for key , value in form . items () : if type ( value ) is list and len ( value ) is 1 : form [ key ] = value [ 0 ] return form","title":"multipart"},{"location":"reference/hug/input_format/#text","text":"def ( body , charset = 'utf-8' , ** kwargs ) Takes plain text data View Source @ content_type ( \" text/plain \" ) def text ( body , charset = \" utf-8 \" , ** kwargs ) : \"\"\" Takes plain text data \"\"\" return body . read () . decode ( charset )","title":"text"},{"location":"reference/hug/input_format/#urlencoded","text":"def ( body , charset = 'ascii' , ** kwargs ) Converts query strings into native Python objects View Source @ content_type ( \" application/x-www-form-urlencoded \" ) def urlencoded ( body , charset = \" ascii \" , ** kwargs ) : \"\"\" Converts query strings into native Python objects \"\"\" return parse_query_string ( text ( body , charset = charset ) , False )","title":"urlencoded"},{"location":"reference/hug/interface/","text":"Module hug.interface hug/interface.py Defines the various interface hug provides to expose routes to functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\"hug/interface.py Defines the various interface hug provides to expose routes to functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software \"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from __ future__ import absolute_import import argparse import asyncio import os import sys from collections import OrderedDict from functools import lru_cache , partial , wraps import falcon from falcon import HTTP_BAD_REQUEST import hug . _ empty as empty import hug . api import hug . output_format import hug . types as types from hug import introspect from hug . exceptions import InvalidTypeData from hug . format import parse_content_type from hug . types import ( MarshmallowInputSchema , MarshmallowReturnSchema , Multiple , OneOf , SmartBoolean , Text , text , ) DOC_TYPE_MAP = { str : \"String\" , bool : \"Boolean\" , list : \"Multiple\" , int : \"Integer\" , float : \"Float\" } def _ doc ( kind ) : return DOC_TYPE_MAP . get ( kind , kind . __ doc__ ) def asyncio_call ( function , * args , **kwargs ) : loop = asyncio . get_event_loop () if loop . is_running () : return function ( * args , **kwargs ) function = asyncio . ensure_future ( function ( * args , **kwargs ), loop = loop ) loop . run_until_complete ( function ) return function . result () class Interfaces ( object ) : \"\"\"Defines the per-function singleton applied to hugged functions defining common data needed by all interfaces\"\"\" def __ init__ ( self , function , args = None ) : self . api = hug . api . from_object ( function ) self . spec = getattr ( function , \"original\" , function ) self . arguments = introspect . arguments ( function ) self . name = introspect . name ( function ) self . _ function = function self . is_coroutine = introspect . is_coroutine ( self . spec ) if self . is_coroutine: self . spec = getattr ( self . spec , \"__wrapped__\" , self . spec ) self . takes_args = introspect . takes_args ( self . spec ) self . takes_kwargs = introspect . takes_kwargs ( self . spec ) self . parameters = list ( introspect . arguments ( self . spec , self . takes_kwargs + self . takes_args )) if self . takes_kwargs: self . kwarg = self . parameters . pop ( - 1 ) if self . takes_args: self . arg = self . parameters . pop ( - 1 ) self . parameters = tuple ( self . parameters ) self . defaults = dict ( zip ( reversed ( self . parameters ), reversed ( self . spec . __ defaults__ or ()))) self . required = self . parameters [ : - ( len ( self . spec . __ defaults__ or ())) or None ] self . is_method = introspect . is_method ( self . spec ) or introspect . is_method ( function ) if self . is_method: self . required = self . required [ 1 : ] self . parameters = self . parameters [ 1 : ] self . all_parameters = set ( self . parameters ) if self . spec is not function : self . all_parameters . update ( self . arguments ) if args is not None : transformers = args else : transformers = self . spec . __ annotations__ self . transform = transformers . get ( \"return\" , None ) self . directives = {} self . input_transformations = {} for name , transformer in transformers . items () : if isinstance ( transformer , str ) : continue elif hasattr ( transformer , \"directive\" ) : self . directives [ name ] = transformer continue if hasattr ( transformer , \"from_string\" ) : transformer = transformer . from_string elif hasattr ( transformer , \"load\" ) : transformer = MarshmallowInputSchema ( transformer ) elif hasattr ( transformer , \"deserialize\" ) : transformer = transformer . deserialize self . input_transformations [ name ] = transformer def __ call__ ( __ hug_internal_self , * args , **kwargs ) : # noqa : N805 \"\"\"\" Calls the wrapped function , uses __ hug_internal_self incase self is passed in as a kwarg from the wrapper \"\"\" if not __hug_internal_self.is_coroutine: return __hug_internal_self._function(*args, **kwargs) return asyncio_call(__hug_internal_self._function, *args, **kwargs) class Interface(object): \"\"\" Defines the basic hug interface object , which is responsible for wrapping a user defined function and providing all the info requested in the function as well as the route A Interface object should be created for every kind of protocal hug supports \"\"\" __slots__ = ( \" interface \", \" _ api \", \" defaults \", \" parameters \", \" required \", \" _ outputs \", \" on_invalid \", \" requires \", \" validate_function \", \" transform \", \" examples \", \" output_doc \", \" wrapped \", \" directives \", \" all_parameters \", \" raise_on_invalid \", \" invalid_outputs \", \" map_params \", \" input_transformations \", ) def __init__(self, route, function): if route.get(\" api \", None): self._api = route[\" api \"] if \" examples \" in route: self.examples = route[\" examples \"] function_args = route.get(\" args \") if not hasattr(function, \" interface \"): function.__dict__[\" interface \"] = Interfaces(function, function_args) self.interface = function.interface self.requires = route.get(\" requires \", ()) if \" validate \" in route: self.validate_function = route[\" validate \"] if \" output_invalid \" in route: self.invalid_outputs = route[\" output_invalid \"] if not \" parameters \" in route: self.defaults = self.interface.defaults self.parameters = self.interface.parameters self.all_parameters = self.interface.all_parameters self.required = self.interface.required else: self.defaults = route.get(\" defaults \", {}) self.parameters = tuple(route[\" parameters \"]) self.all_parameters = set(route[\" parameters \"]) self.required = tuple( [parameter for parameter in self.parameters if parameter not in self.defaults] ) if \" map_params \" in route: self.map_params = route[\" map_params \"] for interface_name, internal_name in self.map_params.items(): if internal_name in self.defaults: self.defaults[interface_name] = self.defaults.pop(internal_name) if internal_name in self.parameters: self.parameters = [ interface_name if param == internal_name else param for param in self.parameters ] if internal_name in self.all_parameters: self.all_parameters.remove(internal_name) self.all_parameters.add(interface_name) if internal_name in self.required: self.required = tuple( [ interface_name if param == internal_name else param for param in self.required ] ) reverse_mapping = { internal: interface for interface, internal in self.map_params.items() } self.input_transformations = { reverse_mapping.get(name, name): transform for name, transform in self.interface.input_transformations.items() } else: self.map_params = {} self.input_transformations = self.interface.input_transformations if \" output \" in route: self.outputs = route[\" output \"] self.transform = route.get(\" transform \", None) if self.transform is None and not isinstance(self.interface.transform, (str, type(None))): self.transform = self.interface.transform if hasattr(self.transform, \" dump \"): self.transform = MarshmallowReturnSchema(self.transform) self.output_doc = self.transform.__doc__ elif self.transform or self.interface.transform: output_doc = self.transform or self.interface.transform self.output_doc = output_doc if type(output_doc) is str else _doc(output_doc) self.raise_on_invalid = route.get(\" raise_on_invalid \", False) if \" on_invalid \" in route: self.on_invalid = route[\" on_invalid \"] elif self.transform: self.on_invalid = self.transform defined_directives = self.api.directives() used_directives = set(self.parameters).intersection(defined_directives) self.directives = { directive_name: defined_directives[directive_name] for directive_name in used_directives } self.directives.update(self.interface.directives) @property def api(self): return getattr(self, \" _ api \", self.interface.api) @property def outputs(self): return getattr(self, \" _ outputs \", None) @outputs.setter def outputs(self, outputs): self._outputs = outputs # pragma: no cover - generally re-implemented by sub classes def validate(self, input_parameters, context): \"\"\" Runs all set type transformers / validators against the provided input parameters and returns any errors \"\"\" errors = {} for key, type_handler in self.input_transformations.items(): if self.raise_on_invalid: if key in input_parameters: input_parameters[key] = self.initialize_handler( type_handler, input_parameters[key], context=context ) else: try: if key in input_parameters: input_parameters[key] = self.initialize_handler( type_handler, input_parameters[key], context=context ) except InvalidTypeData as error: errors[key] = error.reasons or str(error) except Exception as error: if hasattr(error, \" args \") and error.args: errors[key] = error.args[0] else: errors[key] = str(error) for require in self.required: if not require in input_parameters: errors[require] = \" Required parameter '{}' not supplied \".format(require) if not errors and getattr(self, \" validate_function \", False): errors = self.validate_function(input_parameters) return errors def check_requirements(self, request=None, response=None, context=None): \"\"\" Checks to see if all requirements set pass if all requirements pass nothing will be returned otherwise , the error reported will be returned \"\"\" for requirement in self.requires: conclusion = requirement( response=response, request=request, context=context, module=self.api.module ) if conclusion and conclusion is not True: return conclusion def documentation(self, add_to=None): \"\"\" Produces general documentation for the interface \"\"\" doc = OrderedDict if add_to is None else add_to usage = self.interface.spec.__doc__ if usage: doc[\" usage \"] = usage if getattr(self, \" requires \", None): doc[\" requires \"] = [ getattr(requirement, \" __ doc__ \", requirement.__name__) for requirement in self.requires ] doc[\" outputs \"] = OrderedDict() doc[\" outputs \"][\" format \"] = _doc(self.outputs) doc[\" outputs \"][\" content_type \"] = self.outputs.content_type parameters = [ param for param in self.parameters if not param in (\" request \", \" response \", \" self \") and not param in (\" api_version \", \" body \") and not param.startswith(\" hug_ \") and not hasattr(param, \" directive \") ] if parameters: inputs = doc.setdefault(\" inputs \", OrderedDict()) types = self.interface.spec.__annotations__ for argument in parameters: kind = types.get(self._remap_entry(argument), text) if getattr(kind, \" directive \", None) is True: continue input_definition = inputs.setdefault(argument, OrderedDict()) input_definition[\" type \"] = kind if isinstance(kind, str) else _doc(kind) default = self.defaults.get(argument, None) if default is not None: input_definition[\" default \"] = default return doc def _rewrite_params(self, params): for interface_name, internal_name in self.map_params.items(): if interface_name in params: params[internal_name] = params.pop(interface_name) def _remap_entry(self, interface_name): return self.map_params.get(interface_name, interface_name) @staticmethod def cleanup_parameters(parameters, exception=None): for _parameter, directive in parameters.items(): if hasattr(directive, \" cleanup \"): directive.cleanup(exception=exception) @staticmethod def initialize_handler(handler, value, context): try: # It's easier to ask for forgiveness than for permission return handler(value, context=context) except TypeError: return handler(value) class Local(Interface): \"\"\" Defines the Interface responsible for exposing functions locally \"\"\" __slots__ = (\" skip_directives \", \" skip_validation \", \" version \") def __init__(self, route, function): super().__init__(route, function) self.version = route.get(\" version \", None) if \" skip_directives \" in route: self.skip_directives = True if \" skip_validation \" in route: self.skip_validation = True self.interface.local = self def __get__(self, instance, kind): \"\"\" Support instance methods \"\"\" return partial(self.__call__, instance) if instance else self.__call__ @property def __name__(self): return self.interface.spec.__name__ @property def __module__(self): return self.interface.spec.__module__ def __call__(self, *args, **kwargs): context = self.api.context_factory(api=self.api, api_version=self.version, interface=self) \"\"\" Defines how calling the function locally should be handled \"\"\" for _requirement in self.requires: lacks_requirement = self.check_requirements(context=context) if lacks_requirement: self.api.delete_context(context, lacks_requirement=lacks_requirement) return self.outputs(lacks_requirement) if self.outputs else lacks_requirement for index, argument in enumerate(args): kwargs[self.parameters[index]] = argument if not getattr(self, \" skip_directives \", False): for parameter, directive in self.directives.items(): if parameter in kwargs: continue arguments = (self.defaults[parameter],) if parameter in self.defaults else () kwargs[parameter] = directive( *arguments, api=self.api, api_version=self.version, interface=self, context=context ) if not getattr(self, \" skip_validation \", False): errors = self.validate(kwargs, context) if errors: errors = {\" errors \": errors} if getattr(self, \" on_invalid \", False): errors = self.on_invalid(errors) outputs = getattr(self, \" invalid_outputs \", self.outputs) self.api.delete_context(context, errors=errors) return outputs(errors) if outputs else errors self._rewrite_params(kwargs) try: result = self.interface(**kwargs) if self.transform: if hasattr(self.transform, \" context \"): self.transform.context = context result = self.transform(result) except Exception as exception: self.cleanup_parameters(kwargs, exception=exception) self.api.delete_context(context, exception=exception) raise exception self.cleanup_parameters(kwargs) self.api.delete_context(context) return self.outputs(result) if self.outputs else result class CLI(Interface): \"\"\" Defines the Interface responsible for exposing functions to the CLI \"\"\" def __init__(self, route, function): super().__init__(route, function) if not self.outputs: self.outputs = self.api.cli.output_format self.interface.cli = self self.reaffirm_types = {} use_parameters = list(self.interface.parameters) self.additional_options = getattr( self.interface, \" arg \", getattr(self.interface, \" kwarg \", False) ) if self.additional_options: use_parameters.append(self.additional_options) used_options = {\" h \", \" help \"} nargs_set = self.interface.takes_args or self.interface.takes_kwargs class CustomArgumentParser(argparse.ArgumentParser): exit_callback = None def exit(self, status=0, message=None): if self.exit_callback: self.exit_callback(message) super().exit(status, message) self.parser = CustomArgumentParser( description=route.get(\" doc \", self.interface.spec.__doc__) ) if \" version \" in route: self.parser.add_argument( \" - v \", \" --version \", action=\" version \", version=\" { 0 } { 1 } \".format( route.get(\" name \", self.interface.spec.__name__), route[\" version \"] ), ) used_options.update((\" v \", \" version \")) self.context_tranforms = [] for option in use_parameters: if option in self.directives: continue if option in self.interface.required or option == self.additional_options: args = (option,) else: short_option = option[0] while short_option in used_options and len(short_option) < len(option): short_option = option[: len(short_option) + 1] used_options.add(short_option) used_options.add(option) if short_option != option: args = (\" - { 0 } \".format(short_option), \" -- { 0 } \".format(option)) else: args = (\" -- { 0 } \".format(option),) kwargs = {} if option in self.defaults: kwargs[\" default \"] = self.defaults[option] if option in self.interface.input_transformations: transform = self.interface.input_transformations[option] kwargs[\" type \"] = transform kwargs[\" help \"] = _doc(transform) if transform in (list, tuple) or isinstance(transform, types.Multiple): kwargs[\" action \"] = \" append \" kwargs[\" type \"] = Text() self.reaffirm_types[option] = transform elif transform == bool or isinstance(transform, type(types.boolean)): kwargs[\" action \"] = \" store_true \" self.reaffirm_types[option] = transform elif isinstance(transform, types.OneOf): kwargs[\" choices \"] = transform.values elif ( option in self.interface.spec.__annotations__ and type(self.interface.spec.__annotations__[option]) == str ): kwargs[\" help \"] = option if ( kwargs.get(\" type \", None) == bool or kwargs.get(\" action \", None) == \" store_true \" ) and not kwargs[\" default \"]: kwargs[\" action \"] = \" store_true \" kwargs.pop(\" type \", None) elif kwargs.get(\" action \", None) == \" store_true \": kwargs.pop(\" action \", None) if option == self.additional_options: kwargs[\" nargs \"] = \" * \" elif ( not nargs_set and kwargs.get(\" action \", None) == \" append \" and not option in self.interface.defaults ): kwargs[\" nargs \"] = \" * \" kwargs.pop(\" action \", \"\") nargs_set = True self.parser.add_argument(*args, **kwargs) self.api.cli.commands[route.get(\" name \", self.interface.spec.__name__)] = self def output(self, data, context): \"\"\" Outputs the provided data using the transformations and output format specified for this CLI endpoint \"\"\" if self.transform: if hasattr(self.transform, \" context \"): self.transform.context = context data = self.transform(data) if hasattr(data, \" read \"): data = data.read().decode(\" utf8 \") if data is not None: data = self.outputs(data) if data: sys.stdout.buffer.write(data) if not data.endswith(b\" \\n \"): sys.stdout.buffer.write(b\" \\n \") return data def __str__(self): return self.parser.description or \"\" def __call__(self): \"\"\" Calls the wrapped function through the lens of a CLI ran command \"\"\" context = self.api.context_factory(api=self.api, argparse=self.parser, interface=self) def exit_callback(message): self.api.delete_context(context, errors=message) self.parser.exit_callback = exit_callback self.api._ensure_started() for requirement in self.requires: conclusion = requirement(request=sys.argv, module=self.api.module, context=context) if conclusion and conclusion is not True: self.api.delete_context(context, lacks_requirement=conclusion) return self.output(conclusion, context) if self.interface.is_method: self.parser.prog = \" %s %s\" % (self.api.module.__name__, self.interface.name) known , unknown = self . parser . parse_known_args () pass_to_function = vars ( known ) for option , directive in self . directives . items () : arguments = ( self . defaults [ option ],) if option in self . defaults else () pass_to_function [ option ] = directive ( * arguments , api = self . api , argparse = self . parser , context = context , interface = self ) for field , type_handler in self . reaffirm_types . items () : if field in pass_to_function: if not pass_to_function [ field ] and type_handler in ( list , tuple , hug . types . Multiple , ) : pass_to_function [ field ] = type_handler (()) else : pass_to_function [ field ] = self . initialize_handler ( type_handler , pass_to_function [ field ], context = context ) if getattr ( self , \"validate_function\" , False ) : errors = self . validate_function ( pass_to_function ) if errors : self . api . delete_context ( context , errors = errors ) return self . output ( errors , context ) args = None if self . additional_options: args = [] for parameter in self . interface . parameters : if parameter in pass_to_function: args . append ( pass_to_function . pop ( parameter )) args . extend ( pass_to_function . pop ( self . additional_options , ())) if self . interface . takes_kwargs: add_options_to = None for option in unknown : if option . startswith ( \"--\" ) : if add_options_to: value = pass_to_function [ add_options_to ] if len ( value ) == 1 : pass_to_function [ add_options_to ] = value [ 0 ] elif value == [] : pass_to_function [ add_options_to ] = True add_options_to = option [ 2 : ] pass_to_function . setdefault ( add_options_to , []) elif add_options_to: pass_to_function [ add_options_to ]. append ( option ) self . _ rewrite_params ( pass_to_function ) try : if args : result = self . output ( self . interface ( * args , **pass_to_function ), context ) else : result = self . output ( self . interface ( **pass_to_function ), context ) except Exception as exception : self . cleanup_parameters ( pass_to_function , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( pass_to_function ) self . api . delete_context ( context ) return result class HTTP ( Interface ) : \"\"\"Defines the interface responsible for wrapping functions and exposing them via HTTP based on the route\"\"\" __ slots__ = ( \"_params_for_outputs_state\" , \"_params_for_invalid_outputs_state\" , \"_params_for_transform_state\" , \"_params_for_on_invalid\" , \"set_status\" , \"response_headers\" , \"transform\" , \"input_transformations\" , \"examples\" , \"wrapped\" , \"catch_exceptions\" , \"parse_body\" , \"private\" , \"on_invalid\" , \"inputs\" , ) AUTO_INCLUDE = { \"request\" , \"response\" } def __ init__ ( self , route , function , catch_exceptions = True ) : super (). __ init__ ( route , function ) self . catch_exceptions = catch_exceptions self . parse_body = \"parse_body\" in route self . set_status = route . get ( \"status\" , False ) self . response_headers = tuple ( route . get ( \"response_headers\" , {}). items ()) self . private = \"private\" in route self . inputs = route . get ( \"inputs\" , {}) if \"on_invalid\" in route : self . _ params_for_on_invalid = introspect . takes_arguments ( self . on_invalid , * self . AUTO_INCLUDE ) elif self . transform : self . _ params_for_on_invalid = self . _ params_for_transform self . api . http . versions . update ( route . get ( \"versions\" , ( None ,))) self . interface . http = self @property def _ params_for_outputs ( self ) : if not hasattr ( self , \"_params_for_outputs_state\" ) : self . _ params_for_outputs_state = introspect . takes_arguments ( self . outputs , * self . AUTO_INCLUDE ) return self . _ params_for_outputs_state @property def _ params_for_invalid_outputs ( self ) : if not hasattr ( self , \"_params_for_invalid_outputs_state\" ) : self . _ params_for_invalid_outputs_state = introspect . takes_arguments ( self . invalid_outputs , * self . AUTO_INCLUDE ) return self . _ params_for_invalid_outputs_state @property def _ params_for_transform ( self ) : if not hasattr ( self , \"_params_for_transform_state\" ) : self . _ params_for_transform_state = introspect . takes_arguments ( self . transform , * self . AUTO_INCLUDE ) return self . _ params_for_transform_state def gather_parameters ( self , request , response , context , api_version = None , **input_parameters ) : \"\"\"Gathers and returns all parameters that will be used for this endpoint\"\"\" input_parameters . update ( request . params ) if self . parse_body and request . content_length: body = request . bounded_stream content_type , content_params = parse_content_type ( request . content_type ) body_formatter = body and self . inputs . get ( content_type , self . api . http . input_format ( content_type ) ) if body_formatter: body = body_formatter ( body , content_length = request . content_length , **content_params ) if \"body\" in self . all_parameters: input_parameters [ \"body\" ] = body if isinstance ( body , dict ) : input_parameters . update ( body ) elif \"body\" in self . all_parameters: input_parameters [ \"body\" ] = None if \"request\" in self . all_parameters: input_parameters [ \"request\" ] = request if \"response\" in self . all_parameters: input_parameters [ \"response\" ] = response if \"api_version\" in self . all_parameters: input_parameters [ \"api_version\" ] = api_version for parameter , directive in self . directives . items () : arguments = ( self . defaults [ parameter ],) if parameter in self . defaults else () input_parameters [ parameter ] = directive ( * arguments , response = response , request = request , api = self . api , api_version = api_version , context = context , interface = self ) return input_parameters @property def outputs ( self ) : return getattr ( self , \"_outputs\" , self . api . http . output_format ) @outputs . setter def outputs ( self , outputs ) : self . _ outputs = outputs def transform_data ( self , data , request = None , response = None , context = None ) : transform = self . transform if hasattr ( transform , \"context\" ) : self . transform . context = context \"\"\"Runs the transforms specified on this endpoint with the provided data, returning the data modified\"\"\" if transform and not ( isinstance ( transform , type ) and isinstance ( data , transform )) : if self . _ params_for_transform: return transform ( data , **self . _ arguments ( self . _ params_for_transform , request , response ) ) else : return transform ( data ) return data def content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default for this endpoint\"\"\" if callable ( self . outputs . content_type ) : return self . outputs . content_type ( request = request , response = response ) else : return self . outputs . content_type def invalid_content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default on validation errors\"\"\" if callable ( self . invalid_outputs . content_type ) : return self . invalid_outputs . content_type ( request = request , response = response ) else : return self . invalid_outputs . content_type def _ arguments ( self , requested_params , request = None , response = None ) : if requested_params: arguments = {} if \"response\" in requested_params: arguments [ \"response\" ] = response if \"request\" in requested_params: arguments [ \"request\" ] = request return arguments return empty . dict def set_response_defaults ( self , response , request = None ) : \"\"\"Sets up the response defaults that are defined in the URL route\"\"\" for header_name , header_value in self . response_headers: response . set_header ( header_name , header_value ) if self . set_status: response . status = self . set_status response . content_type = self . content_type ( request , response ) def render_errors ( self , errors , request , response ) : data = { \"errors\" : errors } if getattr ( self , \"on_invalid\" , False ) : data = self . on_invalid ( data , **self . _ arguments ( self . _ params_for_on_invalid , request , response ) ) response . status = HTTP_BAD_REQUEST if getattr ( self , \"invalid_outputs\" , False ) : response . content_type = self . invalid_content_type ( request , response ) response . data = self . invalid_outputs ( data , **self . _ arguments ( self . _ params_for_invalid_outputs , request , response ) ) else : response . data = self . outputs ( data , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) def call_function ( self , parameters ) : if not self . interface . takes_kwargs: parameters = { key : value for key , value in parameters . items () if key in self . all_parameters } self . _ rewrite_params ( parameters ) return self . interface ( **parameters ) def render_content ( self , content , context , request , response , **kwargs ) : if hasattr ( content , \"interface\" ) and ( content . interface is True or hasattr ( content . interface , \"http\" ) ) : if content . interface is True : content ( request , response , api_version = None , **kwargs ) else : content . interface . http ( request , response , api_version = None , **kwargs ) return content = self . transform_data ( content , request , response , context ) content = self . outputs ( content , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) if hasattr ( content , \"read\" ) : size = None if hasattr ( content , \"name\" ) and os . path . isfile ( content . name ) : size = os . path . getsize ( content . name ) if request . range and size : start , end = request . range if end < 0 : end = size + end end = min ( end , size ) length = end - start + 1 content . seek ( start ) response . data = content . read ( length ) response . status = falcon . HTTP_206 response . content_range = ( start , end , size ) content . close () else : if size : response . set_stream ( content , size ) else : response . stream = content # pragma : no cover else : response . data = content def __ call__ ( self , request , response , api_version = None , **kwargs ) : context = self . api . context_factory ( response = response , request = request , api = self . api , api_version = api_version , interface = self , ) \"\"\"Call the wrapped function over HTTP pulling information as needed\"\"\" if isinstance ( api_version , str ) and api_version . isdigit () : api_version = int ( api_version ) else : api_version = None if not self . catch_exceptions: exception_types = () else : exception_types = self . api . http . exception_handlers ( api_version ) exception_types = tuple ( exception_types . keys ()) if exception_types else () input_parameters = {} try : self . set_response_defaults ( response , request ) lacks_requirement = self . check_requirements ( request , response , context ) if lacks_requirement: response . data = self . outputs ( lacks_requirement , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) self . api . delete_context ( context , lacks_requirement = lacks_requirement ) return input_parameters = self . gather_parameters ( request , response , context , api_version , **kwargs ) errors = self . validate ( input_parameters , context ) if errors : self . api . delete_context ( context , errors = errors ) return self . render_errors ( errors , request , response ) self . render_content ( self . call_function ( input_parameters ), context , request , response , **kwargs ) except falcon . HTTPNotFound as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) return self . api . http . not_found ( request , response , **kwargs ) except exception_types as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) handler = None exception_type = type ( exception ) if exception_type in exception_types: handler = self . api . http . exception_handlers ( api_version )[ exception_type ][ 0 ] else : for match_exception_type , exception_handlers in tuple ( self . api . http . exception_handlers ( api_version ). items () )[ ::- 1 ] : if isinstance ( exception , match_exception_type ) : for potential_handler in exception_handlers: if not isinstance ( exception , potential_handler . exclude ) : handler = potential_handler if not handler : raise exception handler ( request = request , response = response , exception = exception , **kwargs ) except Exception as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( input_parameters ) self . api . delete_context ( context ) def documentation ( self , add_to = None , version = None , prefix= \"\" , base_url= \"\" , url= \"\" ) : \"\"\"Returns the documentation specific to an HTTP interface\"\"\" doc = OrderedDict () if add_to is None else add_to usage = self . interface . spec . __ doc__ if usage : doc [ \"usage\" ] = usage for example in self . examples : example_text = \"{0}{1}{2}{3}\" . format ( prefix , base_url , \"/v{0}\" . format ( version ) if version else \"\" , url ) if isinstance ( example , str ) : example_text += \"?{0}\" . format ( example ) doc_examples = doc . setdefault ( \"examples\" , []) if not example_text in doc_examples: doc_examples . append ( example_text ) doc = super (). documentation ( doc ) if getattr ( self , \"output_doc\" , \"\" ) : doc [ \"outputs\" ][ \"type\" ] = self . output_doc return doc @ lru_cache () def urls ( self , version = None ) : \"\"\"Returns all URLS that are mapped to this interface\"\"\" urls = [] for _ base_url , routes in self . api . http . routes . items () : for url , methods in routes . items () : for _ method , versions in methods . items () : for interface_version , interface in versions . items () : if interface_version == version and interface == self : if not url in urls : urls . append (( \"/v{0}\" . format ( version ) if version else \"\" ) + url ) return urls def url ( self , version = None , **kwargs ) : \"\"\"Returns the first matching URL found for the specified arguments\"\"\" for url in self . urls ( version ) : if [ key for key in kwargs . keys () if not \"{\" + key + \"}\" in url ] : continue return url . format ( **kwargs ) raise KeyError ( \"URL that takes all provided parameters not found\" ) class ExceptionRaised ( HTTP ) : \"\"\"Defines the interface responsible for taking and transforming exceptions that occur during processing\"\"\" __ slots__ = ( \"handle\" , \"exclude\" ) def __ init__ ( self , route , * args , **kwargs ) : self . handle = route [ \"exceptions\" ] self . exclude = route [ \"exclude\" ] super (). __ init__ ( route , * args , **kwargs ) Variables DOC_TYPE_MAP HTTP_BAD_REQUEST Functions asyncio_call def ( function , * args , ** kwargs ) View Source def asyncio_call ( function , * args , ** kwargs ) : loop = asyncio . get_event_loop () if loop . is_running () : return function ( * args , ** kwargs ) function = asyncio . ensure_future ( function ( * args , ** kwargs ) , loop = loop ) loop . run_until_complete ( function ) return function . result () Classes CLI class ( route , function ) Defines the Interface responsible for exposing functions to the CLI View Source class CLI ( Interface ) : \"\"\" Defines the Interface responsible for exposing functions to the CLI \"\"\" def __init__ ( self , route , function ) : super () . __init__ ( route , function ) if not self . outputs : self . outputs = self . api . cli . output_format self . interface . cli = self self . reaffirm_types = {} use_parameters = list ( self . interface . parameters ) self . additional_options = getattr ( self . interface , \" arg \" , getattr ( self . interface , \" kwarg \" , False ) ) if self . additional_options : use_parameters . append ( self . additional_options ) used_options = { \" h \" , \" help \" } nargs_set = self . interface . takes_args or self . interface . takes_kwargs class CustomArgumentParser ( argparse . ArgumentParser ) : exit_callback = None def exit ( self , status = 0 , message = None ) : if self . exit_callback : self . exit_callback ( message ) super () . exit ( status , message ) self . parser = CustomArgumentParser ( description = route . get ( \" doc \" , self . interface . spec . __doc__ ) ) if \" version \" in route : self . parser . add_argument ( \" -v \" , \" --version \" , action = \" version \" , version = \" {0} {1} \" . format ( route . get ( \" name \" , self . interface . spec . __name__ ) , route [ \" version \" ] ) , ) used_options . update (( \" v \" , \" version \" )) self . context_tranforms = [] for option in use_parameters : if option in self . directives : continue if option in self . interface . required or option == self . additional_options : args = ( option , ) else : short_option = option [ 0 ] while short_option in used_options and len ( short_option ) < len ( option ) : short_option = option [: len ( short_option ) + 1 ] used_options . add ( short_option ) used_options . add ( option ) if short_option != option : args = ( \" -{0} \" . format ( short_option ) , \" --{0} \" . format ( option )) else : args = ( \" --{0} \" . format ( option ) , ) kwargs = {} if option in self . defaults : kwargs [ \" default \" ] = self . defaults [ option ] if option in self . interface . input_transformations : transform = self . interface . input_transformations [ option ] kwargs [ \" type \" ] = transform kwargs [ \" help \" ] = _doc ( transform ) if transform in ( list , tuple ) or isinstance ( transform , types . Multiple ) : kwargs [ \" action \" ] = \" append \" kwargs [ \" type \" ] = Text () self . reaffirm_types [ option ] = transform elif transform == bool or isinstance ( transform , type ( types . boolean )) : kwargs [ \" action \" ] = \" store_true \" self . reaffirm_types [ option ] = transform elif isinstance ( transform , types . OneOf ) : kwargs [ \" choices \" ] = transform . values elif ( option in self . interface . spec . __annotations__ and type ( self . interface . spec . __annotations__ [ option ] ) == str ) : kwargs [ \" help \" ] = option if ( kwargs . get ( \" type \" , None ) == bool or kwargs . get ( \" action \" , None ) == \" store_true \" ) and not kwargs [ \" default \" ]: kwargs [ \" action \" ] = \" store_true \" kwargs . pop ( \" type \" , None ) elif kwargs . get ( \" action \" , None ) == \" store_true \" : kwargs . pop ( \" action \" , None ) if option == self . additional_options : kwargs [ \" nargs \" ] = \" * \" elif ( not nargs_set and kwargs . get ( \" action \" , None ) == \" append \" and not option in self . interface . defaults ) : kwargs [ \" nargs \" ] = \" * \" kwargs . pop ( \" action \" , \"\" ) nargs_set = True self . parser . add_argument ( * args , ** kwargs ) self . api . cli . commands [ route . get ( \" name \" , self . interface . spec . __name__ ) ] = self def output ( self , data , context ) : \"\"\" Outputs the provided data using the transformations and output format specified for this CLI endpoint \"\"\" if self . transform : if hasattr ( self . transform , \" context \" ) : self . transform . context = context data = self . transform ( data ) if hasattr ( data , \" read \" ) : data = data . read () . decode ( \" utf8 \" ) if data is not None : data = self . outputs ( data ) if data : sys . stdout . buffer . write ( data ) if not data . endswith ( b \" \\n \" ) : sys . stdout . buffer . write ( b \" \\n \" ) return data def __str__ ( self ) : return self . parser . description or \"\" def __call__ ( self ) : \"\"\" Calls the wrapped function through the lens of a CLI ran command \"\"\" context = self . api . context_factory ( api = self . api , argparse = self . parser , interface = self ) def exit_callback ( message ) : self . api . delete_context ( context , errors = message ) self . parser . exit_callback = exit_callback self . api . _ensure_started () for requirement in self . requires : conclusion = requirement ( request = sys . argv , module = self . api . module , context = context ) if conclusion and conclusion is not True : self . api . delete_context ( context , lacks_requirement = conclusion ) return self . output ( conclusion , context ) if self . interface . is_method : self . parser . prog = \" %s %s \" % ( self . api . module . __name__ , self . interface . name ) known , unknown = self . parser . parse_known_args () pass_to_function = vars ( known ) for option , directive in self . directives . items () : arguments = ( self . defaults [ option ], ) if option in self . defaults else () pass_to_function [ option ] = directive ( * arguments , api = self . api , argparse = self . parser , context = context , interface = self ) for field , type_handler in self . reaffirm_types . items () : if field in pass_to_function : if not pass_to_function [ field ] and type_handler in ( list , tuple , hug . types . Multiple , ) : pass_to_function [ field ] = type_handler (()) else : pass_to_function [ field ] = self . initialize_handler ( type_handler , pass_to_function [ field ], context = context ) if getattr ( self , \" validate_function \" , False ) : errors = self . validate_function ( pass_to_function ) if errors : self . api . delete_context ( context , errors = errors ) return self . output ( errors , context ) args = None if self . additional_options : args = [] for parameter in self . interface . parameters : if parameter in pass_to_function : args . append ( pass_to_function . pop ( parameter )) args . extend ( pass_to_function . pop ( self . additional_options , ())) if self . interface . takes_kwargs : add_options_to = None for option in unknown : if option . startswith ( \" -- \" ) : if add_options_to : value = pass_to_function [ add_options_to ] if len ( value ) == 1 : pass_to_function [ add_options_to ] = value [ 0 ] elif value == []: pass_to_function [ add_options_to ] = True add_options_to = option [ 2 :] pass_to_function . setdefault ( add_options_to , [] ) elif add_options_to : pass_to_function [ add_options_to ]. append ( option ) self . _rewrite_params ( pass_to_function ) try : if args : result = self . output ( self . interface ( * args , ** pass_to_function ) , context ) else : result = self . output ( self . interface ( ** pass_to_function ) , context ) except Exception as exception : self . cleanup_parameters ( pass_to_function , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( pass_to_function ) self . api . delete_context ( context ) return result Ancestors (in MRO) hug.interface.Interface ExceptionRaised class ( route , * args , ** kwargs ) Defines the interface responsible for taking and transforming exceptions that occur during processing View Source class ExceptionRaised ( HTTP ) : \"\"\" Defines the interface responsible for taking and transforming exceptions that occur during processing \"\"\" __slots__ = ( \" handle \" , \" exclude \" ) def __init__ ( self , route , * args , ** kwargs ) : self . handle = route [ \" exceptions \" ] self . exclude = route [ \" exclude \" ] super () . __init__ ( route , * args , ** kwargs ) Ancestors (in MRO) hug.interface.HTTP hug.interface.Interface HTTP class ( route , function , catch_exceptions = True ) Defines the interface responsible for wrapping functions and exposing them via HTTP based on the route View Source class HTTP ( Interface ) : \"\"\"Defines the interface responsible for wrapping functions and exposing them via HTTP based on the route\"\"\" __ slots__ = ( \"_params_for_outputs_state\" , \"_params_for_invalid_outputs_state\" , \"_params_for_transform_state\" , \"_params_for_on_invalid\" , \"set_status\" , \"response_headers\" , \"transform\" , \"input_transformations\" , \"examples\" , \"wrapped\" , \"catch_exceptions\" , \"parse_body\" , \"private\" , \"on_invalid\" , \"inputs\" , ) AUTO_INCLUDE = { \"request\" , \"response\" } def __ init__ ( self , route , function , catch_exceptions = True ) : super (). __ init__ ( route , function ) self . catch_exceptions = catch_exceptions self . parse_body = \"parse_body\" in route self . set_status = route . get ( \"status\" , False ) self . response_headers = tuple ( route . get ( \"response_headers\" , {}). items ()) self . private = \"private\" in route self . inputs = route . get ( \"inputs\" , {}) if \"on_invalid\" in route : self . _ params_for_on_invalid = introspect . takes_arguments ( self . on_invalid , * self . AUTO_INCLUDE ) elif self . transform : self . _ params_for_on_invalid = self . _ params_for_transform self . api . http . versions . update ( route . get ( \"versions\" , ( None ,))) self . interface . http = self @property def _ params_for_outputs ( self ) : if not hasattr ( self , \"_params_for_outputs_state\" ) : self . _ params_for_outputs_state = introspect . takes_arguments ( self . outputs , * self . AUTO_INCLUDE ) return self . _ params_for_outputs_state @property def _ params_for_invalid_outputs ( self ) : if not hasattr ( self , \"_params_for_invalid_outputs_state\" ) : self . _ params_for_invalid_outputs_state = introspect . takes_arguments ( self . invalid_outputs , * self . AUTO_INCLUDE ) return self . _ params_for_invalid_outputs_state @property def _ params_for_transform ( self ) : if not hasattr ( self , \"_params_for_transform_state\" ) : self . _ params_for_transform_state = introspect . takes_arguments ( self . transform , * self . AUTO_INCLUDE ) return self . _ params_for_transform_state def gather_parameters ( self , request , response , context , api_version = None , **input_parameters ) : \"\"\"Gathers and returns all parameters that will be used for this endpoint\"\"\" input_parameters . update ( request . params ) if self . parse_body and request . content_length: body = request . bounded_stream content_type , content_params = parse_content_type ( request . content_type ) body_formatter = body and self . inputs . get ( content_type , self . api . http . input_format ( content_type ) ) if body_formatter: body = body_formatter ( body , content_length = request . content_length , **content_params ) if \"body\" in self . all_parameters: input_parameters [ \"body\" ] = body if isinstance ( body , dict ) : input_parameters . update ( body ) elif \"body\" in self . all_parameters: input_parameters [ \"body\" ] = None if \"request\" in self . all_parameters: input_parameters [ \"request\" ] = request if \"response\" in self . all_parameters: input_parameters [ \"response\" ] = response if \"api_version\" in self . all_parameters: input_parameters [ \"api_version\" ] = api_version for parameter , directive in self . directives . items () : arguments = ( self . defaults [ parameter ],) if parameter in self . defaults else () input_parameters [ parameter ] = directive ( * arguments , response = response , request = request , api = self . api , api_version = api_version , context = context , interface = self ) return input_parameters @property def outputs ( self ) : return getattr ( self , \"_outputs\" , self . api . http . output_format ) @outputs . setter def outputs ( self , outputs ) : self . _ outputs = outputs def transform_data ( self , data , request = None , response = None , context = None ) : transform = self . transform if hasattr ( transform , \"context\" ) : self . transform . context = context \"\"\"Runs the transforms specified on this endpoint with the provided data, returning the data modified\"\"\" if transform and not ( isinstance ( transform , type ) and isinstance ( data , transform )) : if self . _ params_for_transform: return transform ( data , **self . _ arguments ( self . _ params_for_transform , request , response ) ) else : return transform ( data ) return data def content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default for this endpoint\"\"\" if callable ( self . outputs . content_type ) : return self . outputs . content_type ( request = request , response = response ) else : return self . outputs . content_type def invalid_content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default on validation errors\"\"\" if callable ( self . invalid_outputs . content_type ) : return self . invalid_outputs . content_type ( request = request , response = response ) else : return self . invalid_outputs . content_type def _ arguments ( self , requested_params , request = None , response = None ) : if requested_params: arguments = {} if \"response\" in requested_params: arguments [ \"response\" ] = response if \"request\" in requested_params: arguments [ \"request\" ] = request return arguments return empty . dict def set_response_defaults ( self , response , request = None ) : \"\"\"Sets up the response defaults that are defined in the URL route\"\"\" for header_name , header_value in self . response_headers: response . set_header ( header_name , header_value ) if self . set_status: response . status = self . set_status response . content_type = self . content_type ( request , response ) def render_errors ( self , errors , request , response ) : data = { \"errors\" : errors } if getattr ( self , \"on_invalid\" , False ) : data = self . on_invalid ( data , **self . _ arguments ( self . _ params_for_on_invalid , request , response ) ) response . status = HTTP_BAD_REQUEST if getattr ( self , \"invalid_outputs\" , False ) : response . content_type = self . invalid_content_type ( request , response ) response . data = self . invalid_outputs ( data , **self . _ arguments ( self . _ params_for_invalid_outputs , request , response ) ) else : response . data = self . outputs ( data , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) def call_function ( self , parameters ) : if not self . interface . takes_kwargs: parameters = { key : value for key , value in parameters . items () if key in self . all_parameters } self . _ rewrite_params ( parameters ) return self . interface ( **parameters ) def render_content ( self , content , context , request , response , **kwargs ) : if hasattr ( content , \"interface\" ) and ( content . interface is True or hasattr ( content . interface , \"http\" ) ) : if content . interface is True : content ( request , response , api_version = None , **kwargs ) else : content . interface . http ( request , response , api_version = None , **kwargs ) return content = self . transform_data ( content , request , response , context ) content = self . outputs ( content , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) if hasattr ( content , \"read\" ) : size = None if hasattr ( content , \"name\" ) and os . path . isfile ( content . name ) : size = os . path . getsize ( content . name ) if request . range and size : start , end = request . range if end < 0 : end = size + end end = min ( end , size ) length = end - start + 1 content . seek ( start ) response . data = content . read ( length ) response . status = falcon . HTTP_206 response . content_range = ( start , end , size ) content . close () else : if size : response . set_stream ( content , size ) else : response . stream = content # pragma : no cover else : response . data = content def __ call__ ( self , request , response , api_version = None , **kwargs ) : context = self . api . context_factory ( response = response , request = request , api = self . api , api_version = api_version , interface = self , ) \"\"\"Call the wrapped function over HTTP pulling information as needed\"\"\" if isinstance ( api_version , str ) and api_version . isdigit () : api_version = int ( api_version ) else : api_version = None if not self . catch_exceptions: exception_types = () else : exception_types = self . api . http . exception_handlers ( api_version ) exception_types = tuple ( exception_types . keys ()) if exception_types else () input_parameters = {} try : self . set_response_defaults ( response , request ) lacks_requirement = self . check_requirements ( request , response , context ) if lacks_requirement: response . data = self . outputs ( lacks_requirement , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) self . api . delete_context ( context , lacks_requirement = lacks_requirement ) return input_parameters = self . gather_parameters ( request , response , context , api_version , **kwargs ) errors = self . validate ( input_parameters , context ) if errors : self . api . delete_context ( context , errors = errors ) return self . render_errors ( errors , request , response ) self . render_content ( self . call_function ( input_parameters ), context , request , response , **kwargs ) except falcon . HTTPNotFound as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) return self . api . http . not_found ( request , response , **kwargs ) except exception_types as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) handler = None exception_type = type ( exception ) if exception_type in exception_types: handler = self . api . http . exception_handlers ( api_version )[ exception_type ][ 0 ] else : for match_exception_type , exception_handlers in tuple ( self . api . http . exception_handlers ( api_version ). items () )[ ::- 1 ] : if isinstance ( exception , match_exception_type ) : for potential_handler in exception_handlers: if not isinstance ( exception , potential_handler . exclude ) : handler = potential_handler if not handler : raise exception handler ( request = request , response = response , exception = exception , **kwargs ) except Exception as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( input_parameters ) self . api . delete_context ( context ) def documentation ( self , add_to = None , version = None , prefix= \"\" , base_url= \"\" , url= \"\" ) : \"\"\"Returns the documentation specific to an HTTP interface\"\"\" doc = OrderedDict () if add_to is None else add_to usage = self . interface . spec . __ doc__ if usage : doc [ \"usage\" ] = usage for example in self . examples : example_text = \"{0}{1}{2}{3}\" . format ( prefix , base_url , \"/v{0}\" . format ( version ) if version else \"\" , url ) if isinstance ( example , str ) : example_text += \"?{0}\" . format ( example ) doc_examples = doc . setdefault ( \"examples\" , []) if not example_text in doc_examples: doc_examples . append ( example_text ) doc = super (). documentation ( doc ) if getattr ( self , \"output_doc\" , \"\" ) : doc [ \"outputs\" ][ \"type\" ] = self . output_doc return doc @ lru_cache () def urls ( self , version = None ) : \"\"\"Returns all URLS that are mapped to this interface\"\"\" urls = [] for _ base_url , routes in self . api . http . routes . items () : for url , methods in routes . items () : for _ method , versions in methods . items () : for interface_version , interface in versions . items () : if interface_version == version and interface == self : if not url in urls : urls . append (( \"/v{0}\" . format ( version ) if version else \"\" ) + url ) return urls def url ( self , version = None , **kwargs ) : \"\"\"Returns the first matching URL found for the specified arguments\"\"\" for url in self . urls ( version ) : if [ key for key in kwargs . keys () if not \"{\" + key + \"}\" in url ] : continue return url . format ( **kwargs ) raise KeyError ( \"URL that takes all provided parameters not found\" ) Ancestors (in MRO) hug.interface.Interface Descendants hug.interface.ExceptionRaised Class variables AUTO_INCLUDE Interface class ( route , function ) Defines the basic hug interface object, which is responsible for wrapping a user defined function and providing all the info requested in the function as well as the route A Interface object should be created for every kind of protocal hug supports View Source class Interface ( object ) : \"\"\" Defines the basic hug interface object, which is responsible for wrapping a user defined function and providing all the info requested in the function as well as the route A Interface object should be created for every kind of protocal hug supports \"\"\" __slots__ = ( \" interface \" , \" _api \" , \" defaults \" , \" parameters \" , \" required \" , \" _outputs \" , \" on_invalid \" , \" requires \" , \" validate_function \" , \" transform \" , \" examples \" , \" output_doc \" , \" wrapped \" , \" directives \" , \" all_parameters \" , \" raise_on_invalid \" , \" invalid_outputs \" , \" map_params \" , \" input_transformations \" , ) def __init__ ( self , route , function ) : if route . get ( \" api \" , None ) : self . _api = route [ \" api \" ] if \" examples \" in route : self . examples = route [ \" examples \" ] function_args = route . get ( \" args \" ) if not hasattr ( function , \" interface \" ) : function . __dict__ [ \" interface \" ] = Interfaces ( function , function_args ) self . interface = function . interface self . requires = route . get ( \" requires \" , ()) if \" validate \" in route : self . validate_function = route [ \" validate \" ] if \" output_invalid \" in route : self . invalid_outputs = route [ \" output_invalid \" ] if not \" parameters \" in route : self . defaults = self . interface . defaults self . parameters = self . interface . parameters self . all_parameters = self . interface . all_parameters self . required = self . interface . required else : self . defaults = route . get ( \" defaults \" , {} ) self . parameters = tuple ( route [ \" parameters \" ] ) self . all_parameters = set ( route [ \" parameters \" ] ) self . required = tuple ( [ parameter for parameter in self . parameters if parameter not in self . defaults ] ) if \" map_params \" in route : self . map_params = route [ \" map_params \" ] for interface_name , internal_name in self . map_params . items () : if internal_name in self . defaults : self . defaults [ interface_name ] = self . defaults . pop ( internal_name ) if internal_name in self . parameters : self . parameters = [ interface_name if param == internal_name else param for param in self . parameters ] if internal_name in self . all_parameters : self . all_parameters . remove ( internal_name ) self . all_parameters . add ( interface_name ) if internal_name in self . required : self . required = tuple ( [ interface_name if param == internal_name else param for param in self . required ] ) reverse_mapping = { internal : interface for interface , internal in self . map_params . items () } self . input_transformations = { reverse_mapping . get ( name , name ) : transform for name , transform in self . interface . input_transformations . items () } else : self . map_params = {} self . input_transformations = self . interface . input_transformations if \" output \" in route : self . outputs = route [ \" output \" ] self . transform = route . get ( \" transform \" , None ) if self . transform is None and not isinstance ( self . interface . transform , ( str , type ( None ))) : self . transform = self . interface . transform if hasattr ( self . transform , \" dump \" ) : self . transform = MarshmallowReturnSchema ( self . transform ) self . output_doc = self . transform . __doc__ elif self . transform or self . interface . transform : output_doc = self . transform or self . interface . transform self . output_doc = output_doc if type ( output_doc ) is str else _doc ( output_doc ) self . raise_on_invalid = route . get ( \" raise_on_invalid \" , False ) if \" on_invalid \" in route : self . on_invalid = route [ \" on_invalid \" ] elif self . transform : self . on_invalid = self . transform defined_directives = self . api . directives () used_directives = set ( self . parameters ) . intersection ( defined_directives ) self . directives = { directive_name : defined_directives [ directive_name ] for directive_name in used_directives } self . directives . update ( self . interface . directives ) @ property def api ( self ) : return getattr ( self , \" _api \" , self . interface . api ) @ property def outputs ( self ) : return getattr ( self , \" _outputs \" , None ) @ outputs . setter def outputs ( self , outputs ) : self . _outputs = outputs # pragma : no cover - generally re - implemented by sub classes def validate ( self , input_parameters , context ) : \"\"\" Runs all set type transformers / validators against the provided input parameters and returns any errors \"\"\" errors = {} for key , type_handler in self . input_transformations . items () : if self . raise_on_invalid : if key in input_parameters : input_parameters [ key ] = self . initialize_handler ( type_handler , input_parameters [ key ], context = context ) else : try : if key in input_parameters : input_parameters [ key ] = self . initialize_handler ( type_handler , input_parameters [ key ], context = context ) except InvalidTypeData as error : errors [ key ] = error . reasons or str ( error ) except Exception as error : if hasattr ( error , \" args \" ) and error . args : errors [ key ] = error . args [ 0 ] else : errors [ key ] = str ( error ) for require in self . required : if not require in input_parameters : errors [ require ] = \" Required parameter '{}' not supplied \" . format ( require ) if not errors and getattr ( self , \" validate_function \" , False ) : errors = self . validate_function ( input_parameters ) return errors def check_requirements ( self , request = None , response = None , context = None ) : \"\"\" Checks to see if all requirements set pass if all requirements pass nothing will be returned otherwise , the error reported will be returned \"\"\" for requirement in self . requires : conclusion = requirement ( response = response , request = request , context = context , module = self . api . module ) if conclusion and conclusion is not True : return conclusion def documentation ( self , add_to = None ) : \"\"\" Produces general documentation for the interface \"\"\" doc = OrderedDict if add_to is None else add_to usage = self . interface . spec . __doc__ if usage : doc [ \" usage \" ] = usage if getattr ( self , \" requires \" , None ) : doc [ \" requires \" ] = [ getattr ( requirement , \" __doc__ \" , requirement . __name__ ) for requirement in self . requires ] doc [ \" outputs \" ] = OrderedDict () doc [ \" outputs \" ][ \" format \" ] = _doc ( self . outputs ) doc [ \" outputs \" ][ \" content_type \" ] = self . outputs . content_type parameters = [ param for param in self . parameters if not param in ( \" request \" , \" response \" , \" self \" ) and not param in ( \" api_version \" , \" body \" ) and not param . startswith ( \" hug_ \" ) and not hasattr ( param , \" directive \" ) ] if parameters : inputs = doc . setdefault ( \" inputs \" , OrderedDict ()) types = self . interface . spec . __annotations__ for argument in parameters : kind = types . get ( self . _remap_entry ( argument ) , text ) if getattr ( kind , \" directive \" , None ) is True : continue input_definition = inputs . setdefault ( argument , OrderedDict ()) input_definition [ \" type \" ] = kind if isinstance ( kind , str ) else _doc ( kind ) default = self . defaults . get ( argument , None ) if default is not None : input_definition [ \" default \" ] = default return doc def _rewrite_params ( self , params ) : for interface_name , internal_name in self . map_params . items () : if interface_name in params : params [ internal_name ] = params . pop ( interface_name ) def _remap_entry ( self , interface_name ) : return self . map_params . get ( interface_name , interface_name ) @ staticmethod def cleanup_parameters ( parameters , exception = None ) : for _parameter , directive in parameters . items () : if hasattr ( directive , \" cleanup \" ) : directive . cleanup ( exception = exception ) @ staticmethod def initialize_handler ( handler , value , context ) : try : # It ' s easier to ask for forgiveness than for permission return handler ( value , context = context ) except TypeError : return handler ( value ) Descendants hug.interface.Local hug.interface.CLI hug.interface.HTTP Interfaces class ( function , args = None ) Defines the per-function singleton applied to hugged functions defining common data needed by all interfaces View Source class Interfaces ( object ) : \"\"\" Defines the per-function singleton applied to hugged functions defining common data needed by all interfaces \"\"\" def __init__ ( self , function , args = None ) : self . api = hug . api . from_object ( function ) self . spec = getattr ( function , \" original \" , function ) self . arguments = introspect . arguments ( function ) self . name = introspect . name ( function ) self . _function = function self . is_coroutine = introspect . is_coroutine ( self . spec ) if self . is_coroutine : self . spec = getattr ( self . spec , \" __wrapped__ \" , self . spec ) self . takes_args = introspect . takes_args ( self . spec ) self . takes_kwargs = introspect . takes_kwargs ( self . spec ) self . parameters = list ( introspect . arguments ( self . spec , self . takes_kwargs + self . takes_args )) if self . takes_kwargs : self . kwarg = self . parameters . pop ( - 1 ) if self . takes_args : self . arg = self . parameters . pop ( - 1 ) self . parameters = tuple ( self . parameters ) self . defaults = dict ( zip ( reversed ( self . parameters ) , reversed ( self . spec . __defaults__ or ()))) self . required = self . parameters [: - ( len ( self . spec . __defaults__ or ())) or None ] self . is_method = introspect . is_method ( self . spec ) or introspect . is_method ( function ) if self . is_method : self . required = self . required [ 1 :] self . parameters = self . parameters [ 1 :] self . all_parameters = set ( self . parameters ) if self . spec is not function : self . all_parameters . update ( self . arguments ) if args is not None : transformers = args else : transformers = self . spec . __annotations__ self . transform = transformers . get ( \" return \" , None ) self . directives = {} self . input_transformations = {} for name , transformer in transformers . items () : if isinstance ( transformer , str ) : continue elif hasattr ( transformer , \" directive \" ) : self . directives [ name ] = transformer continue if hasattr ( transformer , \" from_string \" ) : transformer = transformer . from_string elif hasattr ( transformer , \" load \" ) : transformer = MarshmallowInputSchema ( transformer ) elif hasattr ( transformer , \" deserialize \" ) : transformer = transformer . deserialize self . input_transformations [ name ] = transformer def __call__ ( __hug_internal_self , * args , ** kwargs ) : # noqa : N805 \"\"\"\" Calls the wrapped function , uses __hug_internal_self incase self is passed in as a kwarg from the wrapper \"\"\" if not __hug_internal_self . is_coroutine : return __hug_internal_self . _function ( * args , ** kwargs ) return asyncio_call ( __hug_internal_self . _function , * args , ** kwargs ) Local class ( route , function ) Defines the Interface responsible for exposing functions locally Ancestors (in MRO) hug.interface.Interface","title":"Interface"},{"location":"reference/hug/interface/#module-huginterface","text":"hug/interface.py Defines the various interface hug provides to expose routes to functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\"hug/interface.py Defines the various interface hug provides to expose routes to functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software \"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \" AS IS \", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from __ future__ import absolute_import import argparse import asyncio import os import sys from collections import OrderedDict from functools import lru_cache , partial , wraps import falcon from falcon import HTTP_BAD_REQUEST import hug . _ empty as empty import hug . api import hug . output_format import hug . types as types from hug import introspect from hug . exceptions import InvalidTypeData from hug . format import parse_content_type from hug . types import ( MarshmallowInputSchema , MarshmallowReturnSchema , Multiple , OneOf , SmartBoolean , Text , text , ) DOC_TYPE_MAP = { str : \"String\" , bool : \"Boolean\" , list : \"Multiple\" , int : \"Integer\" , float : \"Float\" } def _ doc ( kind ) : return DOC_TYPE_MAP . get ( kind , kind . __ doc__ ) def asyncio_call ( function , * args , **kwargs ) : loop = asyncio . get_event_loop () if loop . is_running () : return function ( * args , **kwargs ) function = asyncio . ensure_future ( function ( * args , **kwargs ), loop = loop ) loop . run_until_complete ( function ) return function . result () class Interfaces ( object ) : \"\"\"Defines the per-function singleton applied to hugged functions defining common data needed by all interfaces\"\"\" def __ init__ ( self , function , args = None ) : self . api = hug . api . from_object ( function ) self . spec = getattr ( function , \"original\" , function ) self . arguments = introspect . arguments ( function ) self . name = introspect . name ( function ) self . _ function = function self . is_coroutine = introspect . is_coroutine ( self . spec ) if self . is_coroutine: self . spec = getattr ( self . spec , \"__wrapped__\" , self . spec ) self . takes_args = introspect . takes_args ( self . spec ) self . takes_kwargs = introspect . takes_kwargs ( self . spec ) self . parameters = list ( introspect . arguments ( self . spec , self . takes_kwargs + self . takes_args )) if self . takes_kwargs: self . kwarg = self . parameters . pop ( - 1 ) if self . takes_args: self . arg = self . parameters . pop ( - 1 ) self . parameters = tuple ( self . parameters ) self . defaults = dict ( zip ( reversed ( self . parameters ), reversed ( self . spec . __ defaults__ or ()))) self . required = self . parameters [ : - ( len ( self . spec . __ defaults__ or ())) or None ] self . is_method = introspect . is_method ( self . spec ) or introspect . is_method ( function ) if self . is_method: self . required = self . required [ 1 : ] self . parameters = self . parameters [ 1 : ] self . all_parameters = set ( self . parameters ) if self . spec is not function : self . all_parameters . update ( self . arguments ) if args is not None : transformers = args else : transformers = self . spec . __ annotations__ self . transform = transformers . get ( \"return\" , None ) self . directives = {} self . input_transformations = {} for name , transformer in transformers . items () : if isinstance ( transformer , str ) : continue elif hasattr ( transformer , \"directive\" ) : self . directives [ name ] = transformer continue if hasattr ( transformer , \"from_string\" ) : transformer = transformer . from_string elif hasattr ( transformer , \"load\" ) : transformer = MarshmallowInputSchema ( transformer ) elif hasattr ( transformer , \"deserialize\" ) : transformer = transformer . deserialize self . input_transformations [ name ] = transformer def __ call__ ( __ hug_internal_self , * args , **kwargs ) : # noqa : N805 \"\"\"\" Calls the wrapped function , uses __ hug_internal_self incase self is passed in as a kwarg from the wrapper \"\"\" if not __hug_internal_self.is_coroutine: return __hug_internal_self._function(*args, **kwargs) return asyncio_call(__hug_internal_self._function, *args, **kwargs) class Interface(object): \"\"\" Defines the basic hug interface object , which is responsible for wrapping a user defined function and providing all the info requested in the function as well as the route A Interface object should be created for every kind of protocal hug supports \"\"\" __slots__ = ( \" interface \", \" _ api \", \" defaults \", \" parameters \", \" required \", \" _ outputs \", \" on_invalid \", \" requires \", \" validate_function \", \" transform \", \" examples \", \" output_doc \", \" wrapped \", \" directives \", \" all_parameters \", \" raise_on_invalid \", \" invalid_outputs \", \" map_params \", \" input_transformations \", ) def __init__(self, route, function): if route.get(\" api \", None): self._api = route[\" api \"] if \" examples \" in route: self.examples = route[\" examples \"] function_args = route.get(\" args \") if not hasattr(function, \" interface \"): function.__dict__[\" interface \"] = Interfaces(function, function_args) self.interface = function.interface self.requires = route.get(\" requires \", ()) if \" validate \" in route: self.validate_function = route[\" validate \"] if \" output_invalid \" in route: self.invalid_outputs = route[\" output_invalid \"] if not \" parameters \" in route: self.defaults = self.interface.defaults self.parameters = self.interface.parameters self.all_parameters = self.interface.all_parameters self.required = self.interface.required else: self.defaults = route.get(\" defaults \", {}) self.parameters = tuple(route[\" parameters \"]) self.all_parameters = set(route[\" parameters \"]) self.required = tuple( [parameter for parameter in self.parameters if parameter not in self.defaults] ) if \" map_params \" in route: self.map_params = route[\" map_params \"] for interface_name, internal_name in self.map_params.items(): if internal_name in self.defaults: self.defaults[interface_name] = self.defaults.pop(internal_name) if internal_name in self.parameters: self.parameters = [ interface_name if param == internal_name else param for param in self.parameters ] if internal_name in self.all_parameters: self.all_parameters.remove(internal_name) self.all_parameters.add(interface_name) if internal_name in self.required: self.required = tuple( [ interface_name if param == internal_name else param for param in self.required ] ) reverse_mapping = { internal: interface for interface, internal in self.map_params.items() } self.input_transformations = { reverse_mapping.get(name, name): transform for name, transform in self.interface.input_transformations.items() } else: self.map_params = {} self.input_transformations = self.interface.input_transformations if \" output \" in route: self.outputs = route[\" output \"] self.transform = route.get(\" transform \", None) if self.transform is None and not isinstance(self.interface.transform, (str, type(None))): self.transform = self.interface.transform if hasattr(self.transform, \" dump \"): self.transform = MarshmallowReturnSchema(self.transform) self.output_doc = self.transform.__doc__ elif self.transform or self.interface.transform: output_doc = self.transform or self.interface.transform self.output_doc = output_doc if type(output_doc) is str else _doc(output_doc) self.raise_on_invalid = route.get(\" raise_on_invalid \", False) if \" on_invalid \" in route: self.on_invalid = route[\" on_invalid \"] elif self.transform: self.on_invalid = self.transform defined_directives = self.api.directives() used_directives = set(self.parameters).intersection(defined_directives) self.directives = { directive_name: defined_directives[directive_name] for directive_name in used_directives } self.directives.update(self.interface.directives) @property def api(self): return getattr(self, \" _ api \", self.interface.api) @property def outputs(self): return getattr(self, \" _ outputs \", None) @outputs.setter def outputs(self, outputs): self._outputs = outputs # pragma: no cover - generally re-implemented by sub classes def validate(self, input_parameters, context): \"\"\" Runs all set type transformers / validators against the provided input parameters and returns any errors \"\"\" errors = {} for key, type_handler in self.input_transformations.items(): if self.raise_on_invalid: if key in input_parameters: input_parameters[key] = self.initialize_handler( type_handler, input_parameters[key], context=context ) else: try: if key in input_parameters: input_parameters[key] = self.initialize_handler( type_handler, input_parameters[key], context=context ) except InvalidTypeData as error: errors[key] = error.reasons or str(error) except Exception as error: if hasattr(error, \" args \") and error.args: errors[key] = error.args[0] else: errors[key] = str(error) for require in self.required: if not require in input_parameters: errors[require] = \" Required parameter '{}' not supplied \".format(require) if not errors and getattr(self, \" validate_function \", False): errors = self.validate_function(input_parameters) return errors def check_requirements(self, request=None, response=None, context=None): \"\"\" Checks to see if all requirements set pass if all requirements pass nothing will be returned otherwise , the error reported will be returned \"\"\" for requirement in self.requires: conclusion = requirement( response=response, request=request, context=context, module=self.api.module ) if conclusion and conclusion is not True: return conclusion def documentation(self, add_to=None): \"\"\" Produces general documentation for the interface \"\"\" doc = OrderedDict if add_to is None else add_to usage = self.interface.spec.__doc__ if usage: doc[\" usage \"] = usage if getattr(self, \" requires \", None): doc[\" requires \"] = [ getattr(requirement, \" __ doc__ \", requirement.__name__) for requirement in self.requires ] doc[\" outputs \"] = OrderedDict() doc[\" outputs \"][\" format \"] = _doc(self.outputs) doc[\" outputs \"][\" content_type \"] = self.outputs.content_type parameters = [ param for param in self.parameters if not param in (\" request \", \" response \", \" self \") and not param in (\" api_version \", \" body \") and not param.startswith(\" hug_ \") and not hasattr(param, \" directive \") ] if parameters: inputs = doc.setdefault(\" inputs \", OrderedDict()) types = self.interface.spec.__annotations__ for argument in parameters: kind = types.get(self._remap_entry(argument), text) if getattr(kind, \" directive \", None) is True: continue input_definition = inputs.setdefault(argument, OrderedDict()) input_definition[\" type \"] = kind if isinstance(kind, str) else _doc(kind) default = self.defaults.get(argument, None) if default is not None: input_definition[\" default \"] = default return doc def _rewrite_params(self, params): for interface_name, internal_name in self.map_params.items(): if interface_name in params: params[internal_name] = params.pop(interface_name) def _remap_entry(self, interface_name): return self.map_params.get(interface_name, interface_name) @staticmethod def cleanup_parameters(parameters, exception=None): for _parameter, directive in parameters.items(): if hasattr(directive, \" cleanup \"): directive.cleanup(exception=exception) @staticmethod def initialize_handler(handler, value, context): try: # It's easier to ask for forgiveness than for permission return handler(value, context=context) except TypeError: return handler(value) class Local(Interface): \"\"\" Defines the Interface responsible for exposing functions locally \"\"\" __slots__ = (\" skip_directives \", \" skip_validation \", \" version \") def __init__(self, route, function): super().__init__(route, function) self.version = route.get(\" version \", None) if \" skip_directives \" in route: self.skip_directives = True if \" skip_validation \" in route: self.skip_validation = True self.interface.local = self def __get__(self, instance, kind): \"\"\" Support instance methods \"\"\" return partial(self.__call__, instance) if instance else self.__call__ @property def __name__(self): return self.interface.spec.__name__ @property def __module__(self): return self.interface.spec.__module__ def __call__(self, *args, **kwargs): context = self.api.context_factory(api=self.api, api_version=self.version, interface=self) \"\"\" Defines how calling the function locally should be handled \"\"\" for _requirement in self.requires: lacks_requirement = self.check_requirements(context=context) if lacks_requirement: self.api.delete_context(context, lacks_requirement=lacks_requirement) return self.outputs(lacks_requirement) if self.outputs else lacks_requirement for index, argument in enumerate(args): kwargs[self.parameters[index]] = argument if not getattr(self, \" skip_directives \", False): for parameter, directive in self.directives.items(): if parameter in kwargs: continue arguments = (self.defaults[parameter],) if parameter in self.defaults else () kwargs[parameter] = directive( *arguments, api=self.api, api_version=self.version, interface=self, context=context ) if not getattr(self, \" skip_validation \", False): errors = self.validate(kwargs, context) if errors: errors = {\" errors \": errors} if getattr(self, \" on_invalid \", False): errors = self.on_invalid(errors) outputs = getattr(self, \" invalid_outputs \", self.outputs) self.api.delete_context(context, errors=errors) return outputs(errors) if outputs else errors self._rewrite_params(kwargs) try: result = self.interface(**kwargs) if self.transform: if hasattr(self.transform, \" context \"): self.transform.context = context result = self.transform(result) except Exception as exception: self.cleanup_parameters(kwargs, exception=exception) self.api.delete_context(context, exception=exception) raise exception self.cleanup_parameters(kwargs) self.api.delete_context(context) return self.outputs(result) if self.outputs else result class CLI(Interface): \"\"\" Defines the Interface responsible for exposing functions to the CLI \"\"\" def __init__(self, route, function): super().__init__(route, function) if not self.outputs: self.outputs = self.api.cli.output_format self.interface.cli = self self.reaffirm_types = {} use_parameters = list(self.interface.parameters) self.additional_options = getattr( self.interface, \" arg \", getattr(self.interface, \" kwarg \", False) ) if self.additional_options: use_parameters.append(self.additional_options) used_options = {\" h \", \" help \"} nargs_set = self.interface.takes_args or self.interface.takes_kwargs class CustomArgumentParser(argparse.ArgumentParser): exit_callback = None def exit(self, status=0, message=None): if self.exit_callback: self.exit_callback(message) super().exit(status, message) self.parser = CustomArgumentParser( description=route.get(\" doc \", self.interface.spec.__doc__) ) if \" version \" in route: self.parser.add_argument( \" - v \", \" --version \", action=\" version \", version=\" { 0 } { 1 } \".format( route.get(\" name \", self.interface.spec.__name__), route[\" version \"] ), ) used_options.update((\" v \", \" version \")) self.context_tranforms = [] for option in use_parameters: if option in self.directives: continue if option in self.interface.required or option == self.additional_options: args = (option,) else: short_option = option[0] while short_option in used_options and len(short_option) < len(option): short_option = option[: len(short_option) + 1] used_options.add(short_option) used_options.add(option) if short_option != option: args = (\" - { 0 } \".format(short_option), \" -- { 0 } \".format(option)) else: args = (\" -- { 0 } \".format(option),) kwargs = {} if option in self.defaults: kwargs[\" default \"] = self.defaults[option] if option in self.interface.input_transformations: transform = self.interface.input_transformations[option] kwargs[\" type \"] = transform kwargs[\" help \"] = _doc(transform) if transform in (list, tuple) or isinstance(transform, types.Multiple): kwargs[\" action \"] = \" append \" kwargs[\" type \"] = Text() self.reaffirm_types[option] = transform elif transform == bool or isinstance(transform, type(types.boolean)): kwargs[\" action \"] = \" store_true \" self.reaffirm_types[option] = transform elif isinstance(transform, types.OneOf): kwargs[\" choices \"] = transform.values elif ( option in self.interface.spec.__annotations__ and type(self.interface.spec.__annotations__[option]) == str ): kwargs[\" help \"] = option if ( kwargs.get(\" type \", None) == bool or kwargs.get(\" action \", None) == \" store_true \" ) and not kwargs[\" default \"]: kwargs[\" action \"] = \" store_true \" kwargs.pop(\" type \", None) elif kwargs.get(\" action \", None) == \" store_true \": kwargs.pop(\" action \", None) if option == self.additional_options: kwargs[\" nargs \"] = \" * \" elif ( not nargs_set and kwargs.get(\" action \", None) == \" append \" and not option in self.interface.defaults ): kwargs[\" nargs \"] = \" * \" kwargs.pop(\" action \", \"\") nargs_set = True self.parser.add_argument(*args, **kwargs) self.api.cli.commands[route.get(\" name \", self.interface.spec.__name__)] = self def output(self, data, context): \"\"\" Outputs the provided data using the transformations and output format specified for this CLI endpoint \"\"\" if self.transform: if hasattr(self.transform, \" context \"): self.transform.context = context data = self.transform(data) if hasattr(data, \" read \"): data = data.read().decode(\" utf8 \") if data is not None: data = self.outputs(data) if data: sys.stdout.buffer.write(data) if not data.endswith(b\" \\n \"): sys.stdout.buffer.write(b\" \\n \") return data def __str__(self): return self.parser.description or \"\" def __call__(self): \"\"\" Calls the wrapped function through the lens of a CLI ran command \"\"\" context = self.api.context_factory(api=self.api, argparse=self.parser, interface=self) def exit_callback(message): self.api.delete_context(context, errors=message) self.parser.exit_callback = exit_callback self.api._ensure_started() for requirement in self.requires: conclusion = requirement(request=sys.argv, module=self.api.module, context=context) if conclusion and conclusion is not True: self.api.delete_context(context, lacks_requirement=conclusion) return self.output(conclusion, context) if self.interface.is_method: self.parser.prog = \" %s %s\" % (self.api.module.__name__, self.interface.name) known , unknown = self . parser . parse_known_args () pass_to_function = vars ( known ) for option , directive in self . directives . items () : arguments = ( self . defaults [ option ],) if option in self . defaults else () pass_to_function [ option ] = directive ( * arguments , api = self . api , argparse = self . parser , context = context , interface = self ) for field , type_handler in self . reaffirm_types . items () : if field in pass_to_function: if not pass_to_function [ field ] and type_handler in ( list , tuple , hug . types . Multiple , ) : pass_to_function [ field ] = type_handler (()) else : pass_to_function [ field ] = self . initialize_handler ( type_handler , pass_to_function [ field ], context = context ) if getattr ( self , \"validate_function\" , False ) : errors = self . validate_function ( pass_to_function ) if errors : self . api . delete_context ( context , errors = errors ) return self . output ( errors , context ) args = None if self . additional_options: args = [] for parameter in self . interface . parameters : if parameter in pass_to_function: args . append ( pass_to_function . pop ( parameter )) args . extend ( pass_to_function . pop ( self . additional_options , ())) if self . interface . takes_kwargs: add_options_to = None for option in unknown : if option . startswith ( \"--\" ) : if add_options_to: value = pass_to_function [ add_options_to ] if len ( value ) == 1 : pass_to_function [ add_options_to ] = value [ 0 ] elif value == [] : pass_to_function [ add_options_to ] = True add_options_to = option [ 2 : ] pass_to_function . setdefault ( add_options_to , []) elif add_options_to: pass_to_function [ add_options_to ]. append ( option ) self . _ rewrite_params ( pass_to_function ) try : if args : result = self . output ( self . interface ( * args , **pass_to_function ), context ) else : result = self . output ( self . interface ( **pass_to_function ), context ) except Exception as exception : self . cleanup_parameters ( pass_to_function , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( pass_to_function ) self . api . delete_context ( context ) return result class HTTP ( Interface ) : \"\"\"Defines the interface responsible for wrapping functions and exposing them via HTTP based on the route\"\"\" __ slots__ = ( \"_params_for_outputs_state\" , \"_params_for_invalid_outputs_state\" , \"_params_for_transform_state\" , \"_params_for_on_invalid\" , \"set_status\" , \"response_headers\" , \"transform\" , \"input_transformations\" , \"examples\" , \"wrapped\" , \"catch_exceptions\" , \"parse_body\" , \"private\" , \"on_invalid\" , \"inputs\" , ) AUTO_INCLUDE = { \"request\" , \"response\" } def __ init__ ( self , route , function , catch_exceptions = True ) : super (). __ init__ ( route , function ) self . catch_exceptions = catch_exceptions self . parse_body = \"parse_body\" in route self . set_status = route . get ( \"status\" , False ) self . response_headers = tuple ( route . get ( \"response_headers\" , {}). items ()) self . private = \"private\" in route self . inputs = route . get ( \"inputs\" , {}) if \"on_invalid\" in route : self . _ params_for_on_invalid = introspect . takes_arguments ( self . on_invalid , * self . AUTO_INCLUDE ) elif self . transform : self . _ params_for_on_invalid = self . _ params_for_transform self . api . http . versions . update ( route . get ( \"versions\" , ( None ,))) self . interface . http = self @property def _ params_for_outputs ( self ) : if not hasattr ( self , \"_params_for_outputs_state\" ) : self . _ params_for_outputs_state = introspect . takes_arguments ( self . outputs , * self . AUTO_INCLUDE ) return self . _ params_for_outputs_state @property def _ params_for_invalid_outputs ( self ) : if not hasattr ( self , \"_params_for_invalid_outputs_state\" ) : self . _ params_for_invalid_outputs_state = introspect . takes_arguments ( self . invalid_outputs , * self . AUTO_INCLUDE ) return self . _ params_for_invalid_outputs_state @property def _ params_for_transform ( self ) : if not hasattr ( self , \"_params_for_transform_state\" ) : self . _ params_for_transform_state = introspect . takes_arguments ( self . transform , * self . AUTO_INCLUDE ) return self . _ params_for_transform_state def gather_parameters ( self , request , response , context , api_version = None , **input_parameters ) : \"\"\"Gathers and returns all parameters that will be used for this endpoint\"\"\" input_parameters . update ( request . params ) if self . parse_body and request . content_length: body = request . bounded_stream content_type , content_params = parse_content_type ( request . content_type ) body_formatter = body and self . inputs . get ( content_type , self . api . http . input_format ( content_type ) ) if body_formatter: body = body_formatter ( body , content_length = request . content_length , **content_params ) if \"body\" in self . all_parameters: input_parameters [ \"body\" ] = body if isinstance ( body , dict ) : input_parameters . update ( body ) elif \"body\" in self . all_parameters: input_parameters [ \"body\" ] = None if \"request\" in self . all_parameters: input_parameters [ \"request\" ] = request if \"response\" in self . all_parameters: input_parameters [ \"response\" ] = response if \"api_version\" in self . all_parameters: input_parameters [ \"api_version\" ] = api_version for parameter , directive in self . directives . items () : arguments = ( self . defaults [ parameter ],) if parameter in self . defaults else () input_parameters [ parameter ] = directive ( * arguments , response = response , request = request , api = self . api , api_version = api_version , context = context , interface = self ) return input_parameters @property def outputs ( self ) : return getattr ( self , \"_outputs\" , self . api . http . output_format ) @outputs . setter def outputs ( self , outputs ) : self . _ outputs = outputs def transform_data ( self , data , request = None , response = None , context = None ) : transform = self . transform if hasattr ( transform , \"context\" ) : self . transform . context = context \"\"\"Runs the transforms specified on this endpoint with the provided data, returning the data modified\"\"\" if transform and not ( isinstance ( transform , type ) and isinstance ( data , transform )) : if self . _ params_for_transform: return transform ( data , **self . _ arguments ( self . _ params_for_transform , request , response ) ) else : return transform ( data ) return data def content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default for this endpoint\"\"\" if callable ( self . outputs . content_type ) : return self . outputs . content_type ( request = request , response = response ) else : return self . outputs . content_type def invalid_content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default on validation errors\"\"\" if callable ( self . invalid_outputs . content_type ) : return self . invalid_outputs . content_type ( request = request , response = response ) else : return self . invalid_outputs . content_type def _ arguments ( self , requested_params , request = None , response = None ) : if requested_params: arguments = {} if \"response\" in requested_params: arguments [ \"response\" ] = response if \"request\" in requested_params: arguments [ \"request\" ] = request return arguments return empty . dict def set_response_defaults ( self , response , request = None ) : \"\"\"Sets up the response defaults that are defined in the URL route\"\"\" for header_name , header_value in self . response_headers: response . set_header ( header_name , header_value ) if self . set_status: response . status = self . set_status response . content_type = self . content_type ( request , response ) def render_errors ( self , errors , request , response ) : data = { \"errors\" : errors } if getattr ( self , \"on_invalid\" , False ) : data = self . on_invalid ( data , **self . _ arguments ( self . _ params_for_on_invalid , request , response ) ) response . status = HTTP_BAD_REQUEST if getattr ( self , \"invalid_outputs\" , False ) : response . content_type = self . invalid_content_type ( request , response ) response . data = self . invalid_outputs ( data , **self . _ arguments ( self . _ params_for_invalid_outputs , request , response ) ) else : response . data = self . outputs ( data , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) def call_function ( self , parameters ) : if not self . interface . takes_kwargs: parameters = { key : value for key , value in parameters . items () if key in self . all_parameters } self . _ rewrite_params ( parameters ) return self . interface ( **parameters ) def render_content ( self , content , context , request , response , **kwargs ) : if hasattr ( content , \"interface\" ) and ( content . interface is True or hasattr ( content . interface , \"http\" ) ) : if content . interface is True : content ( request , response , api_version = None , **kwargs ) else : content . interface . http ( request , response , api_version = None , **kwargs ) return content = self . transform_data ( content , request , response , context ) content = self . outputs ( content , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) if hasattr ( content , \"read\" ) : size = None if hasattr ( content , \"name\" ) and os . path . isfile ( content . name ) : size = os . path . getsize ( content . name ) if request . range and size : start , end = request . range if end < 0 : end = size + end end = min ( end , size ) length = end - start + 1 content . seek ( start ) response . data = content . read ( length ) response . status = falcon . HTTP_206 response . content_range = ( start , end , size ) content . close () else : if size : response . set_stream ( content , size ) else : response . stream = content # pragma : no cover else : response . data = content def __ call__ ( self , request , response , api_version = None , **kwargs ) : context = self . api . context_factory ( response = response , request = request , api = self . api , api_version = api_version , interface = self , ) \"\"\"Call the wrapped function over HTTP pulling information as needed\"\"\" if isinstance ( api_version , str ) and api_version . isdigit () : api_version = int ( api_version ) else : api_version = None if not self . catch_exceptions: exception_types = () else : exception_types = self . api . http . exception_handlers ( api_version ) exception_types = tuple ( exception_types . keys ()) if exception_types else () input_parameters = {} try : self . set_response_defaults ( response , request ) lacks_requirement = self . check_requirements ( request , response , context ) if lacks_requirement: response . data = self . outputs ( lacks_requirement , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) self . api . delete_context ( context , lacks_requirement = lacks_requirement ) return input_parameters = self . gather_parameters ( request , response , context , api_version , **kwargs ) errors = self . validate ( input_parameters , context ) if errors : self . api . delete_context ( context , errors = errors ) return self . render_errors ( errors , request , response ) self . render_content ( self . call_function ( input_parameters ), context , request , response , **kwargs ) except falcon . HTTPNotFound as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) return self . api . http . not_found ( request , response , **kwargs ) except exception_types as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) handler = None exception_type = type ( exception ) if exception_type in exception_types: handler = self . api . http . exception_handlers ( api_version )[ exception_type ][ 0 ] else : for match_exception_type , exception_handlers in tuple ( self . api . http . exception_handlers ( api_version ). items () )[ ::- 1 ] : if isinstance ( exception , match_exception_type ) : for potential_handler in exception_handlers: if not isinstance ( exception , potential_handler . exclude ) : handler = potential_handler if not handler : raise exception handler ( request = request , response = response , exception = exception , **kwargs ) except Exception as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( input_parameters ) self . api . delete_context ( context ) def documentation ( self , add_to = None , version = None , prefix= \"\" , base_url= \"\" , url= \"\" ) : \"\"\"Returns the documentation specific to an HTTP interface\"\"\" doc = OrderedDict () if add_to is None else add_to usage = self . interface . spec . __ doc__ if usage : doc [ \"usage\" ] = usage for example in self . examples : example_text = \"{0}{1}{2}{3}\" . format ( prefix , base_url , \"/v{0}\" . format ( version ) if version else \"\" , url ) if isinstance ( example , str ) : example_text += \"?{0}\" . format ( example ) doc_examples = doc . setdefault ( \"examples\" , []) if not example_text in doc_examples: doc_examples . append ( example_text ) doc = super (). documentation ( doc ) if getattr ( self , \"output_doc\" , \"\" ) : doc [ \"outputs\" ][ \"type\" ] = self . output_doc return doc @ lru_cache () def urls ( self , version = None ) : \"\"\"Returns all URLS that are mapped to this interface\"\"\" urls = [] for _ base_url , routes in self . api . http . routes . items () : for url , methods in routes . items () : for _ method , versions in methods . items () : for interface_version , interface in versions . items () : if interface_version == version and interface == self : if not url in urls : urls . append (( \"/v{0}\" . format ( version ) if version else \"\" ) + url ) return urls def url ( self , version = None , **kwargs ) : \"\"\"Returns the first matching URL found for the specified arguments\"\"\" for url in self . urls ( version ) : if [ key for key in kwargs . keys () if not \"{\" + key + \"}\" in url ] : continue return url . format ( **kwargs ) raise KeyError ( \"URL that takes all provided parameters not found\" ) class ExceptionRaised ( HTTP ) : \"\"\"Defines the interface responsible for taking and transforming exceptions that occur during processing\"\"\" __ slots__ = ( \"handle\" , \"exclude\" ) def __ init__ ( self , route , * args , **kwargs ) : self . handle = route [ \"exceptions\" ] self . exclude = route [ \"exclude\" ] super (). __ init__ ( route , * args , **kwargs )","title":"Module hug.interface"},{"location":"reference/hug/interface/#variables","text":"DOC_TYPE_MAP HTTP_BAD_REQUEST","title":"Variables"},{"location":"reference/hug/interface/#functions","text":"","title":"Functions"},{"location":"reference/hug/interface/#asyncio_call","text":"def ( function , * args , ** kwargs ) View Source def asyncio_call ( function , * args , ** kwargs ) : loop = asyncio . get_event_loop () if loop . is_running () : return function ( * args , ** kwargs ) function = asyncio . ensure_future ( function ( * args , ** kwargs ) , loop = loop ) loop . run_until_complete ( function ) return function . result ()","title":"asyncio_call"},{"location":"reference/hug/interface/#classes","text":"","title":"Classes"},{"location":"reference/hug/interface/#cli","text":"class ( route , function ) Defines the Interface responsible for exposing functions to the CLI View Source class CLI ( Interface ) : \"\"\" Defines the Interface responsible for exposing functions to the CLI \"\"\" def __init__ ( self , route , function ) : super () . __init__ ( route , function ) if not self . outputs : self . outputs = self . api . cli . output_format self . interface . cli = self self . reaffirm_types = {} use_parameters = list ( self . interface . parameters ) self . additional_options = getattr ( self . interface , \" arg \" , getattr ( self . interface , \" kwarg \" , False ) ) if self . additional_options : use_parameters . append ( self . additional_options ) used_options = { \" h \" , \" help \" } nargs_set = self . interface . takes_args or self . interface . takes_kwargs class CustomArgumentParser ( argparse . ArgumentParser ) : exit_callback = None def exit ( self , status = 0 , message = None ) : if self . exit_callback : self . exit_callback ( message ) super () . exit ( status , message ) self . parser = CustomArgumentParser ( description = route . get ( \" doc \" , self . interface . spec . __doc__ ) ) if \" version \" in route : self . parser . add_argument ( \" -v \" , \" --version \" , action = \" version \" , version = \" {0} {1} \" . format ( route . get ( \" name \" , self . interface . spec . __name__ ) , route [ \" version \" ] ) , ) used_options . update (( \" v \" , \" version \" )) self . context_tranforms = [] for option in use_parameters : if option in self . directives : continue if option in self . interface . required or option == self . additional_options : args = ( option , ) else : short_option = option [ 0 ] while short_option in used_options and len ( short_option ) < len ( option ) : short_option = option [: len ( short_option ) + 1 ] used_options . add ( short_option ) used_options . add ( option ) if short_option != option : args = ( \" -{0} \" . format ( short_option ) , \" --{0} \" . format ( option )) else : args = ( \" --{0} \" . format ( option ) , ) kwargs = {} if option in self . defaults : kwargs [ \" default \" ] = self . defaults [ option ] if option in self . interface . input_transformations : transform = self . interface . input_transformations [ option ] kwargs [ \" type \" ] = transform kwargs [ \" help \" ] = _doc ( transform ) if transform in ( list , tuple ) or isinstance ( transform , types . Multiple ) : kwargs [ \" action \" ] = \" append \" kwargs [ \" type \" ] = Text () self . reaffirm_types [ option ] = transform elif transform == bool or isinstance ( transform , type ( types . boolean )) : kwargs [ \" action \" ] = \" store_true \" self . reaffirm_types [ option ] = transform elif isinstance ( transform , types . OneOf ) : kwargs [ \" choices \" ] = transform . values elif ( option in self . interface . spec . __annotations__ and type ( self . interface . spec . __annotations__ [ option ] ) == str ) : kwargs [ \" help \" ] = option if ( kwargs . get ( \" type \" , None ) == bool or kwargs . get ( \" action \" , None ) == \" store_true \" ) and not kwargs [ \" default \" ]: kwargs [ \" action \" ] = \" store_true \" kwargs . pop ( \" type \" , None ) elif kwargs . get ( \" action \" , None ) == \" store_true \" : kwargs . pop ( \" action \" , None ) if option == self . additional_options : kwargs [ \" nargs \" ] = \" * \" elif ( not nargs_set and kwargs . get ( \" action \" , None ) == \" append \" and not option in self . interface . defaults ) : kwargs [ \" nargs \" ] = \" * \" kwargs . pop ( \" action \" , \"\" ) nargs_set = True self . parser . add_argument ( * args , ** kwargs ) self . api . cli . commands [ route . get ( \" name \" , self . interface . spec . __name__ ) ] = self def output ( self , data , context ) : \"\"\" Outputs the provided data using the transformations and output format specified for this CLI endpoint \"\"\" if self . transform : if hasattr ( self . transform , \" context \" ) : self . transform . context = context data = self . transform ( data ) if hasattr ( data , \" read \" ) : data = data . read () . decode ( \" utf8 \" ) if data is not None : data = self . outputs ( data ) if data : sys . stdout . buffer . write ( data ) if not data . endswith ( b \" \\n \" ) : sys . stdout . buffer . write ( b \" \\n \" ) return data def __str__ ( self ) : return self . parser . description or \"\" def __call__ ( self ) : \"\"\" Calls the wrapped function through the lens of a CLI ran command \"\"\" context = self . api . context_factory ( api = self . api , argparse = self . parser , interface = self ) def exit_callback ( message ) : self . api . delete_context ( context , errors = message ) self . parser . exit_callback = exit_callback self . api . _ensure_started () for requirement in self . requires : conclusion = requirement ( request = sys . argv , module = self . api . module , context = context ) if conclusion and conclusion is not True : self . api . delete_context ( context , lacks_requirement = conclusion ) return self . output ( conclusion , context ) if self . interface . is_method : self . parser . prog = \" %s %s \" % ( self . api . module . __name__ , self . interface . name ) known , unknown = self . parser . parse_known_args () pass_to_function = vars ( known ) for option , directive in self . directives . items () : arguments = ( self . defaults [ option ], ) if option in self . defaults else () pass_to_function [ option ] = directive ( * arguments , api = self . api , argparse = self . parser , context = context , interface = self ) for field , type_handler in self . reaffirm_types . items () : if field in pass_to_function : if not pass_to_function [ field ] and type_handler in ( list , tuple , hug . types . Multiple , ) : pass_to_function [ field ] = type_handler (()) else : pass_to_function [ field ] = self . initialize_handler ( type_handler , pass_to_function [ field ], context = context ) if getattr ( self , \" validate_function \" , False ) : errors = self . validate_function ( pass_to_function ) if errors : self . api . delete_context ( context , errors = errors ) return self . output ( errors , context ) args = None if self . additional_options : args = [] for parameter in self . interface . parameters : if parameter in pass_to_function : args . append ( pass_to_function . pop ( parameter )) args . extend ( pass_to_function . pop ( self . additional_options , ())) if self . interface . takes_kwargs : add_options_to = None for option in unknown : if option . startswith ( \" -- \" ) : if add_options_to : value = pass_to_function [ add_options_to ] if len ( value ) == 1 : pass_to_function [ add_options_to ] = value [ 0 ] elif value == []: pass_to_function [ add_options_to ] = True add_options_to = option [ 2 :] pass_to_function . setdefault ( add_options_to , [] ) elif add_options_to : pass_to_function [ add_options_to ]. append ( option ) self . _rewrite_params ( pass_to_function ) try : if args : result = self . output ( self . interface ( * args , ** pass_to_function ) , context ) else : result = self . output ( self . interface ( ** pass_to_function ) , context ) except Exception as exception : self . cleanup_parameters ( pass_to_function , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( pass_to_function ) self . api . delete_context ( context ) return result","title":"CLI"},{"location":"reference/hug/interface/#ancestors-in-mro","text":"hug.interface.Interface","title":"Ancestors (in MRO)"},{"location":"reference/hug/interface/#exceptionraised","text":"class ( route , * args , ** kwargs ) Defines the interface responsible for taking and transforming exceptions that occur during processing View Source class ExceptionRaised ( HTTP ) : \"\"\" Defines the interface responsible for taking and transforming exceptions that occur during processing \"\"\" __slots__ = ( \" handle \" , \" exclude \" ) def __init__ ( self , route , * args , ** kwargs ) : self . handle = route [ \" exceptions \" ] self . exclude = route [ \" exclude \" ] super () . __init__ ( route , * args , ** kwargs )","title":"ExceptionRaised"},{"location":"reference/hug/interface/#ancestors-in-mro_1","text":"hug.interface.HTTP hug.interface.Interface","title":"Ancestors (in MRO)"},{"location":"reference/hug/interface/#http","text":"class ( route , function , catch_exceptions = True ) Defines the interface responsible for wrapping functions and exposing them via HTTP based on the route View Source class HTTP ( Interface ) : \"\"\"Defines the interface responsible for wrapping functions and exposing them via HTTP based on the route\"\"\" __ slots__ = ( \"_params_for_outputs_state\" , \"_params_for_invalid_outputs_state\" , \"_params_for_transform_state\" , \"_params_for_on_invalid\" , \"set_status\" , \"response_headers\" , \"transform\" , \"input_transformations\" , \"examples\" , \"wrapped\" , \"catch_exceptions\" , \"parse_body\" , \"private\" , \"on_invalid\" , \"inputs\" , ) AUTO_INCLUDE = { \"request\" , \"response\" } def __ init__ ( self , route , function , catch_exceptions = True ) : super (). __ init__ ( route , function ) self . catch_exceptions = catch_exceptions self . parse_body = \"parse_body\" in route self . set_status = route . get ( \"status\" , False ) self . response_headers = tuple ( route . get ( \"response_headers\" , {}). items ()) self . private = \"private\" in route self . inputs = route . get ( \"inputs\" , {}) if \"on_invalid\" in route : self . _ params_for_on_invalid = introspect . takes_arguments ( self . on_invalid , * self . AUTO_INCLUDE ) elif self . transform : self . _ params_for_on_invalid = self . _ params_for_transform self . api . http . versions . update ( route . get ( \"versions\" , ( None ,))) self . interface . http = self @property def _ params_for_outputs ( self ) : if not hasattr ( self , \"_params_for_outputs_state\" ) : self . _ params_for_outputs_state = introspect . takes_arguments ( self . outputs , * self . AUTO_INCLUDE ) return self . _ params_for_outputs_state @property def _ params_for_invalid_outputs ( self ) : if not hasattr ( self , \"_params_for_invalid_outputs_state\" ) : self . _ params_for_invalid_outputs_state = introspect . takes_arguments ( self . invalid_outputs , * self . AUTO_INCLUDE ) return self . _ params_for_invalid_outputs_state @property def _ params_for_transform ( self ) : if not hasattr ( self , \"_params_for_transform_state\" ) : self . _ params_for_transform_state = introspect . takes_arguments ( self . transform , * self . AUTO_INCLUDE ) return self . _ params_for_transform_state def gather_parameters ( self , request , response , context , api_version = None , **input_parameters ) : \"\"\"Gathers and returns all parameters that will be used for this endpoint\"\"\" input_parameters . update ( request . params ) if self . parse_body and request . content_length: body = request . bounded_stream content_type , content_params = parse_content_type ( request . content_type ) body_formatter = body and self . inputs . get ( content_type , self . api . http . input_format ( content_type ) ) if body_formatter: body = body_formatter ( body , content_length = request . content_length , **content_params ) if \"body\" in self . all_parameters: input_parameters [ \"body\" ] = body if isinstance ( body , dict ) : input_parameters . update ( body ) elif \"body\" in self . all_parameters: input_parameters [ \"body\" ] = None if \"request\" in self . all_parameters: input_parameters [ \"request\" ] = request if \"response\" in self . all_parameters: input_parameters [ \"response\" ] = response if \"api_version\" in self . all_parameters: input_parameters [ \"api_version\" ] = api_version for parameter , directive in self . directives . items () : arguments = ( self . defaults [ parameter ],) if parameter in self . defaults else () input_parameters [ parameter ] = directive ( * arguments , response = response , request = request , api = self . api , api_version = api_version , context = context , interface = self ) return input_parameters @property def outputs ( self ) : return getattr ( self , \"_outputs\" , self . api . http . output_format ) @outputs . setter def outputs ( self , outputs ) : self . _ outputs = outputs def transform_data ( self , data , request = None , response = None , context = None ) : transform = self . transform if hasattr ( transform , \"context\" ) : self . transform . context = context \"\"\"Runs the transforms specified on this endpoint with the provided data, returning the data modified\"\"\" if transform and not ( isinstance ( transform , type ) and isinstance ( data , transform )) : if self . _ params_for_transform: return transform ( data , **self . _ arguments ( self . _ params_for_transform , request , response ) ) else : return transform ( data ) return data def content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default for this endpoint\"\"\" if callable ( self . outputs . content_type ) : return self . outputs . content_type ( request = request , response = response ) else : return self . outputs . content_type def invalid_content_type ( self , request = None , response = None ) : \"\"\"Returns the content type that should be used by default on validation errors\"\"\" if callable ( self . invalid_outputs . content_type ) : return self . invalid_outputs . content_type ( request = request , response = response ) else : return self . invalid_outputs . content_type def _ arguments ( self , requested_params , request = None , response = None ) : if requested_params: arguments = {} if \"response\" in requested_params: arguments [ \"response\" ] = response if \"request\" in requested_params: arguments [ \"request\" ] = request return arguments return empty . dict def set_response_defaults ( self , response , request = None ) : \"\"\"Sets up the response defaults that are defined in the URL route\"\"\" for header_name , header_value in self . response_headers: response . set_header ( header_name , header_value ) if self . set_status: response . status = self . set_status response . content_type = self . content_type ( request , response ) def render_errors ( self , errors , request , response ) : data = { \"errors\" : errors } if getattr ( self , \"on_invalid\" , False ) : data = self . on_invalid ( data , **self . _ arguments ( self . _ params_for_on_invalid , request , response ) ) response . status = HTTP_BAD_REQUEST if getattr ( self , \"invalid_outputs\" , False ) : response . content_type = self . invalid_content_type ( request , response ) response . data = self . invalid_outputs ( data , **self . _ arguments ( self . _ params_for_invalid_outputs , request , response ) ) else : response . data = self . outputs ( data , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) def call_function ( self , parameters ) : if not self . interface . takes_kwargs: parameters = { key : value for key , value in parameters . items () if key in self . all_parameters } self . _ rewrite_params ( parameters ) return self . interface ( **parameters ) def render_content ( self , content , context , request , response , **kwargs ) : if hasattr ( content , \"interface\" ) and ( content . interface is True or hasattr ( content . interface , \"http\" ) ) : if content . interface is True : content ( request , response , api_version = None , **kwargs ) else : content . interface . http ( request , response , api_version = None , **kwargs ) return content = self . transform_data ( content , request , response , context ) content = self . outputs ( content , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) if hasattr ( content , \"read\" ) : size = None if hasattr ( content , \"name\" ) and os . path . isfile ( content . name ) : size = os . path . getsize ( content . name ) if request . range and size : start , end = request . range if end < 0 : end = size + end end = min ( end , size ) length = end - start + 1 content . seek ( start ) response . data = content . read ( length ) response . status = falcon . HTTP_206 response . content_range = ( start , end , size ) content . close () else : if size : response . set_stream ( content , size ) else : response . stream = content # pragma : no cover else : response . data = content def __ call__ ( self , request , response , api_version = None , **kwargs ) : context = self . api . context_factory ( response = response , request = request , api = self . api , api_version = api_version , interface = self , ) \"\"\"Call the wrapped function over HTTP pulling information as needed\"\"\" if isinstance ( api_version , str ) and api_version . isdigit () : api_version = int ( api_version ) else : api_version = None if not self . catch_exceptions: exception_types = () else : exception_types = self . api . http . exception_handlers ( api_version ) exception_types = tuple ( exception_types . keys ()) if exception_types else () input_parameters = {} try : self . set_response_defaults ( response , request ) lacks_requirement = self . check_requirements ( request , response , context ) if lacks_requirement: response . data = self . outputs ( lacks_requirement , **self . _ arguments ( self . _ params_for_outputs , request , response ) ) self . api . delete_context ( context , lacks_requirement = lacks_requirement ) return input_parameters = self . gather_parameters ( request , response , context , api_version , **kwargs ) errors = self . validate ( input_parameters , context ) if errors : self . api . delete_context ( context , errors = errors ) return self . render_errors ( errors , request , response ) self . render_content ( self . call_function ( input_parameters ), context , request , response , **kwargs ) except falcon . HTTPNotFound as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) return self . api . http . not_found ( request , response , **kwargs ) except exception_types as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) handler = None exception_type = type ( exception ) if exception_type in exception_types: handler = self . api . http . exception_handlers ( api_version )[ exception_type ][ 0 ] else : for match_exception_type , exception_handlers in tuple ( self . api . http . exception_handlers ( api_version ). items () )[ ::- 1 ] : if isinstance ( exception , match_exception_type ) : for potential_handler in exception_handlers: if not isinstance ( exception , potential_handler . exclude ) : handler = potential_handler if not handler : raise exception handler ( request = request , response = response , exception = exception , **kwargs ) except Exception as exception : self . cleanup_parameters ( input_parameters , exception = exception ) self . api . delete_context ( context , exception = exception ) raise exception self . cleanup_parameters ( input_parameters ) self . api . delete_context ( context ) def documentation ( self , add_to = None , version = None , prefix= \"\" , base_url= \"\" , url= \"\" ) : \"\"\"Returns the documentation specific to an HTTP interface\"\"\" doc = OrderedDict () if add_to is None else add_to usage = self . interface . spec . __ doc__ if usage : doc [ \"usage\" ] = usage for example in self . examples : example_text = \"{0}{1}{2}{3}\" . format ( prefix , base_url , \"/v{0}\" . format ( version ) if version else \"\" , url ) if isinstance ( example , str ) : example_text += \"?{0}\" . format ( example ) doc_examples = doc . setdefault ( \"examples\" , []) if not example_text in doc_examples: doc_examples . append ( example_text ) doc = super (). documentation ( doc ) if getattr ( self , \"output_doc\" , \"\" ) : doc [ \"outputs\" ][ \"type\" ] = self . output_doc return doc @ lru_cache () def urls ( self , version = None ) : \"\"\"Returns all URLS that are mapped to this interface\"\"\" urls = [] for _ base_url , routes in self . api . http . routes . items () : for url , methods in routes . items () : for _ method , versions in methods . items () : for interface_version , interface in versions . items () : if interface_version == version and interface == self : if not url in urls : urls . append (( \"/v{0}\" . format ( version ) if version else \"\" ) + url ) return urls def url ( self , version = None , **kwargs ) : \"\"\"Returns the first matching URL found for the specified arguments\"\"\" for url in self . urls ( version ) : if [ key for key in kwargs . keys () if not \"{\" + key + \"}\" in url ] : continue return url . format ( **kwargs ) raise KeyError ( \"URL that takes all provided parameters not found\" )","title":"HTTP"},{"location":"reference/hug/interface/#ancestors-in-mro_2","text":"hug.interface.Interface","title":"Ancestors (in MRO)"},{"location":"reference/hug/interface/#descendants","text":"hug.interface.ExceptionRaised","title":"Descendants"},{"location":"reference/hug/interface/#class-variables","text":"AUTO_INCLUDE","title":"Class variables"},{"location":"reference/hug/interface/#interface","text":"class ( route , function ) Defines the basic hug interface object, which is responsible for wrapping a user defined function and providing all the info requested in the function as well as the route A Interface object should be created for every kind of protocal hug supports View Source class Interface ( object ) : \"\"\" Defines the basic hug interface object, which is responsible for wrapping a user defined function and providing all the info requested in the function as well as the route A Interface object should be created for every kind of protocal hug supports \"\"\" __slots__ = ( \" interface \" , \" _api \" , \" defaults \" , \" parameters \" , \" required \" , \" _outputs \" , \" on_invalid \" , \" requires \" , \" validate_function \" , \" transform \" , \" examples \" , \" output_doc \" , \" wrapped \" , \" directives \" , \" all_parameters \" , \" raise_on_invalid \" , \" invalid_outputs \" , \" map_params \" , \" input_transformations \" , ) def __init__ ( self , route , function ) : if route . get ( \" api \" , None ) : self . _api = route [ \" api \" ] if \" examples \" in route : self . examples = route [ \" examples \" ] function_args = route . get ( \" args \" ) if not hasattr ( function , \" interface \" ) : function . __dict__ [ \" interface \" ] = Interfaces ( function , function_args ) self . interface = function . interface self . requires = route . get ( \" requires \" , ()) if \" validate \" in route : self . validate_function = route [ \" validate \" ] if \" output_invalid \" in route : self . invalid_outputs = route [ \" output_invalid \" ] if not \" parameters \" in route : self . defaults = self . interface . defaults self . parameters = self . interface . parameters self . all_parameters = self . interface . all_parameters self . required = self . interface . required else : self . defaults = route . get ( \" defaults \" , {} ) self . parameters = tuple ( route [ \" parameters \" ] ) self . all_parameters = set ( route [ \" parameters \" ] ) self . required = tuple ( [ parameter for parameter in self . parameters if parameter not in self . defaults ] ) if \" map_params \" in route : self . map_params = route [ \" map_params \" ] for interface_name , internal_name in self . map_params . items () : if internal_name in self . defaults : self . defaults [ interface_name ] = self . defaults . pop ( internal_name ) if internal_name in self . parameters : self . parameters = [ interface_name if param == internal_name else param for param in self . parameters ] if internal_name in self . all_parameters : self . all_parameters . remove ( internal_name ) self . all_parameters . add ( interface_name ) if internal_name in self . required : self . required = tuple ( [ interface_name if param == internal_name else param for param in self . required ] ) reverse_mapping = { internal : interface for interface , internal in self . map_params . items () } self . input_transformations = { reverse_mapping . get ( name , name ) : transform for name , transform in self . interface . input_transformations . items () } else : self . map_params = {} self . input_transformations = self . interface . input_transformations if \" output \" in route : self . outputs = route [ \" output \" ] self . transform = route . get ( \" transform \" , None ) if self . transform is None and not isinstance ( self . interface . transform , ( str , type ( None ))) : self . transform = self . interface . transform if hasattr ( self . transform , \" dump \" ) : self . transform = MarshmallowReturnSchema ( self . transform ) self . output_doc = self . transform . __doc__ elif self . transform or self . interface . transform : output_doc = self . transform or self . interface . transform self . output_doc = output_doc if type ( output_doc ) is str else _doc ( output_doc ) self . raise_on_invalid = route . get ( \" raise_on_invalid \" , False ) if \" on_invalid \" in route : self . on_invalid = route [ \" on_invalid \" ] elif self . transform : self . on_invalid = self . transform defined_directives = self . api . directives () used_directives = set ( self . parameters ) . intersection ( defined_directives ) self . directives = { directive_name : defined_directives [ directive_name ] for directive_name in used_directives } self . directives . update ( self . interface . directives ) @ property def api ( self ) : return getattr ( self , \" _api \" , self . interface . api ) @ property def outputs ( self ) : return getattr ( self , \" _outputs \" , None ) @ outputs . setter def outputs ( self , outputs ) : self . _outputs = outputs # pragma : no cover - generally re - implemented by sub classes def validate ( self , input_parameters , context ) : \"\"\" Runs all set type transformers / validators against the provided input parameters and returns any errors \"\"\" errors = {} for key , type_handler in self . input_transformations . items () : if self . raise_on_invalid : if key in input_parameters : input_parameters [ key ] = self . initialize_handler ( type_handler , input_parameters [ key ], context = context ) else : try : if key in input_parameters : input_parameters [ key ] = self . initialize_handler ( type_handler , input_parameters [ key ], context = context ) except InvalidTypeData as error : errors [ key ] = error . reasons or str ( error ) except Exception as error : if hasattr ( error , \" args \" ) and error . args : errors [ key ] = error . args [ 0 ] else : errors [ key ] = str ( error ) for require in self . required : if not require in input_parameters : errors [ require ] = \" Required parameter '{}' not supplied \" . format ( require ) if not errors and getattr ( self , \" validate_function \" , False ) : errors = self . validate_function ( input_parameters ) return errors def check_requirements ( self , request = None , response = None , context = None ) : \"\"\" Checks to see if all requirements set pass if all requirements pass nothing will be returned otherwise , the error reported will be returned \"\"\" for requirement in self . requires : conclusion = requirement ( response = response , request = request , context = context , module = self . api . module ) if conclusion and conclusion is not True : return conclusion def documentation ( self , add_to = None ) : \"\"\" Produces general documentation for the interface \"\"\" doc = OrderedDict if add_to is None else add_to usage = self . interface . spec . __doc__ if usage : doc [ \" usage \" ] = usage if getattr ( self , \" requires \" , None ) : doc [ \" requires \" ] = [ getattr ( requirement , \" __doc__ \" , requirement . __name__ ) for requirement in self . requires ] doc [ \" outputs \" ] = OrderedDict () doc [ \" outputs \" ][ \" format \" ] = _doc ( self . outputs ) doc [ \" outputs \" ][ \" content_type \" ] = self . outputs . content_type parameters = [ param for param in self . parameters if not param in ( \" request \" , \" response \" , \" self \" ) and not param in ( \" api_version \" , \" body \" ) and not param . startswith ( \" hug_ \" ) and not hasattr ( param , \" directive \" ) ] if parameters : inputs = doc . setdefault ( \" inputs \" , OrderedDict ()) types = self . interface . spec . __annotations__ for argument in parameters : kind = types . get ( self . _remap_entry ( argument ) , text ) if getattr ( kind , \" directive \" , None ) is True : continue input_definition = inputs . setdefault ( argument , OrderedDict ()) input_definition [ \" type \" ] = kind if isinstance ( kind , str ) else _doc ( kind ) default = self . defaults . get ( argument , None ) if default is not None : input_definition [ \" default \" ] = default return doc def _rewrite_params ( self , params ) : for interface_name , internal_name in self . map_params . items () : if interface_name in params : params [ internal_name ] = params . pop ( interface_name ) def _remap_entry ( self , interface_name ) : return self . map_params . get ( interface_name , interface_name ) @ staticmethod def cleanup_parameters ( parameters , exception = None ) : for _parameter , directive in parameters . items () : if hasattr ( directive , \" cleanup \" ) : directive . cleanup ( exception = exception ) @ staticmethod def initialize_handler ( handler , value , context ) : try : # It ' s easier to ask for forgiveness than for permission return handler ( value , context = context ) except TypeError : return handler ( value )","title":"Interface"},{"location":"reference/hug/interface/#descendants_1","text":"hug.interface.Local hug.interface.CLI hug.interface.HTTP","title":"Descendants"},{"location":"reference/hug/interface/#interfaces","text":"class ( function , args = None ) Defines the per-function singleton applied to hugged functions defining common data needed by all interfaces View Source class Interfaces ( object ) : \"\"\" Defines the per-function singleton applied to hugged functions defining common data needed by all interfaces \"\"\" def __init__ ( self , function , args = None ) : self . api = hug . api . from_object ( function ) self . spec = getattr ( function , \" original \" , function ) self . arguments = introspect . arguments ( function ) self . name = introspect . name ( function ) self . _function = function self . is_coroutine = introspect . is_coroutine ( self . spec ) if self . is_coroutine : self . spec = getattr ( self . spec , \" __wrapped__ \" , self . spec ) self . takes_args = introspect . takes_args ( self . spec ) self . takes_kwargs = introspect . takes_kwargs ( self . spec ) self . parameters = list ( introspect . arguments ( self . spec , self . takes_kwargs + self . takes_args )) if self . takes_kwargs : self . kwarg = self . parameters . pop ( - 1 ) if self . takes_args : self . arg = self . parameters . pop ( - 1 ) self . parameters = tuple ( self . parameters ) self . defaults = dict ( zip ( reversed ( self . parameters ) , reversed ( self . spec . __defaults__ or ()))) self . required = self . parameters [: - ( len ( self . spec . __defaults__ or ())) or None ] self . is_method = introspect . is_method ( self . spec ) or introspect . is_method ( function ) if self . is_method : self . required = self . required [ 1 :] self . parameters = self . parameters [ 1 :] self . all_parameters = set ( self . parameters ) if self . spec is not function : self . all_parameters . update ( self . arguments ) if args is not None : transformers = args else : transformers = self . spec . __annotations__ self . transform = transformers . get ( \" return \" , None ) self . directives = {} self . input_transformations = {} for name , transformer in transformers . items () : if isinstance ( transformer , str ) : continue elif hasattr ( transformer , \" directive \" ) : self . directives [ name ] = transformer continue if hasattr ( transformer , \" from_string \" ) : transformer = transformer . from_string elif hasattr ( transformer , \" load \" ) : transformer = MarshmallowInputSchema ( transformer ) elif hasattr ( transformer , \" deserialize \" ) : transformer = transformer . deserialize self . input_transformations [ name ] = transformer def __call__ ( __hug_internal_self , * args , ** kwargs ) : # noqa : N805 \"\"\"\" Calls the wrapped function , uses __hug_internal_self incase self is passed in as a kwarg from the wrapper \"\"\" if not __hug_internal_self . is_coroutine : return __hug_internal_self . _function ( * args , ** kwargs ) return asyncio_call ( __hug_internal_self . _function , * args , ** kwargs )","title":"Interfaces"},{"location":"reference/hug/interface/#local","text":"class ( route , function ) Defines the Interface responsible for exposing functions locally","title":"Local"},{"location":"reference/hug/interface/#ancestors-in-mro_3","text":"hug.interface.Interface","title":"Ancestors (in MRO)"},{"location":"reference/hug/introspect/","text":"Module hug.introspect hug/introspect.py Defines built in hug functions to aid in introspection Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/introspect.py Defines built in hug functions to aid in introspection Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import inspect from types import MethodType def is_method ( function ) : \"\"\" Returns True if the passed in function is identified as a method (NOT a function) \"\"\" return isinstance ( function , MethodType ) def is_coroutine ( function ) : \"\"\" Returns True if the passed in function is a coroutine \"\"\" return function . __code__ . co_flags & 0 x0080 or getattr ( function , \" _is_coroutine \" , False ) def name ( function ) : \"\"\" Returns the name of a function \"\"\" return function . __name__ def arguments ( function , extra_arguments = 0 ) : \"\"\" Returns the name of all arguments a function takes \"\"\" if not hasattr ( function , \" __code__ \" ) : return () return function . __code__ . co_varnames [: function . __code__ . co_argcount + extra_arguments ] def takes_kwargs ( function ) : \"\"\" Returns True if the supplied function takes keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x08 ) def takes_args ( function ) : \"\"\" Returns True if the supplied functions takes extra non-keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x04 ) def takes_arguments ( function , * named_arguments ) : \"\"\" Returns the arguments that a function takes from a list of requested arguments \"\"\" return set ( named_arguments ) . intersection ( arguments ( function )) def takes_all_arguments ( function , * named_arguments ) : \"\"\" Returns True if all supplied arguments are found in the function \"\"\" return bool ( takes_arguments ( function , * named_arguments ) == set ( named_arguments )) def generate_accepted_kwargs ( function , * named_arguments ) : \"\"\" Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that's compatible with the supplied function \"\"\" if hasattr ( function , \" __code__ \" ) and takes_kwargs ( function ) : function_takes_kwargs = True function_takes_arguments = [] else : function_takes_kwargs = False function_takes_arguments = takes_arguments ( function , * named_arguments ) def accepted_kwargs ( kwargs ) : if function_takes_kwargs : return kwargs elif function_takes_arguments : return { key : value for key , value in kwargs . items () if key in function_takes_arguments } return {} return accepted_kwargs Functions arguments def ( function , extra_arguments = 0 ) Returns the name of all arguments a function takes View Source def arguments ( function , extra_arguments = 0 ) : \"\"\" Returns the name of all arguments a function takes \"\"\" if not hasattr ( function , \" __code__ \" ) : return () return function . __code__ . co_varnames [: function . __code__ . co_argcount + extra_arguments ] generate_accepted_kwargs def ( function , * named_arguments ) Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that's compatible with the supplied function View Source def generate_accepted_kwargs ( function , * named_arguments ) : \"\"\" Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that's compatible with the supplied function \"\"\" if hasattr ( function , \" __code__ \" ) and takes_kwargs ( function ) : function_takes_kwargs = True function_takes_arguments = [] else : function_takes_kwargs = False function_takes_arguments = takes_arguments ( function , * named_arguments ) def accepted_kwargs ( kwargs ) : if function_takes_kwargs : return kwargs elif function_takes_arguments : return { key : value for key , value in kwargs . items () if key in function_takes_arguments } return {} return accepted_kwargs is_coroutine def ( function ) Returns True if the passed in function is a coroutine View Source def is_coroutine ( function ) : \"\"\" Returns True if the passed in function is a coroutine \"\"\" return function . __code__ . co_flags & 0 x0080 or getattr ( function , \" _is_coroutine \" , False ) is_method def ( function ) Returns True if the passed in function is identified as a method (NOT a function) View Source def is_method ( function ) : \"\"\" Returns True if the passed in function is identified as a method (NOT a function) \"\"\" return isinstance ( function , MethodType ) name def ( function ) Returns the name of a function View Source def name ( function ) : \"\"\" Returns the name of a function \"\"\" return function . __name__ takes_all_arguments def ( function , * named_arguments ) Returns True if all supplied arguments are found in the function View Source def takes_all_arguments ( function , * named_arguments ) : \"\"\" Returns True if all supplied arguments are found in the function \"\"\" return bool ( takes_arguments ( function , * named_arguments ) == set ( named_arguments )) takes_args def ( function ) Returns True if the supplied functions takes extra non-keyword arguments View Source def takes_args ( function ) : \"\"\" Returns True if the supplied functions takes extra non-keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x04 ) takes_arguments def ( function , * named_arguments ) Returns the arguments that a function takes from a list of requested arguments View Source def takes_arguments ( function , * named_arguments ) : \"\"\" Returns the arguments that a function takes from a list of requested arguments \"\"\" return set ( named_arguments ) . intersection ( arguments ( function )) takes_kwargs def ( function ) Returns True if the supplied function takes keyword arguments View Source def takes_kwargs ( function ) : \"\"\" Returns True if the supplied function takes keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x08 )","title":"Introspect"},{"location":"reference/hug/introspect/#module-hugintrospect","text":"hug/introspect.py Defines built in hug functions to aid in introspection Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/introspect.py Defines built in hug functions to aid in introspection Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import inspect from types import MethodType def is_method ( function ) : \"\"\" Returns True if the passed in function is identified as a method (NOT a function) \"\"\" return isinstance ( function , MethodType ) def is_coroutine ( function ) : \"\"\" Returns True if the passed in function is a coroutine \"\"\" return function . __code__ . co_flags & 0 x0080 or getattr ( function , \" _is_coroutine \" , False ) def name ( function ) : \"\"\" Returns the name of a function \"\"\" return function . __name__ def arguments ( function , extra_arguments = 0 ) : \"\"\" Returns the name of all arguments a function takes \"\"\" if not hasattr ( function , \" __code__ \" ) : return () return function . __code__ . co_varnames [: function . __code__ . co_argcount + extra_arguments ] def takes_kwargs ( function ) : \"\"\" Returns True if the supplied function takes keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x08 ) def takes_args ( function ) : \"\"\" Returns True if the supplied functions takes extra non-keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x04 ) def takes_arguments ( function , * named_arguments ) : \"\"\" Returns the arguments that a function takes from a list of requested arguments \"\"\" return set ( named_arguments ) . intersection ( arguments ( function )) def takes_all_arguments ( function , * named_arguments ) : \"\"\" Returns True if all supplied arguments are found in the function \"\"\" return bool ( takes_arguments ( function , * named_arguments ) == set ( named_arguments )) def generate_accepted_kwargs ( function , * named_arguments ) : \"\"\" Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that's compatible with the supplied function \"\"\" if hasattr ( function , \" __code__ \" ) and takes_kwargs ( function ) : function_takes_kwargs = True function_takes_arguments = [] else : function_takes_kwargs = False function_takes_arguments = takes_arguments ( function , * named_arguments ) def accepted_kwargs ( kwargs ) : if function_takes_kwargs : return kwargs elif function_takes_arguments : return { key : value for key , value in kwargs . items () if key in function_takes_arguments } return {} return accepted_kwargs","title":"Module hug.introspect"},{"location":"reference/hug/introspect/#functions","text":"","title":"Functions"},{"location":"reference/hug/introspect/#arguments","text":"def ( function , extra_arguments = 0 ) Returns the name of all arguments a function takes View Source def arguments ( function , extra_arguments = 0 ) : \"\"\" Returns the name of all arguments a function takes \"\"\" if not hasattr ( function , \" __code__ \" ) : return () return function . __code__ . co_varnames [: function . __code__ . co_argcount + extra_arguments ]","title":"arguments"},{"location":"reference/hug/introspect/#generate_accepted_kwargs","text":"def ( function , * named_arguments ) Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that's compatible with the supplied function View Source def generate_accepted_kwargs ( function , * named_arguments ) : \"\"\" Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that's compatible with the supplied function \"\"\" if hasattr ( function , \" __code__ \" ) and takes_kwargs ( function ) : function_takes_kwargs = True function_takes_arguments = [] else : function_takes_kwargs = False function_takes_arguments = takes_arguments ( function , * named_arguments ) def accepted_kwargs ( kwargs ) : if function_takes_kwargs : return kwargs elif function_takes_arguments : return { key : value for key , value in kwargs . items () if key in function_takes_arguments } return {} return accepted_kwargs","title":"generate_accepted_kwargs"},{"location":"reference/hug/introspect/#is_coroutine","text":"def ( function ) Returns True if the passed in function is a coroutine View Source def is_coroutine ( function ) : \"\"\" Returns True if the passed in function is a coroutine \"\"\" return function . __code__ . co_flags & 0 x0080 or getattr ( function , \" _is_coroutine \" , False )","title":"is_coroutine"},{"location":"reference/hug/introspect/#is_method","text":"def ( function ) Returns True if the passed in function is identified as a method (NOT a function) View Source def is_method ( function ) : \"\"\" Returns True if the passed in function is identified as a method (NOT a function) \"\"\" return isinstance ( function , MethodType )","title":"is_method"},{"location":"reference/hug/introspect/#name","text":"def ( function ) Returns the name of a function View Source def name ( function ) : \"\"\" Returns the name of a function \"\"\" return function . __name__","title":"name"},{"location":"reference/hug/introspect/#takes_all_arguments","text":"def ( function , * named_arguments ) Returns True if all supplied arguments are found in the function View Source def takes_all_arguments ( function , * named_arguments ) : \"\"\" Returns True if all supplied arguments are found in the function \"\"\" return bool ( takes_arguments ( function , * named_arguments ) == set ( named_arguments ))","title":"takes_all_arguments"},{"location":"reference/hug/introspect/#takes_args","text":"def ( function ) Returns True if the supplied functions takes extra non-keyword arguments View Source def takes_args ( function ) : \"\"\" Returns True if the supplied functions takes extra non-keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x04 )","title":"takes_args"},{"location":"reference/hug/introspect/#takes_arguments","text":"def ( function , * named_arguments ) Returns the arguments that a function takes from a list of requested arguments View Source def takes_arguments ( function , * named_arguments ) : \"\"\" Returns the arguments that a function takes from a list of requested arguments \"\"\" return set ( named_arguments ) . intersection ( arguments ( function ))","title":"takes_arguments"},{"location":"reference/hug/introspect/#takes_kwargs","text":"def ( function ) Returns True if the supplied function takes keyword arguments View Source def takes_kwargs ( function ) : \"\"\" Returns True if the supplied function takes keyword arguments \"\"\" return bool ( function . __code__ . co_flags & 0 x08 )","title":"takes_kwargs"},{"location":"reference/hug/json_module/","text":"Module hug.json_module View Source import os HUG_USE_UJSON = bool ( os . environ . get ( \"HUG_USE_UJSON\" , 1 )) try : # pragma: no cover if HUG_USE_UJSON : import ujson as json class dumps_proxy : # noqa: N801 \"\"\"Proxies the call so non supported kwargs are skipped and it enables escape_forward_slashes to simulate built-in json \"\"\" _dumps = json . dumps def __call__ ( self , * args , ** kwargs ): kwargs . pop ( \"default\" , None ) kwargs . pop ( \"separators\" , None ) kwargs . update ( escape_forward_slashes = False ) try : return self . _dumps ( * args , ** kwargs ) except Exception as exc : raise TypeError ( \"Type[ujson] is not Serializable\" , exc ) json . dumps = dumps_proxy () else : import json except ImportError : # pragma: no cover import json Variables HUG_USE_UJSON","title":"Json Module"},{"location":"reference/hug/json_module/#module-hugjson_module","text":"View Source import os HUG_USE_UJSON = bool ( os . environ . get ( \"HUG_USE_UJSON\" , 1 )) try : # pragma: no cover if HUG_USE_UJSON : import ujson as json class dumps_proxy : # noqa: N801 \"\"\"Proxies the call so non supported kwargs are skipped and it enables escape_forward_slashes to simulate built-in json \"\"\" _dumps = json . dumps def __call__ ( self , * args , ** kwargs ): kwargs . pop ( \"default\" , None ) kwargs . pop ( \"separators\" , None ) kwargs . update ( escape_forward_slashes = False ) try : return self . _dumps ( * args , ** kwargs ) except Exception as exc : raise TypeError ( \"Type[ujson] is not Serializable\" , exc ) json . dumps = dumps_proxy () else : import json except ImportError : # pragma: no cover import json","title":"Module hug.json_module"},{"location":"reference/hug/json_module/#variables","text":"HUG_USE_UJSON","title":"Variables"},{"location":"reference/hug/middleware/","text":"Module hug.middleware hug/middleware.py A collection of useful middlewares to automate common hug functionality Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/middleware.py A collection of useful middlewares to automate common hug functionality Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import logging import re import uuid from datetime import datetime class SessionMiddleware ( object ) : \"\"\" Simple session middleware. Injects a session dictionary into the context of a request , sets a session cookie , and stores / restores data via a coupled store object . A session store object must implement the following methods : * get ( session_id ) - return session data * exists ( session_id ) - return boolean if session ID exists or not * set ( session_id , session_data ) - save session data for given session ID The name of the context key can be set via the ' context_name ' argument . The cookie arguments are the same as for falcons set_cookie () function , just prefixed with ' cookie_ ' . \"\"\" __slots__ = ( \" store \" , \" context_name \" , \" cookie_name \" , \" cookie_expires \" , \" cookie_max_age \" , \" cookie_domain \" , \" cookie_path \" , \" cookie_secure \" , \" cookie_http_only \" , ) def __init__ ( self , store , context_name = \" session \" , cookie_name = \" sid \" , cookie_expires = None , cookie_max_age = None , cookie_domain = None , cookie_path = None , cookie_secure = True , cookie_http_only = True , ) : self . store = store self . context_name = context_name self . cookie_name = cookie_name self . cookie_expires = cookie_expires self . cookie_max_age = cookie_max_age self . cookie_domain = cookie_domain self . cookie_path = cookie_path self . cookie_secure = cookie_secure self . cookie_http_only = cookie_http_only def generate_sid ( self ) : \"\"\" Generate a UUID4 string. \"\"\" return str ( uuid . uuid4 ()) def process_request ( self , request , response ) : \"\"\" Get session ID from cookie, load corresponding session data from coupled store and inject session data into the request context . \"\"\" sid = request . cookies . get ( self . cookie_name , None ) data = {} if sid is not None : if self . store . exists ( sid ) : data = self . store . get ( sid ) request . context . update ( { self . context_name : data } ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Save request context in coupled store object. Set cookie containing a session ID. \"\"\" sid = request . cookies . get ( self . cookie_name , None ) if sid is None or not self . store . exists ( sid ) : sid = self . generate_sid () self . store . set ( sid , request . context . get ( self . context_name , {} )) response . set_cookie ( self . cookie_name , sid , expires = self . cookie_expires , max_age = self . cookie_max_age , domain = self . cookie_domain , path = self . cookie_path , secure = self . cookie_secure , http_only = self . cookie_http_only , ) class LogMiddleware ( object ) : \"\"\" A middleware that logs all incoming requests and outgoing responses that make their way through the API \"\"\" __slots__ = ( \" logger \" , ) def __init__ ( self , logger = None ) : self . logger = logger if logger is not None else logging . getLogger ( \" hug \" ) def _generate_combined_log ( self , request , response ) : \"\"\" Given a request/response pair, generate a logging format similar to the NGINX combined style. \"\"\" current_time = datetime . utcnow () data_len = \" - \" if response . data is None else len ( response . data ) return \" {0} - - [{1}] {2} {3} {4} {5} {6} \" . format ( request . remote_addr , current_time , request . method , request . relative_uri , response . status , data_len , request . user_agent , ) def process_request ( self , request , response ) : \"\"\" Logs the basic endpoint requested \"\"\" self . logger . info ( \" Requested: {0} {1} {2} \" . format ( request . method , request . relative_uri , request . content_type ) ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Logs the basic data returned by the API \"\"\" self . logger . info ( self . _generate_combined_log ( request , response )) class CORSMiddleware ( object ) : \"\"\" A middleware for allowing cross-origin request sharing (CORS) Adds appropriate Access - Control -* headers to the HTTP responses returned from the hug API , especially for HTTP OPTIONS responses used in CORS preflighting . \"\"\" __slots__ = ( \" api \" , \" allow_origins \" , \" allow_credentials \" , \" max_age \" ) def __init__ ( self , api , allow_origins : list = None , allow_credentials : bool = True , max_age : int = None ) : if allow_origins is None : allow_origins = [ \" * \" ] self . api = api self . allow_origins = allow_origins self . allow_credentials = allow_credentials self . max_age = max_age def match_route ( self , reqpath ) : \"\"\" Match a request with parameter to it's corresponding route \"\"\" route_dicts = [ routes for _ , routes in self . api . http . routes . items () ][ 0 ] routes = [ route for route , _ in route_dicts . items () ] if reqpath not in routes : for route in routes : # replace params in route with regex reqpath = re . sub ( \" ^(/v\\d*/?) \" , \" / \" , reqpath ) base_url = getattr ( self . api . http , \" base_url \" , \"\" ) reqpath = reqpath . replace ( base_url , \"\" , 1 ) if base_url else reqpath if re . match ( re . sub ( r \" /{[^{}]+} \" , \" .+ \" , route ) + \" $ \" , reqpath , re . DOTALL ) : return route return reqpath def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Add CORS headers to the response \"\"\" response . set_header ( \" Access-Control-Allow-Credentials \" , str ( self . allow_credentials ) . lower ()) origin = request . get_header ( \" ORIGIN \" ) if origin and ( origin in self . allow_origins ) or ( \" * \" in self . allow_origins ) : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) if request . method == \" OPTIONS \" : # check if we are handling a preflight request allowed_methods = set ( method for _ , routes in self . api . http . routes . items () for method , _ in routes [ self . match_route ( request . path ) ]. items () ) allowed_methods . add ( \" OPTIONS \" ) # return allowed methods response . set_header ( \" Access-Control-Allow-Methods \" , \" , \" . join ( allowed_methods )) response . set_header ( \" Allow \" , \" , \" . join ( allowed_methods )) # get all requested headers and echo them back requested_headers = request . get_header ( \" Access-Control-Request-Headers \" ) response . set_header ( \" Access-Control-Allow-Headers \" , requested_headers or \"\" ) # return valid caching time if self . max_age : response . set_header ( \" Access-Control-Max-Age \" , self . max_age ) Classes CORSMiddleware class ( api , allow_origins : list = None , allow_credentials : bool = True , max_age : int = None ) A middleware for allowing cross-origin request sharing (CORS) Adds appropriate Access-Control-* headers to the HTTP responses returned from the hug API, especially for HTTP OPTIONS responses used in CORS preflighting. View Source class CORSMiddleware ( object ) : \"\"\" A middleware for allowing cross-origin request sharing (CORS) Adds appropriate Access - Control -* headers to the HTTP responses returned from the hug API , especially for HTTP OPTIONS responses used in CORS preflighting . \"\"\" __slots__ = ( \" api \" , \" allow_origins \" , \" allow_credentials \" , \" max_age \" ) def __init__ ( self , api , allow_origins : list = None , allow_credentials : bool = True , max_age : int = None ) : if allow_origins is None : allow_origins = [ \" * \" ] self . api = api self . allow_origins = allow_origins self . allow_credentials = allow_credentials self . max_age = max_age def match_route ( self , reqpath ) : \"\"\" Match a request with parameter to it's corresponding route \"\"\" route_dicts = [ routes for _ , routes in self . api . http . routes . items () ][ 0 ] routes = [ route for route , _ in route_dicts . items () ] if reqpath not in routes : for route in routes : # replace params in route with regex reqpath = re . sub ( \" ^(/v\\d*/?) \" , \" / \" , reqpath ) base_url = getattr ( self . api . http , \" base_url \" , \"\" ) reqpath = reqpath . replace ( base_url , \"\" , 1 ) if base_url else reqpath if re . match ( re . sub ( r \" /{[^{}]+} \" , \" .+ \" , route ) + \" $ \" , reqpath , re . DOTALL ) : return route return reqpath def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Add CORS headers to the response \"\"\" response . set_header ( \" Access-Control-Allow-Credentials \" , str ( self . allow_credentials ) . lower ()) origin = request . get_header ( \" ORIGIN \" ) if origin and ( origin in self . allow_origins ) or ( \" * \" in self . allow_origins ) : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) if request . method == \" OPTIONS \" : # check if we are handling a preflight request allowed_methods = set ( method for _ , routes in self . api . http . routes . items () for method , _ in routes [ self . match_route ( request . path ) ]. items () ) allowed_methods . add ( \" OPTIONS \" ) # return allowed methods response . set_header ( \" Access-Control-Allow-Methods \" , \" , \" . join ( allowed_methods )) response . set_header ( \" Allow \" , \" , \" . join ( allowed_methods )) # get all requested headers and echo them back requested_headers = request . get_header ( \" Access-Control-Request-Headers \" ) response . set_header ( \" Access-Control-Allow-Headers \" , requested_headers or \"\" ) # return valid caching time if self . max_age : response . set_header ( \" Access-Control-Max-Age \" , self . max_age ) LogMiddleware class ( logger = None ) A middleware that logs all incoming requests and outgoing responses that make their way through the API View Source class LogMiddleware ( object ) : \"\"\" A middleware that logs all incoming requests and outgoing responses that make their way through the API \"\"\" __slots__ = ( \" logger \" , ) def __init__ ( self , logger = None ) : self . logger = logger if logger is not None else logging . getLogger ( \" hug \" ) def _generate_combined_log ( self , request , response ) : \"\"\" Given a request/response pair, generate a logging format similar to the NGINX combined style. \"\"\" current_time = datetime . utcnow () data_len = \" - \" if response . data is None else len ( response . data ) return \" {0} - - [{1}] {2} {3} {4} {5} {6} \" . format ( request . remote_addr , current_time , request . method , request . relative_uri , response . status , data_len , request . user_agent , ) def process_request ( self , request , response ) : \"\"\" Logs the basic endpoint requested \"\"\" self . logger . info ( \" Requested: {0} {1} {2} \" . format ( request . method , request . relative_uri , request . content_type ) ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Logs the basic data returned by the API \"\"\" self . logger . info ( self . _generate_combined_log ( request , response )) SessionMiddleware class ( store , context_name = 'session' , cookie_name = 'sid' , cookie_expires = None , cookie_max_age = None , cookie_domain = None , cookie_path = None , cookie_secure = True , cookie_http_only = True ) Simple session middleware. Injects a session dictionary into the context of a request, sets a session cookie, and stores/restores data via a coupled store object. A session store object must implement the following methods: * get(session_id) - return session data * exists(session_id) - return boolean if session ID exists or not * set(session_id, session_data) - save session data for given session ID The name of the context key can be set via the 'context_name' argument. The cookie arguments are the same as for falcons set_cookie() function, just prefixed with 'cookie_'. View Source class SessionMiddleware ( object ) : \"\"\" Simple session middleware. Injects a session dictionary into the context of a request , sets a session cookie , and stores / restores data via a coupled store object . A session store object must implement the following methods : * get ( session_id ) - return session data * exists ( session_id ) - return boolean if session ID exists or not * set ( session_id , session_data ) - save session data for given session ID The name of the context key can be set via the ' context_name ' argument . The cookie arguments are the same as for falcons set_cookie () function , just prefixed with ' cookie_ ' . \"\"\" __slots__ = ( \" store \" , \" context_name \" , \" cookie_name \" , \" cookie_expires \" , \" cookie_max_age \" , \" cookie_domain \" , \" cookie_path \" , \" cookie_secure \" , \" cookie_http_only \" , ) def __init__ ( self , store , context_name = \" session \" , cookie_name = \" sid \" , cookie_expires = None , cookie_max_age = None , cookie_domain = None , cookie_path = None , cookie_secure = True , cookie_http_only = True , ) : self . store = store self . context_name = context_name self . cookie_name = cookie_name self . cookie_expires = cookie_expires self . cookie_max_age = cookie_max_age self . cookie_domain = cookie_domain self . cookie_path = cookie_path self . cookie_secure = cookie_secure self . cookie_http_only = cookie_http_only def generate_sid ( self ) : \"\"\" Generate a UUID4 string. \"\"\" return str ( uuid . uuid4 ()) def process_request ( self , request , response ) : \"\"\" Get session ID from cookie, load corresponding session data from coupled store and inject session data into the request context . \"\"\" sid = request . cookies . get ( self . cookie_name , None ) data = {} if sid is not None : if self . store . exists ( sid ) : data = self . store . get ( sid ) request . context . update ( { self . context_name : data } ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Save request context in coupled store object. Set cookie containing a session ID. \"\"\" sid = request . cookies . get ( self . cookie_name , None ) if sid is None or not self . store . exists ( sid ) : sid = self . generate_sid () self . store . set ( sid , request . context . get ( self . context_name , {} )) response . set_cookie ( self . cookie_name , sid , expires = self . cookie_expires , max_age = self . cookie_max_age , domain = self . cookie_domain , path = self . cookie_path , secure = self . cookie_secure , http_only = self . cookie_http_only , )","title":"Middleware"},{"location":"reference/hug/middleware/#module-hugmiddleware","text":"hug/middleware.py A collection of useful middlewares to automate common hug functionality Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/middleware.py A collection of useful middlewares to automate common hug functionality Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import logging import re import uuid from datetime import datetime class SessionMiddleware ( object ) : \"\"\" Simple session middleware. Injects a session dictionary into the context of a request , sets a session cookie , and stores / restores data via a coupled store object . A session store object must implement the following methods : * get ( session_id ) - return session data * exists ( session_id ) - return boolean if session ID exists or not * set ( session_id , session_data ) - save session data for given session ID The name of the context key can be set via the ' context_name ' argument . The cookie arguments are the same as for falcons set_cookie () function , just prefixed with ' cookie_ ' . \"\"\" __slots__ = ( \" store \" , \" context_name \" , \" cookie_name \" , \" cookie_expires \" , \" cookie_max_age \" , \" cookie_domain \" , \" cookie_path \" , \" cookie_secure \" , \" cookie_http_only \" , ) def __init__ ( self , store , context_name = \" session \" , cookie_name = \" sid \" , cookie_expires = None , cookie_max_age = None , cookie_domain = None , cookie_path = None , cookie_secure = True , cookie_http_only = True , ) : self . store = store self . context_name = context_name self . cookie_name = cookie_name self . cookie_expires = cookie_expires self . cookie_max_age = cookie_max_age self . cookie_domain = cookie_domain self . cookie_path = cookie_path self . cookie_secure = cookie_secure self . cookie_http_only = cookie_http_only def generate_sid ( self ) : \"\"\" Generate a UUID4 string. \"\"\" return str ( uuid . uuid4 ()) def process_request ( self , request , response ) : \"\"\" Get session ID from cookie, load corresponding session data from coupled store and inject session data into the request context . \"\"\" sid = request . cookies . get ( self . cookie_name , None ) data = {} if sid is not None : if self . store . exists ( sid ) : data = self . store . get ( sid ) request . context . update ( { self . context_name : data } ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Save request context in coupled store object. Set cookie containing a session ID. \"\"\" sid = request . cookies . get ( self . cookie_name , None ) if sid is None or not self . store . exists ( sid ) : sid = self . generate_sid () self . store . set ( sid , request . context . get ( self . context_name , {} )) response . set_cookie ( self . cookie_name , sid , expires = self . cookie_expires , max_age = self . cookie_max_age , domain = self . cookie_domain , path = self . cookie_path , secure = self . cookie_secure , http_only = self . cookie_http_only , ) class LogMiddleware ( object ) : \"\"\" A middleware that logs all incoming requests and outgoing responses that make their way through the API \"\"\" __slots__ = ( \" logger \" , ) def __init__ ( self , logger = None ) : self . logger = logger if logger is not None else logging . getLogger ( \" hug \" ) def _generate_combined_log ( self , request , response ) : \"\"\" Given a request/response pair, generate a logging format similar to the NGINX combined style. \"\"\" current_time = datetime . utcnow () data_len = \" - \" if response . data is None else len ( response . data ) return \" {0} - - [{1}] {2} {3} {4} {5} {6} \" . format ( request . remote_addr , current_time , request . method , request . relative_uri , response . status , data_len , request . user_agent , ) def process_request ( self , request , response ) : \"\"\" Logs the basic endpoint requested \"\"\" self . logger . info ( \" Requested: {0} {1} {2} \" . format ( request . method , request . relative_uri , request . content_type ) ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Logs the basic data returned by the API \"\"\" self . logger . info ( self . _generate_combined_log ( request , response )) class CORSMiddleware ( object ) : \"\"\" A middleware for allowing cross-origin request sharing (CORS) Adds appropriate Access - Control -* headers to the HTTP responses returned from the hug API , especially for HTTP OPTIONS responses used in CORS preflighting . \"\"\" __slots__ = ( \" api \" , \" allow_origins \" , \" allow_credentials \" , \" max_age \" ) def __init__ ( self , api , allow_origins : list = None , allow_credentials : bool = True , max_age : int = None ) : if allow_origins is None : allow_origins = [ \" * \" ] self . api = api self . allow_origins = allow_origins self . allow_credentials = allow_credentials self . max_age = max_age def match_route ( self , reqpath ) : \"\"\" Match a request with parameter to it's corresponding route \"\"\" route_dicts = [ routes for _ , routes in self . api . http . routes . items () ][ 0 ] routes = [ route for route , _ in route_dicts . items () ] if reqpath not in routes : for route in routes : # replace params in route with regex reqpath = re . sub ( \" ^(/v\\d*/?) \" , \" / \" , reqpath ) base_url = getattr ( self . api . http , \" base_url \" , \"\" ) reqpath = reqpath . replace ( base_url , \"\" , 1 ) if base_url else reqpath if re . match ( re . sub ( r \" /{[^{}]+} \" , \" .+ \" , route ) + \" $ \" , reqpath , re . DOTALL ) : return route return reqpath def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Add CORS headers to the response \"\"\" response . set_header ( \" Access-Control-Allow-Credentials \" , str ( self . allow_credentials ) . lower ()) origin = request . get_header ( \" ORIGIN \" ) if origin and ( origin in self . allow_origins ) or ( \" * \" in self . allow_origins ) : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) if request . method == \" OPTIONS \" : # check if we are handling a preflight request allowed_methods = set ( method for _ , routes in self . api . http . routes . items () for method , _ in routes [ self . match_route ( request . path ) ]. items () ) allowed_methods . add ( \" OPTIONS \" ) # return allowed methods response . set_header ( \" Access-Control-Allow-Methods \" , \" , \" . join ( allowed_methods )) response . set_header ( \" Allow \" , \" , \" . join ( allowed_methods )) # get all requested headers and echo them back requested_headers = request . get_header ( \" Access-Control-Request-Headers \" ) response . set_header ( \" Access-Control-Allow-Headers \" , requested_headers or \"\" ) # return valid caching time if self . max_age : response . set_header ( \" Access-Control-Max-Age \" , self . max_age )","title":"Module hug.middleware"},{"location":"reference/hug/middleware/#classes","text":"","title":"Classes"},{"location":"reference/hug/middleware/#corsmiddleware","text":"class ( api , allow_origins : list = None , allow_credentials : bool = True , max_age : int = None ) A middleware for allowing cross-origin request sharing (CORS) Adds appropriate Access-Control-* headers to the HTTP responses returned from the hug API, especially for HTTP OPTIONS responses used in CORS preflighting. View Source class CORSMiddleware ( object ) : \"\"\" A middleware for allowing cross-origin request sharing (CORS) Adds appropriate Access - Control -* headers to the HTTP responses returned from the hug API , especially for HTTP OPTIONS responses used in CORS preflighting . \"\"\" __slots__ = ( \" api \" , \" allow_origins \" , \" allow_credentials \" , \" max_age \" ) def __init__ ( self , api , allow_origins : list = None , allow_credentials : bool = True , max_age : int = None ) : if allow_origins is None : allow_origins = [ \" * \" ] self . api = api self . allow_origins = allow_origins self . allow_credentials = allow_credentials self . max_age = max_age def match_route ( self , reqpath ) : \"\"\" Match a request with parameter to it's corresponding route \"\"\" route_dicts = [ routes for _ , routes in self . api . http . routes . items () ][ 0 ] routes = [ route for route , _ in route_dicts . items () ] if reqpath not in routes : for route in routes : # replace params in route with regex reqpath = re . sub ( \" ^(/v\\d*/?) \" , \" / \" , reqpath ) base_url = getattr ( self . api . http , \" base_url \" , \"\" ) reqpath = reqpath . replace ( base_url , \"\" , 1 ) if base_url else reqpath if re . match ( re . sub ( r \" /{[^{}]+} \" , \" .+ \" , route ) + \" $ \" , reqpath , re . DOTALL ) : return route return reqpath def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Add CORS headers to the response \"\"\" response . set_header ( \" Access-Control-Allow-Credentials \" , str ( self . allow_credentials ) . lower ()) origin = request . get_header ( \" ORIGIN \" ) if origin and ( origin in self . allow_origins ) or ( \" * \" in self . allow_origins ) : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) if request . method == \" OPTIONS \" : # check if we are handling a preflight request allowed_methods = set ( method for _ , routes in self . api . http . routes . items () for method , _ in routes [ self . match_route ( request . path ) ]. items () ) allowed_methods . add ( \" OPTIONS \" ) # return allowed methods response . set_header ( \" Access-Control-Allow-Methods \" , \" , \" . join ( allowed_methods )) response . set_header ( \" Allow \" , \" , \" . join ( allowed_methods )) # get all requested headers and echo them back requested_headers = request . get_header ( \" Access-Control-Request-Headers \" ) response . set_header ( \" Access-Control-Allow-Headers \" , requested_headers or \"\" ) # return valid caching time if self . max_age : response . set_header ( \" Access-Control-Max-Age \" , self . max_age )","title":"CORSMiddleware"},{"location":"reference/hug/middleware/#logmiddleware","text":"class ( logger = None ) A middleware that logs all incoming requests and outgoing responses that make their way through the API View Source class LogMiddleware ( object ) : \"\"\" A middleware that logs all incoming requests and outgoing responses that make their way through the API \"\"\" __slots__ = ( \" logger \" , ) def __init__ ( self , logger = None ) : self . logger = logger if logger is not None else logging . getLogger ( \" hug \" ) def _generate_combined_log ( self , request , response ) : \"\"\" Given a request/response pair, generate a logging format similar to the NGINX combined style. \"\"\" current_time = datetime . utcnow () data_len = \" - \" if response . data is None else len ( response . data ) return \" {0} - - [{1}] {2} {3} {4} {5} {6} \" . format ( request . remote_addr , current_time , request . method , request . relative_uri , response . status , data_len , request . user_agent , ) def process_request ( self , request , response ) : \"\"\" Logs the basic endpoint requested \"\"\" self . logger . info ( \" Requested: {0} {1} {2} \" . format ( request . method , request . relative_uri , request . content_type ) ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Logs the basic data returned by the API \"\"\" self . logger . info ( self . _generate_combined_log ( request , response ))","title":"LogMiddleware"},{"location":"reference/hug/middleware/#sessionmiddleware","text":"class ( store , context_name = 'session' , cookie_name = 'sid' , cookie_expires = None , cookie_max_age = None , cookie_domain = None , cookie_path = None , cookie_secure = True , cookie_http_only = True ) Simple session middleware. Injects a session dictionary into the context of a request, sets a session cookie, and stores/restores data via a coupled store object. A session store object must implement the following methods: * get(session_id) - return session data * exists(session_id) - return boolean if session ID exists or not * set(session_id, session_data) - save session data for given session ID The name of the context key can be set via the 'context_name' argument. The cookie arguments are the same as for falcons set_cookie() function, just prefixed with 'cookie_'. View Source class SessionMiddleware ( object ) : \"\"\" Simple session middleware. Injects a session dictionary into the context of a request , sets a session cookie , and stores / restores data via a coupled store object . A session store object must implement the following methods : * get ( session_id ) - return session data * exists ( session_id ) - return boolean if session ID exists or not * set ( session_id , session_data ) - save session data for given session ID The name of the context key can be set via the ' context_name ' argument . The cookie arguments are the same as for falcons set_cookie () function , just prefixed with ' cookie_ ' . \"\"\" __slots__ = ( \" store \" , \" context_name \" , \" cookie_name \" , \" cookie_expires \" , \" cookie_max_age \" , \" cookie_domain \" , \" cookie_path \" , \" cookie_secure \" , \" cookie_http_only \" , ) def __init__ ( self , store , context_name = \" session \" , cookie_name = \" sid \" , cookie_expires = None , cookie_max_age = None , cookie_domain = None , cookie_path = None , cookie_secure = True , cookie_http_only = True , ) : self . store = store self . context_name = context_name self . cookie_name = cookie_name self . cookie_expires = cookie_expires self . cookie_max_age = cookie_max_age self . cookie_domain = cookie_domain self . cookie_path = cookie_path self . cookie_secure = cookie_secure self . cookie_http_only = cookie_http_only def generate_sid ( self ) : \"\"\" Generate a UUID4 string. \"\"\" return str ( uuid . uuid4 ()) def process_request ( self , request , response ) : \"\"\" Get session ID from cookie, load corresponding session data from coupled store and inject session data into the request context . \"\"\" sid = request . cookies . get ( self . cookie_name , None ) data = {} if sid is not None : if self . store . exists ( sid ) : data = self . store . get ( sid ) request . context . update ( { self . context_name : data } ) def process_response ( self , request , response , resource , req_succeeded ) : \"\"\" Save request context in coupled store object. Set cookie containing a session ID. \"\"\" sid = request . cookies . get ( self . cookie_name , None ) if sid is None or not self . store . exists ( sid ) : sid = self . generate_sid () self . store . set ( sid , request . context . get ( self . context_name , {} )) response . set_cookie ( self . cookie_name , sid , expires = self . cookie_expires , max_age = self . cookie_max_age , domain = self . cookie_domain , path = self . cookie_path , secure = self . cookie_secure , http_only = self . cookie_http_only , )","title":"SessionMiddleware"},{"location":"reference/hug/output_format/","text":"Module hug.output_format hug/output_format.py Defines Hug's built-in output formatting methods Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/output_format.py Defines Hug ' s built-in output formatting methods Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import base64 import mimetypes import os import re import tempfile from datetime import date , datetime , timedelta from decimal import Decimal from functools import wraps from io import BytesIO from operator import itemgetter from uuid import UUID import falcon from falcon import HTTP_NOT_FOUND from hug import introspect from hug . format import camelcase , content_type from hug . json_module import json as json_converter try : import numpy except ImportError : numpy = False IMAGE_TYPES = ( \" png \" , \" jpg \" , \" bmp \" , \" eps \" , \" gif \" , \" im \" , \" jpeg \" , \" msp \" , \" pcx \" , \" ppm \" , \" spider \" , \" tiff \" , \" webp \" , \" xbm \" , \" cur \" , \" dcx \" , \" fli \" , \" flc \" , \" gbr \" , \" gd \" , \" ico \" , \" icns \" , \" imt \" , \" iptc \" , \" naa \" , \" mcidas \" , \" mpo \" , \" pcd \" , \" psd \" , \" sgi \" , \" tga \" , \" wal \" , \" xpm \" , \" svg \" , \" svg+xml \" , ) VIDEO_TYPES = ( ( \" flv \" , \" video/x-flv \" ) , ( \" mp4 \" , \" video/mp4 \" ) , ( \" m3u8 \" , \" application/x-mpegURL \" ) , ( \" ts \" , \" video/MP2T \" ) , ( \" 3gp \" , \" video/3gpp \" ) , ( \" mov \" , \" video/quicktime \" ) , ( \" avi \" , \" video/x-msvideo \" ) , ( \" wmv \" , \" video/x-ms-wmv \" ) , ) RE_ACCEPT_QUALITY = re . compile ( \" q=(?P<quality>[^;]+) \" ) json_converters = {} stream = tempfile . NamedTemporaryFile if \" UWSGI_ORIGINAL_PROC_NAME \" in os . environ else BytesIO def _json_converter ( item ) : if hasattr ( item , \" __native_types__ \" ) : return item . __native_types__ () for kind , transformer in json_converters . items () : if isinstance ( item , kind ) : return transformer ( item ) if isinstance ( item , ( date , datetime )) : return item . isoformat () elif isinstance ( item , bytes ) : try : return item . decode ( \" utf8 \" ) except UnicodeDecodeError : return base64 . b64encode ( item ) elif hasattr ( item , \" __iter__ \" ) : return list ( item ) elif isinstance ( item , ( Decimal , UUID )) : return str ( item ) elif isinstance ( item , timedelta ) : return item . total_seconds () raise TypeError ( \" Type not serializable \" ) def json_convert ( * kinds ) : \"\"\" Registers the wrapped method as a JSON converter for the provided types. NOTE : custom converters are always globally applied \"\"\" def register_json_converter ( function ) : for kind in kinds : json_converters [ kind ] = function return function return register_json_converter if numpy : @ json_convert ( numpy . ndarray ) def numpy_listable ( item ) : return item . tolist () @ json_convert ( str , numpy . unicode_ ) def numpy_stringable ( item ) : return str ( item ) @ json_convert ( numpy . bytes_ ) def numpy_byte_decodeable ( item ) : return item . decode () @ json_convert ( numpy . bool_ ) def numpy_boolable ( item ) : return bool ( item ) @ json_convert ( numpy . integer ) def numpy_integerable ( item ) : return int ( item ) @ json_convert ( float , numpy . floating ) def numpy_floatable ( item ) : return float ( item ) @ content_type ( \" application/json; charset=utf-8 \" ) def json ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) \"\"\" if hasattr ( content , \" read \" ) : return content if isinstance ( content , tuple ) and getattr ( content , \" _fields \" , None ) : content = { field : getattr ( content , field ) for field in content . _fields } return json_converter . dumps ( content , default = _json_converter , ensure_ascii = ensure_ascii , ** kwargs ) . encode ( \" utf8 \" ) def on_valid ( valid_content_type , on_invalid = json ) : \"\"\" Renders as the specified content type only if no errors are found in the provided data object \"\"\" invalid_kwargs = introspect . generate_accepted_kwargs ( on_invalid , \" request \" , \" response \" ) invalid_takes_response = introspect . takes_all_arguments ( on_invalid , \" response \" ) def wrapper ( function ) : valid_kwargs = introspect . generate_accepted_kwargs ( function , \" request \" , \" response \" ) valid_takes_response = introspect . takes_all_arguments ( function , \" response \" ) @ content_type ( valid_content_type ) @ wraps ( function ) def output_content ( content , response , ** kwargs ) : if type ( content ) == dict and \" errors \" in content : response . content_type = on_invalid . content_type if invalid_takes_response : kwargs [ \" response \" ] = response return on_invalid ( content , ** invalid_kwargs ( kwargs )) if valid_takes_response : kwargs [ \" response \" ] = response return function ( content , ** valid_kwargs ( kwargs )) return output_content return wrapper @ content_type ( \" text/plain; charset=utf-8 \" ) def text ( content , ** kwargs ) : \"\"\" Free form UTF-8 text \"\"\" if hasattr ( content , \" read \" ) : return content return str ( content ) . encode ( \" utf8 \" ) @ content_type ( \" text/html; charset=utf-8 \" ) def html ( content , ** kwargs ) : \"\"\" HTML (Hypertext Markup Language) \"\"\" if hasattr ( content , \" read \" ) : return content elif hasattr ( content , \" render \" ) : return content . render () . encode ( \" utf8 \" ) return str ( content ) . encode ( \" utf8 \" ) def _camelcase ( content ) : if isinstance ( content , dict ) : new_dictionary = {} for key , value in content . items () : if isinstance ( key , str ) : key = camelcase ( key ) new_dictionary [ key ] = _camelcase ( value ) return new_dictionary elif isinstance ( content , list ) : new_list = [] for element in content : new_list . append ( _camelcase ( element )) return new_list else : return content @ content_type ( \" application/json; charset=utf-8 \" ) def json_camelcase ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) with all keys camelCased \"\"\" return json ( _camelcase ( content ) , ** kwargs ) @ content_type ( \" application/json; charset=utf-8 \" ) def pretty_json ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notion) pretty printed and indented \"\"\" return json ( content , indent = 4 , separators = ( \" , \" , \" : \" ) , ** kwargs ) def image ( image_format , doc = None ) : \"\"\" Dynamically creates an image type handler for the specified image type \"\"\" @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) image_handler . __doc__ = doc or \" {0} formatted image \" . format ( image_format ) return image_handler for image_type in IMAGE_TYPES : globals () [ \" {0}_image \" . format ( image_type . replace ( \" + \" , \" _ \" )) ] = image ( image_type ) def video ( video_type , video_mime , doc = None ) : \"\"\" Dynamically creates a video type handler for the specified video type \"\"\" @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) video_handler . __doc__ = doc or \" {0} formatted video \" . format ( video_type ) return video_handler for ( video_type , video_mime ) in VIDEO_TYPES : globals () [ \" {0}_video \" . format ( video_type ) ] = video ( video_type , video_mime ) @ on_valid ( \" file/dynamic \" ) def file ( data , response , ** kwargs ) : \"\"\" A dynamically retrieved file \"\"\" if not data : response . content_type = \" text/plain \" return \"\" if hasattr ( data , \" read \" ) : name , data = getattr ( data , \" name \" , \"\" ) , data elif os . path . isfile ( data ) : name , data = data , open ( data , \" rb \" ) else : response . content_type = \" text/plain \" response . status = HTTP_NOT_FOUND return \" File not found! \" response . content_type = mimetypes . guess_type ( name , None ) [ 0 ] or \" application/octet-stream \" return data def on_content_type ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients provided content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : handler = handlers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ or function . __name__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type def accept_quality ( accept , default = 1 ) : \"\"\" Separates out the quality score from the accepted content_type \"\"\" quality = default if accept and \" ; \" in accept : accept , rest = accept . split ( \" ; \" , 1 ) accept_quality = RE_ACCEPT_QUALITY . search ( rest ) if accept_quality : quality = float ( accept_quality . groupdict () . get ( \" quality \" , quality ) . strip ()) return ( quality , accept . strip ()) def accept ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients defined accepted content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : accept = request . accept if accept in ( \"\" , \" * \" , \" / \" ) : handler = default or handlers and next ( iter ( handlers . values ())) else : handler = default accepted = [ accept_quality ( accept_type ) for accept_type in accept . split ( \" , \" ) ] accepted . sort ( key = itemgetter ( 0 )) for _quality , accepted_content_type in reversed ( accepted ) : if accepted_content_type in handlers : handler = handlers [ accepted_content_type ] break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type def suffix ( handlers , default = None , error = \" The requested suffix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the suffix placed at the end of the URL route should pass in a dict with the following format : { ' [suffix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for suffix_test , suffix_handler in handlers . items () : if path . endswith ( suffix_test ) : handler = suffix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type def prefix ( handlers , default = None , error = \" The requested prefix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the prefix placed at the end of the URL route should pass in a dict with the following format : { ' [prefix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for prefix_test , prefix_handler in handlers . items () : if path . startswith ( prefix_test ) : handler = prefix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type Variables HTTP_NOT_FOUND IMAGE_TYPES RE_ACCEPT_QUALITY VIDEO_TYPES image_type json_converters numpy video_mime video_type Functions 3gp_video def ( data , ** kwargs ) 3gp formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) accept def ( handlers , default = None , error = 'The requested content type does not match any of those allowed' ) Returns a content in a different format based on the clients defined accepted content type, should pass in a dict with the following format: { '[content-type]' : action , ... } View Source def accept ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients defined accepted content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : accept = request . accept if accept in ( \"\" , \" * \" , \" / \" ) : handler = default or handlers and next ( iter ( handlers . values ())) else : handler = default accepted = [ accept_quality ( accept_type ) for accept_type in accept . split ( \" , \" ) ] accepted . sort ( key = itemgetter ( 0 )) for _quality , accepted_content_type in reversed ( accepted ) : if accepted_content_type in handlers : handler = handlers [ accepted_content_type ] break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type accept_quality def ( accept , default = 1 ) Separates out the quality score from the accepted content_type View Source def accept_quality ( accept , default = 1 ) : \"\"\" Separates out the quality score from the accepted content_type \"\"\" quality = default if accept and \" ; \" in accept : accept , rest = accept . split ( \" ; \" , 1 ) accept_quality = RE_ACCEPT_QUALITY . search ( rest ) if accept_quality : quality = float ( accept_quality . groupdict () . get ( \" quality \" , quality ) . strip ()) return ( quality , accept . strip ()) avi_video def ( data , ** kwargs ) avi formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) bmp_image def ( data , ** kwargs ) bmp formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) cur_image def ( data , ** kwargs ) cur formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) dcx_image def ( data , ** kwargs ) dcx formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) eps_image def ( data , ** kwargs ) eps formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) file def ( data , response , ** kwargs ) A dynamically retrieved file View Source @ on_valid ( \" file/dynamic \" ) def file ( data , response , ** kwargs ) : \"\"\" A dynamically retrieved file \"\"\" if not data : response . content_type = \" text/plain \" return \"\" if hasattr ( data , \" read \" ) : name , data = getattr ( data , \" name \" , \"\" ) , data elif os . path . isfile ( data ) : name , data = data , open ( data , \" rb \" ) else : response . content_type = \" text/plain \" response . status = HTTP_NOT_FOUND return \" File not found! \" response . content_type = mimetypes . guess_type ( name , None ) [ 0 ] or \" application/octet-stream \" return data flc_image def ( data , ** kwargs ) flc formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) fli_image def ( data , ** kwargs ) fli formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) flv_video def ( data , ** kwargs ) flv formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) gbr_image def ( data , ** kwargs ) gbr formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) gd_image def ( data , ** kwargs ) gd formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) gif_image def ( data , ** kwargs ) gif formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) html def ( content , ** kwargs ) HTML (Hypertext Markup Language) View Source @ content_type ( \" text/html; charset=utf-8 \" ) def html ( content , ** kwargs ) : \"\"\" HTML (Hypertext Markup Language) \"\"\" if hasattr ( content , \" read \" ) : return content elif hasattr ( content , \" render \" ) : return content . render () . encode ( \" utf8 \" ) return str ( content ) . encode ( \" utf8 \" ) icns_image def ( data , ** kwargs ) icns formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) ico_image def ( data , ** kwargs ) ico formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) im_image def ( data , ** kwargs ) im formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) image def ( image_format , doc = None ) Dynamically creates an image type handler for the specified image type View Source def image ( image_format , doc = None ) : \"\"\" Dynamically creates an image type handler for the specified image type \"\"\" @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) image_handler . __doc__ = doc or \" {0} formatted image \" . format ( image_format ) return image_handler imt_image def ( data , ** kwargs ) imt formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) iptc_image def ( data , ** kwargs ) iptc formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) jpeg_image def ( data , ** kwargs ) jpeg formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) jpg_image def ( data , ** kwargs ) jpg formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) json def ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) JSON (Javascript Serialized Object Notation) View Source @ content_type ( \" application/json; charset=utf-8 \" ) def json ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) \"\"\" if hasattr ( content , \" read \" ) : return content if isinstance ( content , tuple ) and getattr ( content , \" _fields \" , None ) : content = { field : getattr ( content , field ) for field in content . _fields } return json_converter . dumps ( content , default = _json_converter , ensure_ascii = ensure_ascii , ** kwargs ) . encode ( \" utf8 \" ) json_camelcase def ( content , ** kwargs ) JSON (Javascript Serialized Object Notation) with all keys camelCased View Source @ content_type ( \" application/json; charset=utf-8 \" ) def json_camelcase ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) with all keys camelCased \"\"\" return json ( _camelcase ( content ) , ** kwargs ) json_convert def ( * kinds ) Registers the wrapped method as a JSON converter for the provided types. NOTE: custom converters are always globally applied View Source def json_convert ( * kinds ) : \"\"\" Registers the wrapped method as a JSON converter for the provided types. NOTE : custom converters are always globally applied \"\"\" def register_json_converter ( function ) : for kind in kinds : json_converters [ kind ] = function return function return register_json_converter m3u8_video def ( data , ** kwargs ) m3u8 formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) mcidas_image def ( data , ** kwargs ) mcidas formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) mov_video def ( data , ** kwargs ) mov formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) mp4_video def ( data , ** kwargs ) mp4 formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) mpo_image def ( data , ** kwargs ) mpo formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) msp_image def ( data , ** kwargs ) msp formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) naa_image def ( data , ** kwargs ) naa formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) on_content_type def ( handlers , default = None , error = 'The requested content type does not match any of those allowed' ) Returns a content in a different format based on the clients provided content type, should pass in a dict with the following format: { '[content-type]' : action , ... } View Source def on_content_type ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients provided content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : handler = handlers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ or function . __name__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type on_valid def ( valid_content_type , on_invalid =< function json at 0x7f0676c7c9d8 > ) Renders as the specified content type only if no errors are found in the provided data object View Source def on_valid ( valid_content_type , on_invalid = json ) : \"\"\" Renders as the specified content type only if no errors are found in the provided data object \"\"\" invalid_kwargs = introspect . generate_accepted_kwargs ( on_invalid , \" request \" , \" response \" ) invalid_takes_response = introspect . takes_all_arguments ( on_invalid , \" response \" ) def wrapper ( function ) : valid_kwargs = introspect . generate_accepted_kwargs ( function , \" request \" , \" response \" ) valid_takes_response = introspect . takes_all_arguments ( function , \" response \" ) @ content_type ( valid_content_type ) @ wraps ( function ) def output_content ( content , response , ** kwargs ) : if type ( content ) == dict and \" errors \" in content : response . content_type = on_invalid . content_type if invalid_takes_response : kwargs [ \" response \" ] = response return on_invalid ( content , ** invalid_kwargs ( kwargs )) if valid_takes_response : kwargs [ \" response \" ] = response return function ( content , ** valid_kwargs ( kwargs )) return output_content return wrapper pcd_image def ( data , ** kwargs ) pcd formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) pcx_image def ( data , ** kwargs ) pcx formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) png_image def ( data , ** kwargs ) png formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) ppm_image def ( data , ** kwargs ) ppm formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) prefix def ( handlers , default = None , error = 'The requested prefix does not match any of those allowed' ) Returns a content in a different format based on the prefix placed at the end of the URL route should pass in a dict with the following format: { '[prefix]' : action , ... } View Source def prefix ( handlers , default = None , error = \" The requested prefix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the prefix placed at the end of the URL route should pass in a dict with the following format : { ' [prefix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for prefix_test , prefix_handler in handlers . items () : if path . startswith ( prefix_test ) : handler = prefix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type pretty_json def ( content , ** kwargs ) JSON (Javascript Serialized Object Notion) pretty printed and indented View Source @ content_type ( \" application/json; charset=utf-8 \" ) def pretty_json ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notion) pretty printed and indented \"\"\" return json ( content , indent = 4 , separators = ( \" , \" , \" : \" ) , ** kwargs ) psd_image def ( data , ** kwargs ) psd formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) sgi_image def ( data , ** kwargs ) sgi formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) spider_image def ( data , ** kwargs ) spider formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) suffix def ( handlers , default = None , error = 'The requested suffix does not match any of those allowed' ) Returns a content in a different format based on the suffix placed at the end of the URL route should pass in a dict with the following format: { '[suffix]' : action , ... } View Source def suffix ( handlers , default = None , error = \" The requested suffix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the suffix placed at the end of the URL route should pass in a dict with the following format : { ' [suffix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for suffix_test , suffix_handler in handlers . items () : if path . endswith ( suffix_test ) : handler = suffix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type svg_image def ( data , ** kwargs ) svg formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) svg_xml_image def ( data , ** kwargs ) svg+xml formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) text def ( content , ** kwargs ) Free form UTF-8 text View Source @ content_type ( \" text/plain; charset=utf-8 \" ) def text ( content , ** kwargs ) : \"\"\" Free form UTF-8 text \"\"\" if hasattr ( content , \" read \" ) : return content return str ( content ) . encode ( \" utf8 \" ) tga_image def ( data , ** kwargs ) tga formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) tiff_image def ( data , ** kwargs ) tiff formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) ts_video def ( data , ** kwargs ) ts formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) video def ( video_type , video_mime , doc = None ) Dynamically creates a video type handler for the specified video type View Source def video ( video_type , video_mime , doc = None ) : \"\"\" Dynamically creates a video type handler for the specified video type \"\"\" @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) video_handler . __doc__ = doc or \" {0} formatted video \" . format ( video_type ) return video_handler wal_image def ( data , ** kwargs ) wal formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) webp_image def ( data , ** kwargs ) webp formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) wmv_video def ( data , ** kwargs ) wmv formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) xbm_image def ( data , ** kwargs ) xbm formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) xpm_image def ( data , ** kwargs ) xpm formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) Classes stream class ( / , * args , ** kwargs ) Buffered I/O implementation using an in-memory bytes buffer. Ancestors (in MRO) _io._BufferedIOBase _io._IOBase","title":"Output Format"},{"location":"reference/hug/output_format/#module-hugoutput_format","text":"hug/output_format.py Defines Hug's built-in output formatting methods Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/output_format.py Defines Hug ' s built-in output formatting methods Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import base64 import mimetypes import os import re import tempfile from datetime import date , datetime , timedelta from decimal import Decimal from functools import wraps from io import BytesIO from operator import itemgetter from uuid import UUID import falcon from falcon import HTTP_NOT_FOUND from hug import introspect from hug . format import camelcase , content_type from hug . json_module import json as json_converter try : import numpy except ImportError : numpy = False IMAGE_TYPES = ( \" png \" , \" jpg \" , \" bmp \" , \" eps \" , \" gif \" , \" im \" , \" jpeg \" , \" msp \" , \" pcx \" , \" ppm \" , \" spider \" , \" tiff \" , \" webp \" , \" xbm \" , \" cur \" , \" dcx \" , \" fli \" , \" flc \" , \" gbr \" , \" gd \" , \" ico \" , \" icns \" , \" imt \" , \" iptc \" , \" naa \" , \" mcidas \" , \" mpo \" , \" pcd \" , \" psd \" , \" sgi \" , \" tga \" , \" wal \" , \" xpm \" , \" svg \" , \" svg+xml \" , ) VIDEO_TYPES = ( ( \" flv \" , \" video/x-flv \" ) , ( \" mp4 \" , \" video/mp4 \" ) , ( \" m3u8 \" , \" application/x-mpegURL \" ) , ( \" ts \" , \" video/MP2T \" ) , ( \" 3gp \" , \" video/3gpp \" ) , ( \" mov \" , \" video/quicktime \" ) , ( \" avi \" , \" video/x-msvideo \" ) , ( \" wmv \" , \" video/x-ms-wmv \" ) , ) RE_ACCEPT_QUALITY = re . compile ( \" q=(?P<quality>[^;]+) \" ) json_converters = {} stream = tempfile . NamedTemporaryFile if \" UWSGI_ORIGINAL_PROC_NAME \" in os . environ else BytesIO def _json_converter ( item ) : if hasattr ( item , \" __native_types__ \" ) : return item . __native_types__ () for kind , transformer in json_converters . items () : if isinstance ( item , kind ) : return transformer ( item ) if isinstance ( item , ( date , datetime )) : return item . isoformat () elif isinstance ( item , bytes ) : try : return item . decode ( \" utf8 \" ) except UnicodeDecodeError : return base64 . b64encode ( item ) elif hasattr ( item , \" __iter__ \" ) : return list ( item ) elif isinstance ( item , ( Decimal , UUID )) : return str ( item ) elif isinstance ( item , timedelta ) : return item . total_seconds () raise TypeError ( \" Type not serializable \" ) def json_convert ( * kinds ) : \"\"\" Registers the wrapped method as a JSON converter for the provided types. NOTE : custom converters are always globally applied \"\"\" def register_json_converter ( function ) : for kind in kinds : json_converters [ kind ] = function return function return register_json_converter if numpy : @ json_convert ( numpy . ndarray ) def numpy_listable ( item ) : return item . tolist () @ json_convert ( str , numpy . unicode_ ) def numpy_stringable ( item ) : return str ( item ) @ json_convert ( numpy . bytes_ ) def numpy_byte_decodeable ( item ) : return item . decode () @ json_convert ( numpy . bool_ ) def numpy_boolable ( item ) : return bool ( item ) @ json_convert ( numpy . integer ) def numpy_integerable ( item ) : return int ( item ) @ json_convert ( float , numpy . floating ) def numpy_floatable ( item ) : return float ( item ) @ content_type ( \" application/json; charset=utf-8 \" ) def json ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) \"\"\" if hasattr ( content , \" read \" ) : return content if isinstance ( content , tuple ) and getattr ( content , \" _fields \" , None ) : content = { field : getattr ( content , field ) for field in content . _fields } return json_converter . dumps ( content , default = _json_converter , ensure_ascii = ensure_ascii , ** kwargs ) . encode ( \" utf8 \" ) def on_valid ( valid_content_type , on_invalid = json ) : \"\"\" Renders as the specified content type only if no errors are found in the provided data object \"\"\" invalid_kwargs = introspect . generate_accepted_kwargs ( on_invalid , \" request \" , \" response \" ) invalid_takes_response = introspect . takes_all_arguments ( on_invalid , \" response \" ) def wrapper ( function ) : valid_kwargs = introspect . generate_accepted_kwargs ( function , \" request \" , \" response \" ) valid_takes_response = introspect . takes_all_arguments ( function , \" response \" ) @ content_type ( valid_content_type ) @ wraps ( function ) def output_content ( content , response , ** kwargs ) : if type ( content ) == dict and \" errors \" in content : response . content_type = on_invalid . content_type if invalid_takes_response : kwargs [ \" response \" ] = response return on_invalid ( content , ** invalid_kwargs ( kwargs )) if valid_takes_response : kwargs [ \" response \" ] = response return function ( content , ** valid_kwargs ( kwargs )) return output_content return wrapper @ content_type ( \" text/plain; charset=utf-8 \" ) def text ( content , ** kwargs ) : \"\"\" Free form UTF-8 text \"\"\" if hasattr ( content , \" read \" ) : return content return str ( content ) . encode ( \" utf8 \" ) @ content_type ( \" text/html; charset=utf-8 \" ) def html ( content , ** kwargs ) : \"\"\" HTML (Hypertext Markup Language) \"\"\" if hasattr ( content , \" read \" ) : return content elif hasattr ( content , \" render \" ) : return content . render () . encode ( \" utf8 \" ) return str ( content ) . encode ( \" utf8 \" ) def _camelcase ( content ) : if isinstance ( content , dict ) : new_dictionary = {} for key , value in content . items () : if isinstance ( key , str ) : key = camelcase ( key ) new_dictionary [ key ] = _camelcase ( value ) return new_dictionary elif isinstance ( content , list ) : new_list = [] for element in content : new_list . append ( _camelcase ( element )) return new_list else : return content @ content_type ( \" application/json; charset=utf-8 \" ) def json_camelcase ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) with all keys camelCased \"\"\" return json ( _camelcase ( content ) , ** kwargs ) @ content_type ( \" application/json; charset=utf-8 \" ) def pretty_json ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notion) pretty printed and indented \"\"\" return json ( content , indent = 4 , separators = ( \" , \" , \" : \" ) , ** kwargs ) def image ( image_format , doc = None ) : \"\"\" Dynamically creates an image type handler for the specified image type \"\"\" @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) image_handler . __doc__ = doc or \" {0} formatted image \" . format ( image_format ) return image_handler for image_type in IMAGE_TYPES : globals () [ \" {0}_image \" . format ( image_type . replace ( \" + \" , \" _ \" )) ] = image ( image_type ) def video ( video_type , video_mime , doc = None ) : \"\"\" Dynamically creates a video type handler for the specified video type \"\"\" @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) video_handler . __doc__ = doc or \" {0} formatted video \" . format ( video_type ) return video_handler for ( video_type , video_mime ) in VIDEO_TYPES : globals () [ \" {0}_video \" . format ( video_type ) ] = video ( video_type , video_mime ) @ on_valid ( \" file/dynamic \" ) def file ( data , response , ** kwargs ) : \"\"\" A dynamically retrieved file \"\"\" if not data : response . content_type = \" text/plain \" return \"\" if hasattr ( data , \" read \" ) : name , data = getattr ( data , \" name \" , \"\" ) , data elif os . path . isfile ( data ) : name , data = data , open ( data , \" rb \" ) else : response . content_type = \" text/plain \" response . status = HTTP_NOT_FOUND return \" File not found! \" response . content_type = mimetypes . guess_type ( name , None ) [ 0 ] or \" application/octet-stream \" return data def on_content_type ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients provided content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : handler = handlers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ or function . __name__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type def accept_quality ( accept , default = 1 ) : \"\"\" Separates out the quality score from the accepted content_type \"\"\" quality = default if accept and \" ; \" in accept : accept , rest = accept . split ( \" ; \" , 1 ) accept_quality = RE_ACCEPT_QUALITY . search ( rest ) if accept_quality : quality = float ( accept_quality . groupdict () . get ( \" quality \" , quality ) . strip ()) return ( quality , accept . strip ()) def accept ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients defined accepted content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : accept = request . accept if accept in ( \"\" , \" * \" , \" / \" ) : handler = default or handlers and next ( iter ( handlers . values ())) else : handler = default accepted = [ accept_quality ( accept_type ) for accept_type in accept . split ( \" , \" ) ] accepted . sort ( key = itemgetter ( 0 )) for _quality , accepted_content_type in reversed ( accepted ) : if accepted_content_type in handlers : handler = handlers [ accepted_content_type ] break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type def suffix ( handlers , default = None , error = \" The requested suffix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the suffix placed at the end of the URL route should pass in a dict with the following format : { ' [suffix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for suffix_test , suffix_handler in handlers . items () : if path . endswith ( suffix_test ) : handler = suffix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type def prefix ( handlers , default = None , error = \" The requested prefix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the prefix placed at the end of the URL route should pass in a dict with the following format : { ' [prefix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for prefix_test , prefix_handler in handlers . items () : if path . startswith ( prefix_test ) : handler = prefix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type","title":"Module hug.output_format"},{"location":"reference/hug/output_format/#variables","text":"HTTP_NOT_FOUND IMAGE_TYPES RE_ACCEPT_QUALITY VIDEO_TYPES image_type json_converters numpy video_mime video_type","title":"Variables"},{"location":"reference/hug/output_format/#functions","text":"","title":"Functions"},{"location":"reference/hug/output_format/#3gp_video","text":"def ( data , ** kwargs ) 3gp formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"3gp_video"},{"location":"reference/hug/output_format/#accept","text":"def ( handlers , default = None , error = 'The requested content type does not match any of those allowed' ) Returns a content in a different format based on the clients defined accepted content type, should pass in a dict with the following format: { '[content-type]' : action , ... } View Source def accept ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients defined accepted content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : accept = request . accept if accept in ( \"\" , \" * \" , \" / \" ) : handler = default or handlers and next ( iter ( handlers . values ())) else : handler = default accepted = [ accept_quality ( accept_type ) for accept_type in accept . split ( \" , \" ) ] accepted . sort ( key = itemgetter ( 0 )) for _quality , accepted_content_type in reversed ( accepted ) : if accepted_content_type in handlers : handler = handlers [ accepted_content_type ] break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type","title":"accept"},{"location":"reference/hug/output_format/#accept_quality","text":"def ( accept , default = 1 ) Separates out the quality score from the accepted content_type View Source def accept_quality ( accept , default = 1 ) : \"\"\" Separates out the quality score from the accepted content_type \"\"\" quality = default if accept and \" ; \" in accept : accept , rest = accept . split ( \" ; \" , 1 ) accept_quality = RE_ACCEPT_QUALITY . search ( rest ) if accept_quality : quality = float ( accept_quality . groupdict () . get ( \" quality \" , quality ) . strip ()) return ( quality , accept . strip ())","title":"accept_quality"},{"location":"reference/hug/output_format/#avi_video","text":"def ( data , ** kwargs ) avi formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"avi_video"},{"location":"reference/hug/output_format/#bmp_image","text":"def ( data , ** kwargs ) bmp formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"bmp_image"},{"location":"reference/hug/output_format/#cur_image","text":"def ( data , ** kwargs ) cur formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"cur_image"},{"location":"reference/hug/output_format/#dcx_image","text":"def ( data , ** kwargs ) dcx formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"dcx_image"},{"location":"reference/hug/output_format/#eps_image","text":"def ( data , ** kwargs ) eps formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"eps_image"},{"location":"reference/hug/output_format/#file","text":"def ( data , response , ** kwargs ) A dynamically retrieved file View Source @ on_valid ( \" file/dynamic \" ) def file ( data , response , ** kwargs ) : \"\"\" A dynamically retrieved file \"\"\" if not data : response . content_type = \" text/plain \" return \"\" if hasattr ( data , \" read \" ) : name , data = getattr ( data , \" name \" , \"\" ) , data elif os . path . isfile ( data ) : name , data = data , open ( data , \" rb \" ) else : response . content_type = \" text/plain \" response . status = HTTP_NOT_FOUND return \" File not found! \" response . content_type = mimetypes . guess_type ( name , None ) [ 0 ] or \" application/octet-stream \" return data","title":"file"},{"location":"reference/hug/output_format/#flc_image","text":"def ( data , ** kwargs ) flc formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"flc_image"},{"location":"reference/hug/output_format/#fli_image","text":"def ( data , ** kwargs ) fli formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"fli_image"},{"location":"reference/hug/output_format/#flv_video","text":"def ( data , ** kwargs ) flv formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"flv_video"},{"location":"reference/hug/output_format/#gbr_image","text":"def ( data , ** kwargs ) gbr formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"gbr_image"},{"location":"reference/hug/output_format/#gd_image","text":"def ( data , ** kwargs ) gd formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"gd_image"},{"location":"reference/hug/output_format/#gif_image","text":"def ( data , ** kwargs ) gif formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"gif_image"},{"location":"reference/hug/output_format/#html","text":"def ( content , ** kwargs ) HTML (Hypertext Markup Language) View Source @ content_type ( \" text/html; charset=utf-8 \" ) def html ( content , ** kwargs ) : \"\"\" HTML (Hypertext Markup Language) \"\"\" if hasattr ( content , \" read \" ) : return content elif hasattr ( content , \" render \" ) : return content . render () . encode ( \" utf8 \" ) return str ( content ) . encode ( \" utf8 \" )","title":"html"},{"location":"reference/hug/output_format/#icns_image","text":"def ( data , ** kwargs ) icns formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"icns_image"},{"location":"reference/hug/output_format/#ico_image","text":"def ( data , ** kwargs ) ico formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"ico_image"},{"location":"reference/hug/output_format/#im_image","text":"def ( data , ** kwargs ) im formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"im_image"},{"location":"reference/hug/output_format/#image","text":"def ( image_format , doc = None ) Dynamically creates an image type handler for the specified image type View Source def image ( image_format , doc = None ) : \"\"\" Dynamically creates an image type handler for the specified image type \"\"\" @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) image_handler . __doc__ = doc or \" {0} formatted image \" . format ( image_format ) return image_handler","title":"image"},{"location":"reference/hug/output_format/#imt_image","text":"def ( data , ** kwargs ) imt formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"imt_image"},{"location":"reference/hug/output_format/#iptc_image","text":"def ( data , ** kwargs ) iptc formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"iptc_image"},{"location":"reference/hug/output_format/#jpeg_image","text":"def ( data , ** kwargs ) jpeg formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"jpeg_image"},{"location":"reference/hug/output_format/#jpg_image","text":"def ( data , ** kwargs ) jpg formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"jpg_image"},{"location":"reference/hug/output_format/#json","text":"def ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) JSON (Javascript Serialized Object Notation) View Source @ content_type ( \" application/json; charset=utf-8 \" ) def json ( content , request = None , response = None , ensure_ascii = False , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) \"\"\" if hasattr ( content , \" read \" ) : return content if isinstance ( content , tuple ) and getattr ( content , \" _fields \" , None ) : content = { field : getattr ( content , field ) for field in content . _fields } return json_converter . dumps ( content , default = _json_converter , ensure_ascii = ensure_ascii , ** kwargs ) . encode ( \" utf8 \" )","title":"json"},{"location":"reference/hug/output_format/#json_camelcase","text":"def ( content , ** kwargs ) JSON (Javascript Serialized Object Notation) with all keys camelCased View Source @ content_type ( \" application/json; charset=utf-8 \" ) def json_camelcase ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notation) with all keys camelCased \"\"\" return json ( _camelcase ( content ) , ** kwargs )","title":"json_camelcase"},{"location":"reference/hug/output_format/#json_convert","text":"def ( * kinds ) Registers the wrapped method as a JSON converter for the provided types. NOTE: custom converters are always globally applied View Source def json_convert ( * kinds ) : \"\"\" Registers the wrapped method as a JSON converter for the provided types. NOTE : custom converters are always globally applied \"\"\" def register_json_converter ( function ) : for kind in kinds : json_converters [ kind ] = function return function return register_json_converter","title":"json_convert"},{"location":"reference/hug/output_format/#m3u8_video","text":"def ( data , ** kwargs ) m3u8 formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"m3u8_video"},{"location":"reference/hug/output_format/#mcidas_image","text":"def ( data , ** kwargs ) mcidas formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"mcidas_image"},{"location":"reference/hug/output_format/#mov_video","text":"def ( data , ** kwargs ) mov formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"mov_video"},{"location":"reference/hug/output_format/#mp4_video","text":"def ( data , ** kwargs ) mp4 formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"mp4_video"},{"location":"reference/hug/output_format/#mpo_image","text":"def ( data , ** kwargs ) mpo formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"mpo_image"},{"location":"reference/hug/output_format/#msp_image","text":"def ( data , ** kwargs ) msp formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"msp_image"},{"location":"reference/hug/output_format/#naa_image","text":"def ( data , ** kwargs ) naa formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"naa_image"},{"location":"reference/hug/output_format/#on_content_type","text":"def ( handlers , default = None , error = 'The requested content type does not match any of those allowed' ) Returns a content in a different format based on the clients provided content type, should pass in a dict with the following format: { '[content-type]' : action , ... } View Source def on_content_type ( handlers , default = None , error = \" The requested content type does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the clients provided content type, should pass in a dict with the following format : { ' [content-type] ' : action , ... } \"\"\" def output_type ( data , request , response ) : handler = handlers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ or function . __name__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type","title":"on_content_type"},{"location":"reference/hug/output_format/#on_valid","text":"def ( valid_content_type , on_invalid =< function json at 0x7f0676c7c9d8 > ) Renders as the specified content type only if no errors are found in the provided data object View Source def on_valid ( valid_content_type , on_invalid = json ) : \"\"\" Renders as the specified content type only if no errors are found in the provided data object \"\"\" invalid_kwargs = introspect . generate_accepted_kwargs ( on_invalid , \" request \" , \" response \" ) invalid_takes_response = introspect . takes_all_arguments ( on_invalid , \" response \" ) def wrapper ( function ) : valid_kwargs = introspect . generate_accepted_kwargs ( function , \" request \" , \" response \" ) valid_takes_response = introspect . takes_all_arguments ( function , \" response \" ) @ content_type ( valid_content_type ) @ wraps ( function ) def output_content ( content , response , ** kwargs ) : if type ( content ) == dict and \" errors \" in content : response . content_type = on_invalid . content_type if invalid_takes_response : kwargs [ \" response \" ] = response return on_invalid ( content , ** invalid_kwargs ( kwargs )) if valid_takes_response : kwargs [ \" response \" ] = response return function ( content , ** valid_kwargs ( kwargs )) return output_content return wrapper","title":"on_valid"},{"location":"reference/hug/output_format/#pcd_image","text":"def ( data , ** kwargs ) pcd formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"pcd_image"},{"location":"reference/hug/output_format/#pcx_image","text":"def ( data , ** kwargs ) pcx formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"pcx_image"},{"location":"reference/hug/output_format/#png_image","text":"def ( data , ** kwargs ) png formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"png_image"},{"location":"reference/hug/output_format/#ppm_image","text":"def ( data , ** kwargs ) ppm formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"ppm_image"},{"location":"reference/hug/output_format/#prefix","text":"def ( handlers , default = None , error = 'The requested prefix does not match any of those allowed' ) Returns a content in a different format based on the prefix placed at the end of the URL route should pass in a dict with the following format: { '[prefix]' : action , ... } View Source def prefix ( handlers , default = None , error = \" The requested prefix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the prefix placed at the end of the URL route should pass in a dict with the following format : { ' [prefix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for prefix_test , prefix_handler in handlers . items () : if path . startswith ( prefix_test ) : handler = prefix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type","title":"prefix"},{"location":"reference/hug/output_format/#pretty_json","text":"def ( content , ** kwargs ) JSON (Javascript Serialized Object Notion) pretty printed and indented View Source @ content_type ( \" application/json; charset=utf-8 \" ) def pretty_json ( content , ** kwargs ) : \"\"\" JSON (Javascript Serialized Object Notion) pretty printed and indented \"\"\" return json ( content , indent = 4 , separators = ( \" , \" , \" : \" ) , ** kwargs )","title":"pretty_json"},{"location":"reference/hug/output_format/#psd_image","text":"def ( data , ** kwargs ) psd formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"psd_image"},{"location":"reference/hug/output_format/#sgi_image","text":"def ( data , ** kwargs ) sgi formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"sgi_image"},{"location":"reference/hug/output_format/#spider_image","text":"def ( data , ** kwargs ) spider formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"spider_image"},{"location":"reference/hug/output_format/#suffix","text":"def ( handlers , default = None , error = 'The requested suffix does not match any of those allowed' ) Returns a content in a different format based on the suffix placed at the end of the URL route should pass in a dict with the following format: { '[suffix]' : action , ... } View Source def suffix ( handlers , default = None , error = \" The requested suffix does not match any of those allowed \" ) : \"\"\" Returns a content in a different format based on the suffix placed at the end of the URL route should pass in a dict with the following format : { ' [suffix] ' : action , ... } \"\"\" def output_type ( data , request , response ) : path = request . path handler = default for suffix_test , suffix_handler in handlers . items () : if path . endswith ( suffix_test ) : handler = suffix_handler break if not handler : raise falcon . HTTPNotAcceptable ( error ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \" Supports any of the following formats: {0} \" . format ( \" , \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \" , \" . join ( handlers . keys ()) return output_type","title":"suffix"},{"location":"reference/hug/output_format/#svg_image","text":"def ( data , ** kwargs ) svg formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"svg_image"},{"location":"reference/hug/output_format/#svg_xml_image","text":"def ( data , ** kwargs ) svg+xml formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"svg_xml_image"},{"location":"reference/hug/output_format/#text","text":"def ( content , ** kwargs ) Free form UTF-8 text View Source @ content_type ( \" text/plain; charset=utf-8 \" ) def text ( content , ** kwargs ) : \"\"\" Free form UTF-8 text \"\"\" if hasattr ( content , \" read \" ) : return content return str ( content ) . encode ( \" utf8 \" )","title":"text"},{"location":"reference/hug/output_format/#tga_image","text":"def ( data , ** kwargs ) tga formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"tga_image"},{"location":"reference/hug/output_format/#tiff_image","text":"def ( data , ** kwargs ) tiff formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"tiff_image"},{"location":"reference/hug/output_format/#ts_video","text":"def ( data , ** kwargs ) ts formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"ts_video"},{"location":"reference/hug/output_format/#video","text":"def ( video_type , video_mime , doc = None ) Dynamically creates a video type handler for the specified video type View Source def video ( video_type , video_mime , doc = None ) : \"\"\" Dynamically creates a video type handler for the specified video type \"\"\" @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" ) video_handler . __doc__ = doc or \" {0} formatted video \" . format ( video_type ) return video_handler","title":"video"},{"location":"reference/hug/output_format/#wal_image","text":"def ( data , ** kwargs ) wal formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"wal_image"},{"location":"reference/hug/output_format/#webp_image","text":"def ( data , ** kwargs ) webp formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"webp_image"},{"location":"reference/hug/output_format/#wmv_video","text":"def ( data , ** kwargs ) wmv formatted video View Source @ on_valid ( video_mime ) def video_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () data . save ( output , format = video_type . upper ()) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"wmv_video"},{"location":"reference/hug/output_format/#xbm_image","text":"def ( data , ** kwargs ) xbm formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"xbm_image"},{"location":"reference/hug/output_format/#xpm_image","text":"def ( data , ** kwargs ) xpm formatted image View Source @ on_valid ( \" image/{0} \" . format ( image_format )) def image_handler ( data , ** kwargs ) : if hasattr ( data , \" read \" ) : return data elif hasattr ( data , \" save \" ) : output = stream () if introspect . takes_all_arguments ( data . save , \" format \" ) or introspect . takes_kwargs ( data . save ) : data . save ( output , format = image_format . upper ()) else : data . save ( output ) output . seek ( 0 ) return output elif hasattr ( data , \" render \" ) : return data . render () elif os . path . isfile ( data ) : return open ( data , \" rb \" )","title":"xpm_image"},{"location":"reference/hug/output_format/#classes","text":"","title":"Classes"},{"location":"reference/hug/output_format/#stream","text":"class ( / , * args , ** kwargs ) Buffered I/O implementation using an in-memory bytes buffer.","title":"stream"},{"location":"reference/hug/output_format/#ancestors-in-mro","text":"_io._BufferedIOBase _io._IOBase","title":"Ancestors (in MRO)"},{"location":"reference/hug/redirect/","text":"Module hug.redirect hug/redirect.py Implements convenience redirect methods that raise a redirection exception when called Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/redirect.py Implements convenience redirect methods that raise a redirection exception when called Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import falcon def to ( location , code = falcon . HTTP_302 ) : \"\"\" Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND) \"\"\" raise falcon . http_status . HTTPStatus ( code , { \" location \" : location } ) def permanent ( location ) : \"\"\" Redirects to the specified location using HTTP 301 status code \"\"\" to ( location , falcon . HTTP_301 ) def found ( location ) : \"\"\" Redirects to the specified location using HTTP 302 status code \"\"\" to ( location , falcon . HTTP_302 ) def see_other ( location ) : \"\"\" Redirects to the specified location using HTTP 303 status code \"\"\" to ( location , falcon . HTTP_303 ) def temporary ( location ) : \"\"\" Redirects to the specified location using HTTP 307 status code \"\"\" to ( location , falcon . HTTP_307 ) def not_found ( * args , ** kwargs ) : \"\"\" Redirects request handling to the not found render \"\"\" raise falcon . HTTPNotFound () Functions found def ( location ) Redirects to the specified location using HTTP 302 status code View Source def found ( location ): \"\"\"Redirects to the specified location using HTTP 302 status code\"\"\" to ( location , falcon . HTTP_302 ) not_found def ( * args , ** kwargs ) Redirects request handling to the not found render View Source def not_found ( * args , ** kwargs ): \"\"\"Redirects request handling to the not found render\"\"\" raise falcon . HTTPNotFound () permanent def ( location ) Redirects to the specified location using HTTP 301 status code View Source def permanent ( location ): \"\"\"Redirects to the specified location using HTTP 301 status code\"\"\" to ( location , falcon . HTTP_301 ) see_other def ( location ) Redirects to the specified location using HTTP 303 status code View Source def see_other ( location ): \"\"\"Redirects to the specified location using HTTP 303 status code\"\"\" to ( location , falcon . HTTP_303 ) temporary def ( location ) Redirects to the specified location using HTTP 307 status code View Source def temporary ( location ): \"\"\"Redirects to the specified location using HTTP 307 status code\"\"\" to ( location , falcon . HTTP_307 ) to def ( location , code = '302 Found' ) Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND) View Source def to ( location , code = falcon . HTTP_302 ): \"\"\"Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND)\"\"\" raise falcon . http_status . HTTPStatus ( code , { \"location\" : location } )","title":"Redirect"},{"location":"reference/hug/redirect/#module-hugredirect","text":"hug/redirect.py Implements convenience redirect methods that raise a redirection exception when called Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/redirect.py Implements convenience redirect methods that raise a redirection exception when called Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import falcon def to ( location , code = falcon . HTTP_302 ) : \"\"\" Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND) \"\"\" raise falcon . http_status . HTTPStatus ( code , { \" location \" : location } ) def permanent ( location ) : \"\"\" Redirects to the specified location using HTTP 301 status code \"\"\" to ( location , falcon . HTTP_301 ) def found ( location ) : \"\"\" Redirects to the specified location using HTTP 302 status code \"\"\" to ( location , falcon . HTTP_302 ) def see_other ( location ) : \"\"\" Redirects to the specified location using HTTP 303 status code \"\"\" to ( location , falcon . HTTP_303 ) def temporary ( location ) : \"\"\" Redirects to the specified location using HTTP 307 status code \"\"\" to ( location , falcon . HTTP_307 ) def not_found ( * args , ** kwargs ) : \"\"\" Redirects request handling to the not found render \"\"\" raise falcon . HTTPNotFound ()","title":"Module hug.redirect"},{"location":"reference/hug/redirect/#functions","text":"","title":"Functions"},{"location":"reference/hug/redirect/#found","text":"def ( location ) Redirects to the specified location using HTTP 302 status code View Source def found ( location ): \"\"\"Redirects to the specified location using HTTP 302 status code\"\"\" to ( location , falcon . HTTP_302 )","title":"found"},{"location":"reference/hug/redirect/#not_found","text":"def ( * args , ** kwargs ) Redirects request handling to the not found render View Source def not_found ( * args , ** kwargs ): \"\"\"Redirects request handling to the not found render\"\"\" raise falcon . HTTPNotFound ()","title":"not_found"},{"location":"reference/hug/redirect/#permanent","text":"def ( location ) Redirects to the specified location using HTTP 301 status code View Source def permanent ( location ): \"\"\"Redirects to the specified location using HTTP 301 status code\"\"\" to ( location , falcon . HTTP_301 )","title":"permanent"},{"location":"reference/hug/redirect/#see_other","text":"def ( location ) Redirects to the specified location using HTTP 303 status code View Source def see_other ( location ): \"\"\"Redirects to the specified location using HTTP 303 status code\"\"\" to ( location , falcon . HTTP_303 )","title":"see_other"},{"location":"reference/hug/redirect/#temporary","text":"def ( location ) Redirects to the specified location using HTTP 307 status code View Source def temporary ( location ): \"\"\"Redirects to the specified location using HTTP 307 status code\"\"\" to ( location , falcon . HTTP_307 )","title":"temporary"},{"location":"reference/hug/redirect/#to","text":"def ( location , code = '302 Found' ) Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND) View Source def to ( location , code = falcon . HTTP_302 ): \"\"\"Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND)\"\"\" raise falcon . http_status . HTTPStatus ( code , { \"location\" : location } )","title":"to"},{"location":"reference/hug/route/","text":"Module hug.route hug/route.py Defines user usable routers Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/route.py Defines user usable routers Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from functools import partial from types import FunctionType , MethodType from falcon import HTTP_METHODS import hug . api from hug . routing import CLIRouter as cli # noqa : N813 from hug . routing import ExceptionRouter as exception # noqa : N813 from hug . routing import LocalRouter as local # noqa : N813 from hug . routing import NotFoundRouter as not_found # noqa : N813 from hug . routing import SinkRouter as sink # noqa : N813 from hug . routing import StaticRouter as static # noqa : N813 from hug . routing import URLRouter as http # noqa : N813 class Object ( http ) : \"\"\" Defines a router for classes and objects \"\"\" def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , ** kwargs ) : super () . __init__ ( urls = urls , accept = accept , output = output , ** kwargs ) def __call__ ( self , method_or_class = None , ** kwargs ) : if not method_or_class and kwargs : return self . where ( ** kwargs ) if isinstance ( method_or_class , ( MethodType , FunctionType )) : routes = getattr ( method_or_class , \" _hug_http_routes \" , [] ) routes . append ( self . route ) method_or_class . _hug_http_routes = routes return method_or_class instance = method_or_class if isinstance ( method_or_class , type ) : instance = method_or_class () for argument in dir ( instance ) : argument = getattr ( instance , argument , None ) http_routes = getattr ( argument , \" _hug_http_routes \" , ()) for route in http_routes : http ( ** self . where ( ** route ) . route )( argument ) cli_routes = getattr ( argument , \" _hug_cli_routes \" , ()) for route in cli_routes : cli ( ** self . where ( ** route ) . route )( argument ) return method_or_class def http_methods ( self , urls = None , ** route_data ) : \"\"\" Creates routes from a class, where the class method names should line up to HTTP METHOD types \"\"\" def decorator ( class_definition ) : instance = class_definition if isinstance ( class_definition , type ) : instance = class_definition () router = self . urls ( urls if urls else \" /{0} \" . format ( instance . __class__ . __name__ . lower ()) , ** route_data ) for method in HTTP_METHODS : handler = getattr ( instance , method . lower () , None ) if handler : http_routes = getattr ( handler , \" _hug_http_routes \" , ()) if http_routes : for route in http_routes : http ( ** router . accept ( method ) . where ( ** route ) . route )( handler ) else : http ( ** router . accept ( method ) . route )( handler ) cli_routes = getattr ( handler , \" _hug_cli_routes \" , ()) if cli_routes : for route in cli_routes : cli ( ** self . where ( ** route ) . route )( handler ) return class_definition return decorator def cli ( self , method ) : \"\"\" Registers a method on an Object as a CLI route \"\"\" routes = getattr ( method , \" _hug_cli_routes \" , [] ) routes . append ( self . route ) method . _hug_cli_routes = routes return method class API ( object ) : \"\"\" Provides a convient way to route functions to a single API independent of where they live \"\"\" __slots__ = ( \" api \" , ) def __init__ ( self , api ) : if type ( api ) == str : api = hug . api . API ( api ) self . api = api def http ( self , * args , ** kwargs ) : \"\"\" Starts the process of building a new HTTP route linked to this API instance \"\"\" kwargs [ \" api \" ] = self . api return http ( * args , ** kwargs ) def urls ( self , * args , ** kwargs ) : \"\"\" DEPRECATED: for backwords compatibility with < hug 2.2.0. `API.http` should be used instead. Starts the process of building a new URL HTTP route linked to this API instance \"\"\" return self . http ( * args , ** kwargs ) def not_found ( self , * args , ** kwargs ) : \"\"\" Defines the handler that should handle not found requests against this API \"\"\" kwargs [ \" api \" ] = self . api return not_found ( * args , ** kwargs ) def static ( self , * args , ** kwargs ) : \"\"\" Define the routes to static files the API should expose \"\"\" kwargs [ \" api \" ] = self . api return static ( * args , ** kwargs ) def sink ( self , * args , ** kwargs ) : \"\"\" Define URL prefixes/handler matches where everything under the URL prefix should be handled \"\"\" kwargs [ \" api \" ] = self . api return sink ( * args , ** kwargs ) def exception ( self , * args , ** kwargs ) : \"\"\" Defines how this API should handle the provided exceptions \"\"\" kwargs [ \" api \" ] = self . api return exception ( * args , ** kwargs ) def cli ( self , * args , ** kwargs ) : \"\"\" Defines a CLI function that should be routed by this API \"\"\" kwargs [ \" api \" ] = self . api return cli ( * args , ** kwargs ) def object ( self , * args , ** kwargs ) : \"\"\" Registers a class based router to this API \"\"\" kwargs [ \" api \" ] = self . api return Object ( * args , ** kwargs ) def get ( self , * args , ** kwargs ) : \"\"\" Builds a new GET HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , ) return http ( * args , ** kwargs ) def post ( self , * args , ** kwargs ) : \"\"\" Builds a new POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" POST \" , ) return http ( * args , ** kwargs ) def put ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , ) return http ( * args , ** kwargs ) def delete ( self , * args , ** kwargs ) : \"\"\" Builds a new DELETE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" DELETE \" , ) return http ( * args , ** kwargs ) def connect ( self , * args , ** kwargs ) : \"\"\" Builds a new CONNECT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" CONNECT \" , ) return http ( * args , ** kwargs ) def head ( self , * args , ** kwargs ) : \"\"\" Builds a new HEAD HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" HEAD \" , ) return http ( * args , ** kwargs ) def options ( self , * args , ** kwargs ) : \"\"\" Builds a new OPTIONS HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" OPTIONS \" , ) return http ( * args , ** kwargs ) def patch ( self , * args , ** kwargs ) : \"\"\" Builds a new PATCH HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PATCH \" , ) return http ( * args , ** kwargs ) def trace ( self , * args , ** kwargs ) : \"\"\" Builds a new TRACE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" TRACE \" , ) return http ( * args , ** kwargs ) def get_post ( self , * args , ** kwargs ) : \"\"\" Builds a new GET or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , \" POST \" ) return http ( * args , ** kwargs ) def put_post ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , \" POST \" ) return http ( * args , ** kwargs ) for method in HTTP_METHODS : method_handler = partial ( http , accept = ( method , )) method_handler . __doc__ = \" Exposes a Python method externally as an HTTP {0} method \" . format ( method . upper () ) globals () [ method . lower () ] = method_handler get_post = partial ( http , accept = ( \" GET \" , \" POST \" )) get_post . __doc__ = \" Exposes a Python method externally under both the HTTP POST and GET methods \" put_post = partial ( http , accept = ( \" PUT \" , \" POST \" )) put_post . __doc__ = \" Exposes a Python method externally under both the HTTP POST and PUT methods \" object = Object () # DEPRECATED : for backwords compatibility with hug 1 . x . x call = http Variables HTTP_METHODS connect delete get get_post head method method_handler object options patch post put put_post trace Classes API class ( api ) Provides a convient way to route functions to a single API independent of where they live View Source class API ( object ) : \"\"\" Provides a convient way to route functions to a single API independent of where they live \"\"\" __slots__ = ( \" api \" , ) def __init__ ( self , api ) : if type ( api ) == str : api = hug . api . API ( api ) self . api = api def http ( self , * args , ** kwargs ) : \"\"\" Starts the process of building a new HTTP route linked to this API instance \"\"\" kwargs [ \" api \" ] = self . api return http ( * args , ** kwargs ) def urls ( self , * args , ** kwargs ) : \"\"\" DEPRECATED: for backwords compatibility with < hug 2.2.0. `API.http` should be used instead. Starts the process of building a new URL HTTP route linked to this API instance \"\"\" return self . http ( * args , ** kwargs ) def not_found ( self , * args , ** kwargs ) : \"\"\" Defines the handler that should handle not found requests against this API \"\"\" kwargs [ \" api \" ] = self . api return not_found ( * args , ** kwargs ) def static ( self , * args , ** kwargs ) : \"\"\" Define the routes to static files the API should expose \"\"\" kwargs [ \" api \" ] = self . api return static ( * args , ** kwargs ) def sink ( self , * args , ** kwargs ) : \"\"\" Define URL prefixes/handler matches where everything under the URL prefix should be handled \"\"\" kwargs [ \" api \" ] = self . api return sink ( * args , ** kwargs ) def exception ( self , * args , ** kwargs ) : \"\"\" Defines how this API should handle the provided exceptions \"\"\" kwargs [ \" api \" ] = self . api return exception ( * args , ** kwargs ) def cli ( self , * args , ** kwargs ) : \"\"\" Defines a CLI function that should be routed by this API \"\"\" kwargs [ \" api \" ] = self . api return cli ( * args , ** kwargs ) def object ( self , * args , ** kwargs ) : \"\"\" Registers a class based router to this API \"\"\" kwargs [ \" api \" ] = self . api return Object ( * args , ** kwargs ) def get ( self , * args , ** kwargs ) : \"\"\" Builds a new GET HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , ) return http ( * args , ** kwargs ) def post ( self , * args , ** kwargs ) : \"\"\" Builds a new POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" POST \" , ) return http ( * args , ** kwargs ) def put ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , ) return http ( * args , ** kwargs ) def delete ( self , * args , ** kwargs ) : \"\"\" Builds a new DELETE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" DELETE \" , ) return http ( * args , ** kwargs ) def connect ( self , * args , ** kwargs ) : \"\"\" Builds a new CONNECT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" CONNECT \" , ) return http ( * args , ** kwargs ) def head ( self , * args , ** kwargs ) : \"\"\" Builds a new HEAD HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" HEAD \" , ) return http ( * args , ** kwargs ) def options ( self , * args , ** kwargs ) : \"\"\" Builds a new OPTIONS HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" OPTIONS \" , ) return http ( * args , ** kwargs ) def patch ( self , * args , ** kwargs ) : \"\"\" Builds a new PATCH HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PATCH \" , ) return http ( * args , ** kwargs ) def trace ( self , * args , ** kwargs ) : \"\"\" Builds a new TRACE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" TRACE \" , ) return http ( * args , ** kwargs ) def get_post ( self , * args , ** kwargs ) : \"\"\" Builds a new GET or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , \" POST \" ) return http ( * args , ** kwargs ) def put_post ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , \" POST \" ) return http ( * args , ** kwargs ) Object class ( urls = None , accept = ( 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'PATCH' , 'POST' , 'PUT' , 'TRACE' ), output = None , ** kwargs ) Defines a router for classes and objects View Source class Object ( http ) : \"\"\" Defines a router for classes and objects \"\"\" def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , ** kwargs ) : super () . __init__ ( urls = urls , accept = accept , output = output , ** kwargs ) def __call__ ( self , method_or_class = None , ** kwargs ) : if not method_or_class and kwargs : return self . where ( ** kwargs ) if isinstance ( method_or_class , ( MethodType , FunctionType )) : routes = getattr ( method_or_class , \" _hug_http_routes \" , [] ) routes . append ( self . route ) method_or_class . _hug_http_routes = routes return method_or_class instance = method_or_class if isinstance ( method_or_class , type ) : instance = method_or_class () for argument in dir ( instance ) : argument = getattr ( instance , argument , None ) http_routes = getattr ( argument , \" _hug_http_routes \" , ()) for route in http_routes : http ( ** self . where ( ** route ) . route )( argument ) cli_routes = getattr ( argument , \" _hug_cli_routes \" , ()) for route in cli_routes : cli ( ** self . where ( ** route ) . route )( argument ) return method_or_class def http_methods ( self , urls = None , ** route_data ) : \"\"\" Creates routes from a class, where the class method names should line up to HTTP METHOD types \"\"\" def decorator ( class_definition ) : instance = class_definition if isinstance ( class_definition , type ) : instance = class_definition () router = self . urls ( urls if urls else \" /{0} \" . format ( instance . __class__ . __name__ . lower ()) , ** route_data ) for method in HTTP_METHODS : handler = getattr ( instance , method . lower () , None ) if handler : http_routes = getattr ( handler , \" _hug_http_routes \" , ()) if http_routes : for route in http_routes : http ( ** router . accept ( method ) . where ( ** route ) . route )( handler ) else : http ( ** router . accept ( method ) . route )( handler ) cli_routes = getattr ( handler , \" _hug_cli_routes \" , ()) if cli_routes : for route in cli_routes : cli ( ** self . where ( ** route ) . route )( handler ) return class_definition return decorator def cli ( self , method ) : \"\"\" Registers a method on an Object as a CLI route \"\"\" routes = getattr ( method , \" _hug_cli_routes \" , [] ) routes . append ( self . route ) method . _hug_cli_routes = routes return method Ancestors (in MRO) hug.route.URLRouter hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router call class ( urls = None , accept = ( 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'PATCH' , 'POST' , 'PUT' , 'TRACE' ), output = None , examples = (), versions =< built - in function any > , suffixes = (), prefixes = (), response_headers = None , parse_body = True , ** kwargs ) Provides a chainable router that can be used to route a URL to a Python function View Source class URLRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route a URL to a Python function \"\"\" __slots__ = () def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , examples = () , versions = any , suffixes = () , prefixes = () , response_headers = None , parse_body = True , ** kwargs ) : super () . __init__ ( output = output , versions = versions , parse_body = parse_body , response_headers = response_headers , ** kwargs ) if urls is not None : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls if accept : self . route [ \" accept \" ] = ( accept , ) if isinstance ( accept , str ) else accept if examples : self . route [ \" examples \" ] = ( examples , ) if isinstance ( examples , str ) else examples if suffixes : self . route [ \" suffixes \" ] = ( suffixes , ) if isinstance ( suffixes , str ) else suffixes if prefixes : self . route [ \" prefixes \" ] = ( prefixes , ) if isinstance ( prefixes , str ) else prefixes def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) api . http . routes . setdefault ( api . http . base_url , OrderedDict ()) ( interface , callable_method ) = self . _create_interface ( api , api_function ) use_examples = self . route . get ( \" examples \" , ()) if not interface . required and not use_examples : use_examples = ( True , ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : expose = [ base_url ] for suffix in self . route . get ( \" suffixes \" , ()) : if suffix . startswith ( \" / \" ) : expose . append ( os . path . join ( base_url , suffix . lstrip ( \" / \" ))) else : expose . append ( base_url + suffix ) for prefix in self . route . get ( \" prefixes \" , ()) : expose . append ( prefix + base_url ) for url in expose : handlers = api . http . routes [ api . http . base_url ]. setdefault ( url , {} ) for method in self . route . get ( \" accept \" , ()) : version_mapping = handlers . setdefault ( method . upper () , {} ) for version in self . route . get ( \" versions \" , ( None , )) : version_mapping [ version ] = interface api . http . versioned . setdefault ( version , {} ) [ callable_method . __name__ ] = callable_method interface . examples = use_examples return callable_method def urls ( self , * urls , ** overrides ) : \"\"\" Sets the URLs that will map to this API call \"\"\" return self . where ( urls = urls , ** overrides ) def accept ( self , * accept , ** overrides ) : \"\"\" Sets a list of HTTP methods this router should accept \"\"\" return self . where ( accept = accept , ** overrides ) def get ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to a GET \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" GET \" , ** overrides ) def delete ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to DELETE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" DELETE \" , ** overrides ) def post ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to POST \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" POST \" , ** overrides ) def put ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PUT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PUT \" , ** overrides ) def trace ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to TRACE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" TRACE \" , ** overrides ) def patch ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PATCH \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PATCH \" , ** overrides ) def options ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to OPTIONS \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" OPTIONS \" , ** overrides ) def head ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to HEAD \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" HEAD \" , ** overrides ) def connect ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to CONNECT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" CONNECT \" , ** overrides ) def call ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def http ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def get_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and GET methods \"\"\" return self . where ( accept = ( \" GET \" , \" POST \" ) , ** overrides ) def put_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and PUT methods \"\"\" return self . where ( accept = ( \" PUT \" , \" POST \" ) , ** overrides ) def examples ( self , * examples , ** overrides ) : \"\"\" Sets the examples that the route should use \"\"\" return self . where ( examples = examples , ** overrides ) def suffixes ( self , * suffixes , ** overrides ) : \"\"\" Sets the suffixes supported by the route \"\"\" return self . where ( suffixes = suffixes , ** overrides ) def prefixes ( self , * prefixes , ** overrides ) : \"\"\" Sets the prefixes supported by the route \"\"\" return self . where ( prefixes = prefixes , ** overrides ) def where ( self , ** overrides ) : if \" urls \" in overrides : existing_urls = self . route . get ( \" urls \" , ()) use_urls = [] for url in ( ( overrides [ \" urls \" ], ) if isinstance ( overrides [ \" urls \" ], str ) else overrides [ \" urls \" ] ) : if url . startswith ( \" / \" ) or not existing_urls : use_urls . append ( url ) else : for existing in existing_urls : use_urls . append ( urljoin ( existing . rstrip ( \" / \" ) + \" / \" , url )) overrides [ \" urls \" ] = tuple ( use_urls ) return super () . where ( ** overrides ) Ancestors (in MRO) hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router Descendants hug.route.Object","title":"Route"},{"location":"reference/hug/route/#module-hugroute","text":"hug/route.py Defines user usable routers Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/route.py Defines user usable routers Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from functools import partial from types import FunctionType , MethodType from falcon import HTTP_METHODS import hug . api from hug . routing import CLIRouter as cli # noqa : N813 from hug . routing import ExceptionRouter as exception # noqa : N813 from hug . routing import LocalRouter as local # noqa : N813 from hug . routing import NotFoundRouter as not_found # noqa : N813 from hug . routing import SinkRouter as sink # noqa : N813 from hug . routing import StaticRouter as static # noqa : N813 from hug . routing import URLRouter as http # noqa : N813 class Object ( http ) : \"\"\" Defines a router for classes and objects \"\"\" def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , ** kwargs ) : super () . __init__ ( urls = urls , accept = accept , output = output , ** kwargs ) def __call__ ( self , method_or_class = None , ** kwargs ) : if not method_or_class and kwargs : return self . where ( ** kwargs ) if isinstance ( method_or_class , ( MethodType , FunctionType )) : routes = getattr ( method_or_class , \" _hug_http_routes \" , [] ) routes . append ( self . route ) method_or_class . _hug_http_routes = routes return method_or_class instance = method_or_class if isinstance ( method_or_class , type ) : instance = method_or_class () for argument in dir ( instance ) : argument = getattr ( instance , argument , None ) http_routes = getattr ( argument , \" _hug_http_routes \" , ()) for route in http_routes : http ( ** self . where ( ** route ) . route )( argument ) cli_routes = getattr ( argument , \" _hug_cli_routes \" , ()) for route in cli_routes : cli ( ** self . where ( ** route ) . route )( argument ) return method_or_class def http_methods ( self , urls = None , ** route_data ) : \"\"\" Creates routes from a class, where the class method names should line up to HTTP METHOD types \"\"\" def decorator ( class_definition ) : instance = class_definition if isinstance ( class_definition , type ) : instance = class_definition () router = self . urls ( urls if urls else \" /{0} \" . format ( instance . __class__ . __name__ . lower ()) , ** route_data ) for method in HTTP_METHODS : handler = getattr ( instance , method . lower () , None ) if handler : http_routes = getattr ( handler , \" _hug_http_routes \" , ()) if http_routes : for route in http_routes : http ( ** router . accept ( method ) . where ( ** route ) . route )( handler ) else : http ( ** router . accept ( method ) . route )( handler ) cli_routes = getattr ( handler , \" _hug_cli_routes \" , ()) if cli_routes : for route in cli_routes : cli ( ** self . where ( ** route ) . route )( handler ) return class_definition return decorator def cli ( self , method ) : \"\"\" Registers a method on an Object as a CLI route \"\"\" routes = getattr ( method , \" _hug_cli_routes \" , [] ) routes . append ( self . route ) method . _hug_cli_routes = routes return method class API ( object ) : \"\"\" Provides a convient way to route functions to a single API independent of where they live \"\"\" __slots__ = ( \" api \" , ) def __init__ ( self , api ) : if type ( api ) == str : api = hug . api . API ( api ) self . api = api def http ( self , * args , ** kwargs ) : \"\"\" Starts the process of building a new HTTP route linked to this API instance \"\"\" kwargs [ \" api \" ] = self . api return http ( * args , ** kwargs ) def urls ( self , * args , ** kwargs ) : \"\"\" DEPRECATED: for backwords compatibility with < hug 2.2.0. `API.http` should be used instead. Starts the process of building a new URL HTTP route linked to this API instance \"\"\" return self . http ( * args , ** kwargs ) def not_found ( self , * args , ** kwargs ) : \"\"\" Defines the handler that should handle not found requests against this API \"\"\" kwargs [ \" api \" ] = self . api return not_found ( * args , ** kwargs ) def static ( self , * args , ** kwargs ) : \"\"\" Define the routes to static files the API should expose \"\"\" kwargs [ \" api \" ] = self . api return static ( * args , ** kwargs ) def sink ( self , * args , ** kwargs ) : \"\"\" Define URL prefixes/handler matches where everything under the URL prefix should be handled \"\"\" kwargs [ \" api \" ] = self . api return sink ( * args , ** kwargs ) def exception ( self , * args , ** kwargs ) : \"\"\" Defines how this API should handle the provided exceptions \"\"\" kwargs [ \" api \" ] = self . api return exception ( * args , ** kwargs ) def cli ( self , * args , ** kwargs ) : \"\"\" Defines a CLI function that should be routed by this API \"\"\" kwargs [ \" api \" ] = self . api return cli ( * args , ** kwargs ) def object ( self , * args , ** kwargs ) : \"\"\" Registers a class based router to this API \"\"\" kwargs [ \" api \" ] = self . api return Object ( * args , ** kwargs ) def get ( self , * args , ** kwargs ) : \"\"\" Builds a new GET HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , ) return http ( * args , ** kwargs ) def post ( self , * args , ** kwargs ) : \"\"\" Builds a new POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" POST \" , ) return http ( * args , ** kwargs ) def put ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , ) return http ( * args , ** kwargs ) def delete ( self , * args , ** kwargs ) : \"\"\" Builds a new DELETE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" DELETE \" , ) return http ( * args , ** kwargs ) def connect ( self , * args , ** kwargs ) : \"\"\" Builds a new CONNECT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" CONNECT \" , ) return http ( * args , ** kwargs ) def head ( self , * args , ** kwargs ) : \"\"\" Builds a new HEAD HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" HEAD \" , ) return http ( * args , ** kwargs ) def options ( self , * args , ** kwargs ) : \"\"\" Builds a new OPTIONS HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" OPTIONS \" , ) return http ( * args , ** kwargs ) def patch ( self , * args , ** kwargs ) : \"\"\" Builds a new PATCH HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PATCH \" , ) return http ( * args , ** kwargs ) def trace ( self , * args , ** kwargs ) : \"\"\" Builds a new TRACE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" TRACE \" , ) return http ( * args , ** kwargs ) def get_post ( self , * args , ** kwargs ) : \"\"\" Builds a new GET or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , \" POST \" ) return http ( * args , ** kwargs ) def put_post ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , \" POST \" ) return http ( * args , ** kwargs ) for method in HTTP_METHODS : method_handler = partial ( http , accept = ( method , )) method_handler . __doc__ = \" Exposes a Python method externally as an HTTP {0} method \" . format ( method . upper () ) globals () [ method . lower () ] = method_handler get_post = partial ( http , accept = ( \" GET \" , \" POST \" )) get_post . __doc__ = \" Exposes a Python method externally under both the HTTP POST and GET methods \" put_post = partial ( http , accept = ( \" PUT \" , \" POST \" )) put_post . __doc__ = \" Exposes a Python method externally under both the HTTP POST and PUT methods \" object = Object () # DEPRECATED : for backwords compatibility with hug 1 . x . x call = http","title":"Module hug.route"},{"location":"reference/hug/route/#variables","text":"HTTP_METHODS connect delete get get_post head method method_handler object options patch post put put_post trace","title":"Variables"},{"location":"reference/hug/route/#classes","text":"","title":"Classes"},{"location":"reference/hug/route/#api","text":"class ( api ) Provides a convient way to route functions to a single API independent of where they live View Source class API ( object ) : \"\"\" Provides a convient way to route functions to a single API independent of where they live \"\"\" __slots__ = ( \" api \" , ) def __init__ ( self , api ) : if type ( api ) == str : api = hug . api . API ( api ) self . api = api def http ( self , * args , ** kwargs ) : \"\"\" Starts the process of building a new HTTP route linked to this API instance \"\"\" kwargs [ \" api \" ] = self . api return http ( * args , ** kwargs ) def urls ( self , * args , ** kwargs ) : \"\"\" DEPRECATED: for backwords compatibility with < hug 2.2.0. `API.http` should be used instead. Starts the process of building a new URL HTTP route linked to this API instance \"\"\" return self . http ( * args , ** kwargs ) def not_found ( self , * args , ** kwargs ) : \"\"\" Defines the handler that should handle not found requests against this API \"\"\" kwargs [ \" api \" ] = self . api return not_found ( * args , ** kwargs ) def static ( self , * args , ** kwargs ) : \"\"\" Define the routes to static files the API should expose \"\"\" kwargs [ \" api \" ] = self . api return static ( * args , ** kwargs ) def sink ( self , * args , ** kwargs ) : \"\"\" Define URL prefixes/handler matches where everything under the URL prefix should be handled \"\"\" kwargs [ \" api \" ] = self . api return sink ( * args , ** kwargs ) def exception ( self , * args , ** kwargs ) : \"\"\" Defines how this API should handle the provided exceptions \"\"\" kwargs [ \" api \" ] = self . api return exception ( * args , ** kwargs ) def cli ( self , * args , ** kwargs ) : \"\"\" Defines a CLI function that should be routed by this API \"\"\" kwargs [ \" api \" ] = self . api return cli ( * args , ** kwargs ) def object ( self , * args , ** kwargs ) : \"\"\" Registers a class based router to this API \"\"\" kwargs [ \" api \" ] = self . api return Object ( * args , ** kwargs ) def get ( self , * args , ** kwargs ) : \"\"\" Builds a new GET HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , ) return http ( * args , ** kwargs ) def post ( self , * args , ** kwargs ) : \"\"\" Builds a new POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" POST \" , ) return http ( * args , ** kwargs ) def put ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , ) return http ( * args , ** kwargs ) def delete ( self , * args , ** kwargs ) : \"\"\" Builds a new DELETE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" DELETE \" , ) return http ( * args , ** kwargs ) def connect ( self , * args , ** kwargs ) : \"\"\" Builds a new CONNECT HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" CONNECT \" , ) return http ( * args , ** kwargs ) def head ( self , * args , ** kwargs ) : \"\"\" Builds a new HEAD HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" HEAD \" , ) return http ( * args , ** kwargs ) def options ( self , * args , ** kwargs ) : \"\"\" Builds a new OPTIONS HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" OPTIONS \" , ) return http ( * args , ** kwargs ) def patch ( self , * args , ** kwargs ) : \"\"\" Builds a new PATCH HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PATCH \" , ) return http ( * args , ** kwargs ) def trace ( self , * args , ** kwargs ) : \"\"\" Builds a new TRACE HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" TRACE \" , ) return http ( * args , ** kwargs ) def get_post ( self , * args , ** kwargs ) : \"\"\" Builds a new GET or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" GET \" , \" POST \" ) return http ( * args , ** kwargs ) def put_post ( self , * args , ** kwargs ) : \"\"\" Builds a new PUT or POST HTTP route that is registered to this API \"\"\" kwargs [ \" api \" ] = self . api kwargs [ \" accept \" ] = ( \" PUT \" , \" POST \" ) return http ( * args , ** kwargs )","title":"API"},{"location":"reference/hug/route/#object","text":"class ( urls = None , accept = ( 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'PATCH' , 'POST' , 'PUT' , 'TRACE' ), output = None , ** kwargs ) Defines a router for classes and objects View Source class Object ( http ) : \"\"\" Defines a router for classes and objects \"\"\" def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , ** kwargs ) : super () . __init__ ( urls = urls , accept = accept , output = output , ** kwargs ) def __call__ ( self , method_or_class = None , ** kwargs ) : if not method_or_class and kwargs : return self . where ( ** kwargs ) if isinstance ( method_or_class , ( MethodType , FunctionType )) : routes = getattr ( method_or_class , \" _hug_http_routes \" , [] ) routes . append ( self . route ) method_or_class . _hug_http_routes = routes return method_or_class instance = method_or_class if isinstance ( method_or_class , type ) : instance = method_or_class () for argument in dir ( instance ) : argument = getattr ( instance , argument , None ) http_routes = getattr ( argument , \" _hug_http_routes \" , ()) for route in http_routes : http ( ** self . where ( ** route ) . route )( argument ) cli_routes = getattr ( argument , \" _hug_cli_routes \" , ()) for route in cli_routes : cli ( ** self . where ( ** route ) . route )( argument ) return method_or_class def http_methods ( self , urls = None , ** route_data ) : \"\"\" Creates routes from a class, where the class method names should line up to HTTP METHOD types \"\"\" def decorator ( class_definition ) : instance = class_definition if isinstance ( class_definition , type ) : instance = class_definition () router = self . urls ( urls if urls else \" /{0} \" . format ( instance . __class__ . __name__ . lower ()) , ** route_data ) for method in HTTP_METHODS : handler = getattr ( instance , method . lower () , None ) if handler : http_routes = getattr ( handler , \" _hug_http_routes \" , ()) if http_routes : for route in http_routes : http ( ** router . accept ( method ) . where ( ** route ) . route )( handler ) else : http ( ** router . accept ( method ) . route )( handler ) cli_routes = getattr ( handler , \" _hug_cli_routes \" , ()) if cli_routes : for route in cli_routes : cli ( ** self . where ( ** route ) . route )( handler ) return class_definition return decorator def cli ( self , method ) : \"\"\" Registers a method on an Object as a CLI route \"\"\" routes = getattr ( method , \" _hug_cli_routes \" , [] ) routes . append ( self . route ) method . _hug_cli_routes = routes return method","title":"Object"},{"location":"reference/hug/route/#ancestors-in-mro","text":"hug.route.URLRouter hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/route/#call","text":"class ( urls = None , accept = ( 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'PATCH' , 'POST' , 'PUT' , 'TRACE' ), output = None , examples = (), versions =< built - in function any > , suffixes = (), prefixes = (), response_headers = None , parse_body = True , ** kwargs ) Provides a chainable router that can be used to route a URL to a Python function View Source class URLRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route a URL to a Python function \"\"\" __slots__ = () def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , examples = () , versions = any , suffixes = () , prefixes = () , response_headers = None , parse_body = True , ** kwargs ) : super () . __init__ ( output = output , versions = versions , parse_body = parse_body , response_headers = response_headers , ** kwargs ) if urls is not None : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls if accept : self . route [ \" accept \" ] = ( accept , ) if isinstance ( accept , str ) else accept if examples : self . route [ \" examples \" ] = ( examples , ) if isinstance ( examples , str ) else examples if suffixes : self . route [ \" suffixes \" ] = ( suffixes , ) if isinstance ( suffixes , str ) else suffixes if prefixes : self . route [ \" prefixes \" ] = ( prefixes , ) if isinstance ( prefixes , str ) else prefixes def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) api . http . routes . setdefault ( api . http . base_url , OrderedDict ()) ( interface , callable_method ) = self . _create_interface ( api , api_function ) use_examples = self . route . get ( \" examples \" , ()) if not interface . required and not use_examples : use_examples = ( True , ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : expose = [ base_url ] for suffix in self . route . get ( \" suffixes \" , ()) : if suffix . startswith ( \" / \" ) : expose . append ( os . path . join ( base_url , suffix . lstrip ( \" / \" ))) else : expose . append ( base_url + suffix ) for prefix in self . route . get ( \" prefixes \" , ()) : expose . append ( prefix + base_url ) for url in expose : handlers = api . http . routes [ api . http . base_url ]. setdefault ( url , {} ) for method in self . route . get ( \" accept \" , ()) : version_mapping = handlers . setdefault ( method . upper () , {} ) for version in self . route . get ( \" versions \" , ( None , )) : version_mapping [ version ] = interface api . http . versioned . setdefault ( version , {} ) [ callable_method . __name__ ] = callable_method interface . examples = use_examples return callable_method def urls ( self , * urls , ** overrides ) : \"\"\" Sets the URLs that will map to this API call \"\"\" return self . where ( urls = urls , ** overrides ) def accept ( self , * accept , ** overrides ) : \"\"\" Sets a list of HTTP methods this router should accept \"\"\" return self . where ( accept = accept , ** overrides ) def get ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to a GET \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" GET \" , ** overrides ) def delete ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to DELETE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" DELETE \" , ** overrides ) def post ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to POST \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" POST \" , ** overrides ) def put ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PUT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PUT \" , ** overrides ) def trace ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to TRACE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" TRACE \" , ** overrides ) def patch ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PATCH \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PATCH \" , ** overrides ) def options ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to OPTIONS \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" OPTIONS \" , ** overrides ) def head ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to HEAD \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" HEAD \" , ** overrides ) def connect ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to CONNECT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" CONNECT \" , ** overrides ) def call ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def http ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def get_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and GET methods \"\"\" return self . where ( accept = ( \" GET \" , \" POST \" ) , ** overrides ) def put_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and PUT methods \"\"\" return self . where ( accept = ( \" PUT \" , \" POST \" ) , ** overrides ) def examples ( self , * examples , ** overrides ) : \"\"\" Sets the examples that the route should use \"\"\" return self . where ( examples = examples , ** overrides ) def suffixes ( self , * suffixes , ** overrides ) : \"\"\" Sets the suffixes supported by the route \"\"\" return self . where ( suffixes = suffixes , ** overrides ) def prefixes ( self , * prefixes , ** overrides ) : \"\"\" Sets the prefixes supported by the route \"\"\" return self . where ( prefixes = prefixes , ** overrides ) def where ( self , ** overrides ) : if \" urls \" in overrides : existing_urls = self . route . get ( \" urls \" , ()) use_urls = [] for url in ( ( overrides [ \" urls \" ], ) if isinstance ( overrides [ \" urls \" ], str ) else overrides [ \" urls \" ] ) : if url . startswith ( \" / \" ) or not existing_urls : use_urls . append ( url ) else : for existing in existing_urls : use_urls . append ( urljoin ( existing . rstrip ( \" / \" ) + \" / \" , url )) overrides [ \" urls \" ] = tuple ( use_urls ) return super () . where ( ** overrides )","title":"call"},{"location":"reference/hug/route/#ancestors-in-mro_1","text":"hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/route/#descendants","text":"hug.route.Object","title":"Descendants"},{"location":"reference/hug/routing/","text":"Module hug.routing hug/routing.py Defines the chainable classes responsible for defining the routing of Python functions for use with Falcon and CLIs Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/routing.py Defines the chainable classes responsible for defining the routing of Python functions for use with Falcon and CLIs Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import os import re from collections import OrderedDict from functools import wraps from urllib . parse import urljoin import falcon from falcon import HTTP_METHODS import hug . api import hug . interface import hug . output_format from hug import introspect from hug . exceptions import InvalidTypeData class Router ( object ) : \"\"\" The base chainable router object \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , transform = None , output = None , validate = None , api = None , requires = () , map_params = None , args = None , ** kwargs ) : self . route = {} if transform is not None : self . route [ \" transform \" ] = transform if output : self . route [ \" output \" ] = output if validate : self . route [ \" validate \" ] = validate if api : self . route [ \" api \" ] = api if requires : self . route [ \" requires \" ] = ( ( requires , ) if not isinstance ( requires , ( tuple , list )) else requires ) if map_params : self . route [ \" map_params \" ] = map_params if args : self . route [ \" args \" ] = args def output ( self , formatter , ** overrides ) : \"\"\" Sets the output formatter that should be used to render this route \"\"\" return self . where ( output = formatter , ** overrides ) def transform ( self , function , ** overrides ) : \"\"\" Sets the function that should be used to transform the returned Python structure into something serializable by specified output format \"\"\" return self . where ( transform = function , ** overrides ) def validate ( self , validation_function , ** overrides ) : \"\"\" Sets the secondary validation fucntion to use for this handler \"\"\" return self . where ( validate = validation_function , ** overrides ) def api ( self , api , ** overrides ) : \"\"\" Sets the API that should contain this route \"\"\" return self . where ( api = api , ** overrides ) def requires ( self , requirements , ** overrides ) : \"\"\" Adds additional requirements to the specified route \"\"\" return self . where ( requires = tuple ( self . route . get ( \" requires \" , ())) + tuple ( requirements ) , ** overrides ) def doesnt_require ( self , requirements , ** overrides ) : \"\"\" Removes individual requirements while keeping all other defined ones within a route \"\"\" return self . where ( requires = tuple ( set ( self . route . get ( \" requires \" , ())) . difference ( requirements if type ( requirements ) in ( list , tuple ) else ( requirements , ) ) ) ) def map_params ( self , ** map_params ) : \"\"\" Map interface specific params to an internal name representation \"\"\" return self . where ( map_params = map_params ) def where ( self , ** overrides ) : \"\"\" Creates a new route, based on the current route, with the specified overrided values \"\"\" route_data = self . route . copy () route_data . update ( overrides ) return self . __class__ ( ** route_data ) class CLIRouter ( Router ) : \"\"\" The CLIRouter provides a chainable router that can be used to route a CLI command to a Python function \"\"\" __slots__ = () def __init__ ( self , name = None , version = None , doc = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if name is not None : self . route [ \" name \" ] = name if version : self . route [ \" version \" ] = version if doc : self . route [ \" doc \" ] = doc def name ( self , name , ** overrides ) : \"\"\" Sets the name for the CLI interface \"\"\" return self . where ( name = name , ** overrides ) def version ( self , version , ** overrides ) : \"\"\" Sets the version for the CLI interface \"\"\" return self . where ( version = version , ** overrides ) def doc ( self , documentation , ** overrides ) : \"\"\" Sets the documentation for the CLI interface \"\"\" return self . where ( doc = documentation , ** overrides ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a Hug compatible function as a Command Line Interface \"\"\" hug . interface . CLI ( self . route , api_function ) return api_function class InternalValidation ( Router ) : \"\"\" Defines the base route for interfaces that define their own internal validation \"\"\" __slots__ = () def __init__ ( self , raise_on_invalid = False , on_invalid = None , output_invalid = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if raise_on_invalid : self . route [ \" raise_on_invalid \" ] = raise_on_invalid if on_invalid is not None : self . route [ \" on_invalid \" ] = on_invalid if output_invalid is not None : self . route [ \" output_invalid \" ] = output_invalid def raise_on_invalid ( self , setting = True , ** overrides ) : \"\"\" Sets the route to raise validation errors instead of catching them \"\"\" return self . where ( raise_on_invalid = setting , ** overrides ) def on_invalid ( self , function , ** overrides ) : \"\"\" Sets a function to use to transform data on validation errors. Defaults to the transform function if one is set to ensure no special handling occurs for invalid data set to ` False `. \"\"\" return self . where ( on_invalid = function , ** overrides ) def output_invalid ( self , output_handler , ** overrides ) : \"\"\" Sets an output handler to be used when handler validation fails. Defaults to the output formatter set globally for the route . \"\"\" return self . where ( output_invalid = output_handler , ** overrides ) class LocalRouter ( InternalValidation ) : \"\"\" The LocalRouter defines how interfaces should be handled when accessed locally from within Python code \"\"\" __slots__ = () def __init__ ( self , directives = True , validate = True , version = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if version is not None : self . route [ \" version \" ] = version if not directives : self . route [ \" skip_directives \" ] = True if not validate : self . route [ \" skip_validation \" ] = True def directives ( self , use = True , ** kwargs ) : return self . where ( directives = use ) def validate ( self , enforce = True , ** kwargs ) : return self . where ( validate = enforce ) def version ( self , supported , ** kwargs ) : return self . where ( version = supported ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a hug compatible function locally \"\"\" return hug . interface . Local ( self . route , api_function ) class HTTPRouter ( InternalValidation ) : \"\"\" The HTTPRouter provides the base concept of a router from an HTTPRequest to a Python function \"\"\" __slots__ = () def __init__ ( self , versions = any , parse_body = False , parameters = None , defaults = None , status = None , response_headers = None , private = False , inputs = None , ** kwargs ) : if defaults is None : defaults = {} super () . __init__ ( ** kwargs ) if versions is not any : self . route [ \" versions \" ] = ( ( versions , ) if isinstance ( versions , ( int , float , None . __class__ )) else versions ) self . route [ \" versions \" ] = tuple ( int ( version ) if version else version for version in self . route [ \" versions \" ] ) if parse_body : self . route [ \" parse_body \" ] = parse_body if parameters : self . route [ \" parameters \" ] = parameters if defaults : self . route [ \" defaults \" ] = defaults if status : self . route [ \" status \" ] = status if response_headers : self . route [ \" response_headers \" ] = response_headers if private : self . route [ \" private \" ] = private if inputs : self . route [ \" inputs \" ] = inputs def versions ( self , supported , ** overrides ) : \"\"\" Sets the versions that this route should be compatiable with \"\"\" return self . where ( versions = supported , ** overrides ) def parse_body ( self , automatic = True , ** overrides ) : \"\"\" Tells hug to automatically parse the input body if it matches a registered input format \"\"\" return self . where ( parse_body = automatic , ** overrides ) def set_status ( self , status , ** overrides ) : \"\"\" Sets the status that will be returned by default \"\"\" return self . where ( status = status , ** overrides ) def parameters ( self , parameters , ** overrides ) : \"\"\" Sets the custom parameters that will be used instead of those found introspecting the decorated function \"\"\" return self . where ( parameters = parameters , ** overrides ) def defaults ( self , defaults , ** overrides ) : \"\"\" Sets the custom defaults that will be used for custom parameters \"\"\" return self . where ( defaults = defaults , ** overrides ) def _create_interface ( self , api , api_function , catch_exceptions = True ) : interface = hug . interface . HTTP ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) def response_headers ( self , headers , ** overrides ) : \"\"\" Sets the response headers automatically injected by the router \"\"\" return self . where ( response_headers = headers , ** overrides ) def add_response_headers ( self , headers , ** overrides ) : \"\"\" Adds the specified response headers while keeping existing ones in-tact \"\"\" response_headers = self . route . get ( \" response_headers \" , {} ) . copy () response_headers . update ( headers ) return self . where ( response_headers = response_headers , ** overrides ) def cache ( self , private = False , max_age = 31536000 , s_maxage = None , no_cache = False , no_store = False , must_revalidate = False , ** overrides ) : \"\"\" Convenience method for quickly adding cache header to route \"\"\" parts = ( \" private \" if private else \" public \" , \" max-age={0} \" . format ( max_age ) , \" s-maxage={0} \" . format ( s_maxage ) if s_maxage is not None else None , no_cache and \" no-cache \" , no_store and \" no-store \" , must_revalidate and \" must-revalidate \" , ) return self . add_response_headers ( { \" cache-control \" : \" , \" . join ( filter ( bool , parts )) }, ** overrides ) def allow_origins ( self , * origins , methods = None , max_age = None , credentials = None , headers = None , ** overrides ) : \"\"\" Convenience method for quickly allowing other resources to access this one \"\"\" response_headers = {} if origins : @ hug . response_middleware ( api = self . route . get ( \" api \" , None )) def process_data ( request , response , resource ) : if \" ORIGIN \" in request . headers : origin = request . headers [ \" ORIGIN \" ] if origin in origins : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) else : response_headers [ \" Access-Control-Allow-Origin \" ] = \" * \" if methods : response_headers [ \" Access-Control-Allow-Methods \" ] = \" , \" . join ( methods ) if max_age : response_headers [ \" Access-Control-Max-Age \" ] = max_age if credentials : response_headers [ \" Access-Control-Allow-Credentials \" ] = str ( credentials ) . lower () if headers : response_headers [ \" Access-Control-Allow-Headers \" ] = headers return self . add_response_headers ( response_headers , ** overrides ) class NotFoundRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route 404'd request to a Python function \"\"\" __slots__ = () def __init__ ( self , output = None , versions = any , status = falcon . HTTP_NOT_FOUND , ** kwargs ) : super () . __init__ ( output = output , versions = versions , status = status , ** kwargs ) def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for version in self . route . get ( \" versions \" , ( None , )) : api . http . set_not_found_handler ( interface , version ) return callable_method class SinkRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route all routes pass a certain base URL (essentially route/*) \"\"\" __slots__ = () def __init__ ( self , urls = None , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) if urls : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : api . http . add_sink ( interface , base_url ) return callable_method class StaticRouter ( SinkRouter ) : \"\"\" Provides a chainable router that can be used to return static files automatically from a set of directories \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , urls = None , output = hug . output_format . file , cache = False , ** kwargs ) : super () . __init__ ( urls = urls , output = output , ** kwargs ) if cache is True : self . cache () elif cache is not False : self . cache ( ** cache ) def __call__ ( self , api_function ) : directories = [] for directory in api_function () : path = os . path . abspath ( directory ) directories . append ( path ) api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : def read_file ( request = None , path = \"\" ) : filename = path . lstrip ( \" / \" ) for directory in directories : path = os . path . abspath ( os . path . join ( directory , filename )) if not path . startswith ( directory ) : hug . redirect . not_found () if os . path . isdir ( path ) : new_path = os . path . join ( path , \" index.html \" ) if os . path . exists ( new_path ) and os . path . isfile ( new_path ) : path = new_path if os . path . exists ( path ) and os . path . isfile ( path ) : return path hug . redirect . not_found () api . http . add_sink ( self . _create_interface ( api , read_file ) [ 0 ], base_url ) return api_function class ExceptionRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route exceptions thrown during request handling \"\"\" __slots__ = () def __init__ ( self , exceptions = ( Exception , ) , exclude = () , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) self . route [ \" exceptions \" ] = ( ( exceptions , ) if not isinstance ( exceptions , ( list , tuple )) else exceptions ) self . route [ \" exclude \" ] = ( exclude , ) if not isinstance ( exclude , ( list , tuple )) else exclude def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function , catch_exceptions = False ) for version in self . route . get ( \" versions \" , ( None , )) : for exception in self . route [ \" exceptions \" ]: api . http . add_exception_handler ( exception , interface , version ) return callable_method def _create_interface ( self , api , api_function , catch_exceptions = False ) : interface = hug . interface . ExceptionRaised ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) class URLRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route a URL to a Python function \"\"\" __slots__ = () def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , examples = () , versions = any , suffixes = () , prefixes = () , response_headers = None , parse_body = True , ** kwargs ) : super () . __init__ ( output = output , versions = versions , parse_body = parse_body , response_headers = response_headers , ** kwargs ) if urls is not None : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls if accept : self . route [ \" accept \" ] = ( accept , ) if isinstance ( accept , str ) else accept if examples : self . route [ \" examples \" ] = ( examples , ) if isinstance ( examples , str ) else examples if suffixes : self . route [ \" suffixes \" ] = ( suffixes , ) if isinstance ( suffixes , str ) else suffixes if prefixes : self . route [ \" prefixes \" ] = ( prefixes , ) if isinstance ( prefixes , str ) else prefixes def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) api . http . routes . setdefault ( api . http . base_url , OrderedDict ()) ( interface , callable_method ) = self . _create_interface ( api , api_function ) use_examples = self . route . get ( \" examples \" , ()) if not interface . required and not use_examples : use_examples = ( True , ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : expose = [ base_url ] for suffix in self . route . get ( \" suffixes \" , ()) : if suffix . startswith ( \" / \" ) : expose . append ( os . path . join ( base_url , suffix . lstrip ( \" / \" ))) else : expose . append ( base_url + suffix ) for prefix in self . route . get ( \" prefixes \" , ()) : expose . append ( prefix + base_url ) for url in expose : handlers = api . http . routes [ api . http . base_url ]. setdefault ( url , {} ) for method in self . route . get ( \" accept \" , ()) : version_mapping = handlers . setdefault ( method . upper () , {} ) for version in self . route . get ( \" versions \" , ( None , )) : version_mapping [ version ] = interface api . http . versioned . setdefault ( version , {} ) [ callable_method . __name__ ] = callable_method interface . examples = use_examples return callable_method def urls ( self , * urls , ** overrides ) : \"\"\" Sets the URLs that will map to this API call \"\"\" return self . where ( urls = urls , ** overrides ) def accept ( self , * accept , ** overrides ) : \"\"\" Sets a list of HTTP methods this router should accept \"\"\" return self . where ( accept = accept , ** overrides ) def get ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to a GET \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" GET \" , ** overrides ) def delete ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to DELETE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" DELETE \" , ** overrides ) def post ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to POST \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" POST \" , ** overrides ) def put ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PUT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PUT \" , ** overrides ) def trace ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to TRACE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" TRACE \" , ** overrides ) def patch ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PATCH \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PATCH \" , ** overrides ) def options ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to OPTIONS \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" OPTIONS \" , ** overrides ) def head ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to HEAD \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" HEAD \" , ** overrides ) def connect ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to CONNECT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" CONNECT \" , ** overrides ) def call ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def http ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def get_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and GET methods \"\"\" return self . where ( accept = ( \" GET \" , \" POST \" ) , ** overrides ) def put_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and PUT methods \"\"\" return self . where ( accept = ( \" PUT \" , \" POST \" ) , ** overrides ) def examples ( self , * examples , ** overrides ) : \"\"\" Sets the examples that the route should use \"\"\" return self . where ( examples = examples , ** overrides ) def suffixes ( self , * suffixes , ** overrides ) : \"\"\" Sets the suffixes supported by the route \"\"\" return self . where ( suffixes = suffixes , ** overrides ) def prefixes ( self , * prefixes , ** overrides ) : \"\"\" Sets the prefixes supported by the route \"\"\" return self . where ( prefixes = prefixes , ** overrides ) def where ( self , ** overrides ) : if \" urls \" in overrides : existing_urls = self . route . get ( \" urls \" , ()) use_urls = [] for url in ( ( overrides [ \" urls \" ], ) if isinstance ( overrides [ \" urls \" ], str ) else overrides [ \" urls \" ] ) : if url . startswith ( \" / \" ) or not existing_urls : use_urls . append ( url ) else : for existing in existing_urls : use_urls . append ( urljoin ( existing . rstrip ( \" / \" ) + \" / \" , url )) overrides [ \" urls \" ] = tuple ( use_urls ) return super () . where ( ** overrides ) Variables HTTP_METHODS Classes CLIRouter class ( name = None , version = None , doc = None , ** kwargs ) The CLIRouter provides a chainable router that can be used to route a CLI command to a Python function View Source class CLIRouter ( Router ) : \"\"\" The CLIRouter provides a chainable router that can be used to route a CLI command to a Python function \"\"\" __slots__ = () def __init__ ( self , name = None , version = None , doc = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if name is not None : self . route [ \" name \" ] = name if version : self . route [ \" version \" ] = version if doc : self . route [ \" doc \" ] = doc def name ( self , name , ** overrides ) : \"\"\" Sets the name for the CLI interface \"\"\" return self . where ( name = name , ** overrides ) def version ( self , version , ** overrides ) : \"\"\" Sets the version for the CLI interface \"\"\" return self . where ( version = version , ** overrides ) def doc ( self , documentation , ** overrides ) : \"\"\" Sets the documentation for the CLI interface \"\"\" return self . where ( doc = documentation , ** overrides ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a Hug compatible function as a Command Line Interface \"\"\" hug . interface . CLI ( self . route , api_function ) return api_function Ancestors (in MRO) hug.routing.Router ExceptionRouter class ( exceptions = ( < class ' Exception '>,), exclude = (), output = None , ** kwargs ) Provides a chainable router that can be used to route exceptions thrown during request handling View Source class ExceptionRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route exceptions thrown during request handling \"\"\" __slots__ = () def __init__ ( self , exceptions = ( Exception , ) , exclude = () , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) self . route [ \" exceptions \" ] = ( ( exceptions , ) if not isinstance ( exceptions , ( list , tuple )) else exceptions ) self . route [ \" exclude \" ] = ( exclude , ) if not isinstance ( exclude , ( list , tuple )) else exclude def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function , catch_exceptions = False ) for version in self . route . get ( \" versions \" , ( None , )) : for exception in self . route [ \" exceptions \" ]: api . http . add_exception_handler ( exception , interface , version ) return callable_method def _create_interface ( self , api , api_function , catch_exceptions = False ) : interface = hug . interface . ExceptionRaised ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) Ancestors (in MRO) hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router HTTPRouter class ( versions =< built - in function any > , parse_body = False , parameters = None , defaults = None , status = None , response_headers = None , private = False , inputs = None , ** kwargs ) The HTTPRouter provides the base concept of a router from an HTTPRequest to a Python function View Source class HTTPRouter ( InternalValidation ) : \"\"\" The HTTPRouter provides the base concept of a router from an HTTPRequest to a Python function \"\"\" __slots__ = () def __init__ ( self , versions = any , parse_body = False , parameters = None , defaults = None , status = None , response_headers = None , private = False , inputs = None , ** kwargs ) : if defaults is None : defaults = {} super () . __init__ ( ** kwargs ) if versions is not any : self . route [ \" versions \" ] = ( ( versions , ) if isinstance ( versions , ( int , float , None . __class__ )) else versions ) self . route [ \" versions \" ] = tuple ( int ( version ) if version else version for version in self . route [ \" versions \" ] ) if parse_body : self . route [ \" parse_body \" ] = parse_body if parameters : self . route [ \" parameters \" ] = parameters if defaults : self . route [ \" defaults \" ] = defaults if status : self . route [ \" status \" ] = status if response_headers : self . route [ \" response_headers \" ] = response_headers if private : self . route [ \" private \" ] = private if inputs : self . route [ \" inputs \" ] = inputs def versions ( self , supported , ** overrides ) : \"\"\" Sets the versions that this route should be compatiable with \"\"\" return self . where ( versions = supported , ** overrides ) def parse_body ( self , automatic = True , ** overrides ) : \"\"\" Tells hug to automatically parse the input body if it matches a registered input format \"\"\" return self . where ( parse_body = automatic , ** overrides ) def set_status ( self , status , ** overrides ) : \"\"\" Sets the status that will be returned by default \"\"\" return self . where ( status = status , ** overrides ) def parameters ( self , parameters , ** overrides ) : \"\"\" Sets the custom parameters that will be used instead of those found introspecting the decorated function \"\"\" return self . where ( parameters = parameters , ** overrides ) def defaults ( self , defaults , ** overrides ) : \"\"\" Sets the custom defaults that will be used for custom parameters \"\"\" return self . where ( defaults = defaults , ** overrides ) def _create_interface ( self , api , api_function , catch_exceptions = True ) : interface = hug . interface . HTTP ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) def response_headers ( self , headers , ** overrides ) : \"\"\" Sets the response headers automatically injected by the router \"\"\" return self . where ( response_headers = headers , ** overrides ) def add_response_headers ( self , headers , ** overrides ) : \"\"\" Adds the specified response headers while keeping existing ones in-tact \"\"\" response_headers = self . route . get ( \" response_headers \" , {} ) . copy () response_headers . update ( headers ) return self . where ( response_headers = response_headers , ** overrides ) def cache ( self , private = False , max_age = 31536000 , s_maxage = None , no_cache = False , no_store = False , must_revalidate = False , ** overrides ) : \"\"\" Convenience method for quickly adding cache header to route \"\"\" parts = ( \" private \" if private else \" public \" , \" max-age={0} \" . format ( max_age ) , \" s-maxage={0} \" . format ( s_maxage ) if s_maxage is not None else None , no_cache and \" no-cache \" , no_store and \" no-store \" , must_revalidate and \" must-revalidate \" , ) return self . add_response_headers ( { \" cache-control \" : \" , \" . join ( filter ( bool , parts )) }, ** overrides ) def allow_origins ( self , * origins , methods = None , max_age = None , credentials = None , headers = None , ** overrides ) : \"\"\" Convenience method for quickly allowing other resources to access this one \"\"\" response_headers = {} if origins : @ hug . response_middleware ( api = self . route . get ( \" api \" , None )) def process_data ( request , response , resource ) : if \" ORIGIN \" in request . headers : origin = request . headers [ \" ORIGIN \" ] if origin in origins : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) else : response_headers [ \" Access-Control-Allow-Origin \" ] = \" * \" if methods : response_headers [ \" Access-Control-Allow-Methods \" ] = \" , \" . join ( methods ) if max_age : response_headers [ \" Access-Control-Max-Age \" ] = max_age if credentials : response_headers [ \" Access-Control-Allow-Credentials \" ] = str ( credentials ) . lower () if headers : response_headers [ \" Access-Control-Allow-Headers \" ] = headers return self . add_response_headers ( response_headers , ** overrides ) Ancestors (in MRO) hug.routing.InternalValidation hug.routing.Router Descendants hug.routing.NotFoundRouter hug.routing.SinkRouter hug.routing.ExceptionRouter hug.routing.URLRouter InternalValidation class ( raise_on_invalid = False , on_invalid = None , output_invalid = None , ** kwargs ) Defines the base route for interfaces that define their own internal validation View Source class InternalValidation ( Router ) : \"\"\" Defines the base route for interfaces that define their own internal validation \"\"\" __slots__ = () def __init__ ( self , raise_on_invalid = False , on_invalid = None , output_invalid = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if raise_on_invalid : self . route [ \" raise_on_invalid \" ] = raise_on_invalid if on_invalid is not None : self . route [ \" on_invalid \" ] = on_invalid if output_invalid is not None : self . route [ \" output_invalid \" ] = output_invalid def raise_on_invalid ( self , setting = True , ** overrides ) : \"\"\" Sets the route to raise validation errors instead of catching them \"\"\" return self . where ( raise_on_invalid = setting , ** overrides ) def on_invalid ( self , function , ** overrides ) : \"\"\" Sets a function to use to transform data on validation errors. Defaults to the transform function if one is set to ensure no special handling occurs for invalid data set to ` False `. \"\"\" return self . where ( on_invalid = function , ** overrides ) def output_invalid ( self , output_handler , ** overrides ) : \"\"\" Sets an output handler to be used when handler validation fails. Defaults to the output formatter set globally for the route . \"\"\" return self . where ( output_invalid = output_handler , ** overrides ) Ancestors (in MRO) hug.routing.Router Descendants hug.routing.LocalRouter hug.routing.HTTPRouter LocalRouter class ( directives = True , validate = True , version = None , ** kwargs ) The LocalRouter defines how interfaces should be handled when accessed locally from within Python code View Source class LocalRouter ( InternalValidation ) : \"\"\" The LocalRouter defines how interfaces should be handled when accessed locally from within Python code \"\"\" __slots__ = () def __init__ ( self , directives = True , validate = True , version = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if version is not None : self . route [ \" version \" ] = version if not directives : self . route [ \" skip_directives \" ] = True if not validate : self . route [ \" skip_validation \" ] = True def directives ( self , use = True , ** kwargs ) : return self . where ( directives = use ) def validate ( self , enforce = True , ** kwargs ) : return self . where ( validate = enforce ) def version ( self , supported , ** kwargs ) : return self . where ( version = supported ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a hug compatible function locally \"\"\" return hug . interface . Local ( self . route , api_function ) Ancestors (in MRO) hug.routing.InternalValidation hug.routing.Router NotFoundRouter class ( output = None , versions =< built - in function any > , status = '404 Not Found' , ** kwargs ) Provides a chainable router that can be used to route 404'd request to a Python function View Source class NotFoundRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route 404'd request to a Python function \"\"\" __slots__ = () def __init__ ( self , output = None , versions = any , status = falcon . HTTP_NOT_FOUND , ** kwargs ) : super () . __init__ ( output = output , versions = versions , status = status , ** kwargs ) def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for version in self . route . get ( \" versions \" , ( None , )) : api . http . set_not_found_handler ( interface , version ) return callable_method Ancestors (in MRO) hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router Router class ( transform = None , output = None , validate = None , api = None , requires = (), map_params = None , args = None , ** kwargs ) The base chainable router object View Source class Router ( object ) : \"\"\" The base chainable router object \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , transform = None , output = None , validate = None , api = None , requires = () , map_params = None , args = None , ** kwargs ) : self . route = {} if transform is not None : self . route [ \" transform \" ] = transform if output : self . route [ \" output \" ] = output if validate : self . route [ \" validate \" ] = validate if api : self . route [ \" api \" ] = api if requires : self . route [ \" requires \" ] = ( ( requires , ) if not isinstance ( requires , ( tuple , list )) else requires ) if map_params : self . route [ \" map_params \" ] = map_params if args : self . route [ \" args \" ] = args def output ( self , formatter , ** overrides ) : \"\"\" Sets the output formatter that should be used to render this route \"\"\" return self . where ( output = formatter , ** overrides ) def transform ( self , function , ** overrides ) : \"\"\" Sets the function that should be used to transform the returned Python structure into something serializable by specified output format \"\"\" return self . where ( transform = function , ** overrides ) def validate ( self , validation_function , ** overrides ) : \"\"\" Sets the secondary validation fucntion to use for this handler \"\"\" return self . where ( validate = validation_function , ** overrides ) def api ( self , api , ** overrides ) : \"\"\" Sets the API that should contain this route \"\"\" return self . where ( api = api , ** overrides ) def requires ( self , requirements , ** overrides ) : \"\"\" Adds additional requirements to the specified route \"\"\" return self . where ( requires = tuple ( self . route . get ( \" requires \" , ())) + tuple ( requirements ) , ** overrides ) def doesnt_require ( self , requirements , ** overrides ) : \"\"\" Removes individual requirements while keeping all other defined ones within a route \"\"\" return self . where ( requires = tuple ( set ( self . route . get ( \" requires \" , ())) . difference ( requirements if type ( requirements ) in ( list , tuple ) else ( requirements , ) ) ) ) def map_params ( self , ** map_params ) : \"\"\" Map interface specific params to an internal name representation \"\"\" return self . where ( map_params = map_params ) def where ( self , ** overrides ) : \"\"\" Creates a new route, based on the current route, with the specified overrided values \"\"\" route_data = self . route . copy () route_data . update ( overrides ) return self . __class__ ( ** route_data ) Descendants hug.routing.CLIRouter hug.routing.InternalValidation SinkRouter class ( urls = None , output = None , ** kwargs ) Provides a chainable router that can be used to route all routes pass a certain base URL (essentially route/*) View Source class SinkRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route all routes pass a certain base URL (essentially route/*) \"\"\" __slots__ = () def __init__ ( self , urls = None , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) if urls : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : api . http . add_sink ( interface , base_url ) return callable_method Ancestors (in MRO) hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router Descendants hug.routing.StaticRouter StaticRouter class ( urls = None , output =< function file at 0x7f0676c9c048 > , cache = False , ** kwargs ) Provides a chainable router that can be used to return static files automatically from a set of directories View Source class StaticRouter ( SinkRouter ) : \"\"\" Provides a chainable router that can be used to return static files automatically from a set of directories \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , urls = None , output = hug . output_format . file , cache = False , ** kwargs ) : super () . __init__ ( urls = urls , output = output , ** kwargs ) if cache is True : self . cache () elif cache is not False : self . cache ( ** cache ) def __call__ ( self , api_function ) : directories = [] for directory in api_function () : path = os . path . abspath ( directory ) directories . append ( path ) api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : def read_file ( request = None , path = \"\" ) : filename = path . lstrip ( \" / \" ) for directory in directories : path = os . path . abspath ( os . path . join ( directory , filename )) if not path . startswith ( directory ) : hug . redirect . not_found () if os . path . isdir ( path ) : new_path = os . path . join ( path , \" index.html \" ) if os . path . exists ( new_path ) and os . path . isfile ( new_path ) : path = new_path if os . path . exists ( path ) and os . path . isfile ( path ) : return path hug . redirect . not_found () api . http . add_sink ( self . _create_interface ( api , read_file ) [ 0 ], base_url ) return api_function Ancestors (in MRO) hug.routing.SinkRouter hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router URLRouter class ( urls = None , accept = ( 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'PATCH' , 'POST' , 'PUT' , 'TRACE' ), output = None , examples = (), versions =< built - in function any > , suffixes = (), prefixes = (), response_headers = None , parse_body = True , ** kwargs ) Provides a chainable router that can be used to route a URL to a Python function View Source class URLRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route a URL to a Python function \"\"\" __slots__ = () def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , examples = () , versions = any , suffixes = () , prefixes = () , response_headers = None , parse_body = True , ** kwargs ) : super () . __init__ ( output = output , versions = versions , parse_body = parse_body , response_headers = response_headers , ** kwargs ) if urls is not None : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls if accept : self . route [ \" accept \" ] = ( accept , ) if isinstance ( accept , str ) else accept if examples : self . route [ \" examples \" ] = ( examples , ) if isinstance ( examples , str ) else examples if suffixes : self . route [ \" suffixes \" ] = ( suffixes , ) if isinstance ( suffixes , str ) else suffixes if prefixes : self . route [ \" prefixes \" ] = ( prefixes , ) if isinstance ( prefixes , str ) else prefixes def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) api . http . routes . setdefault ( api . http . base_url , OrderedDict ()) ( interface , callable_method ) = self . _create_interface ( api , api_function ) use_examples = self . route . get ( \" examples \" , ()) if not interface . required and not use_examples : use_examples = ( True , ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : expose = [ base_url ] for suffix in self . route . get ( \" suffixes \" , ()) : if suffix . startswith ( \" / \" ) : expose . append ( os . path . join ( base_url , suffix . lstrip ( \" / \" ))) else : expose . append ( base_url + suffix ) for prefix in self . route . get ( \" prefixes \" , ()) : expose . append ( prefix + base_url ) for url in expose : handlers = api . http . routes [ api . http . base_url ]. setdefault ( url , {} ) for method in self . route . get ( \" accept \" , ()) : version_mapping = handlers . setdefault ( method . upper () , {} ) for version in self . route . get ( \" versions \" , ( None , )) : version_mapping [ version ] = interface api . http . versioned . setdefault ( version , {} ) [ callable_method . __name__ ] = callable_method interface . examples = use_examples return callable_method def urls ( self , * urls , ** overrides ) : \"\"\" Sets the URLs that will map to this API call \"\"\" return self . where ( urls = urls , ** overrides ) def accept ( self , * accept , ** overrides ) : \"\"\" Sets a list of HTTP methods this router should accept \"\"\" return self . where ( accept = accept , ** overrides ) def get ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to a GET \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" GET \" , ** overrides ) def delete ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to DELETE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" DELETE \" , ** overrides ) def post ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to POST \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" POST \" , ** overrides ) def put ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PUT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PUT \" , ** overrides ) def trace ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to TRACE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" TRACE \" , ** overrides ) def patch ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PATCH \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PATCH \" , ** overrides ) def options ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to OPTIONS \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" OPTIONS \" , ** overrides ) def head ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to HEAD \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" HEAD \" , ** overrides ) def connect ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to CONNECT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" CONNECT \" , ** overrides ) def call ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def http ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def get_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and GET methods \"\"\" return self . where ( accept = ( \" GET \" , \" POST \" ) , ** overrides ) def put_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and PUT methods \"\"\" return self . where ( accept = ( \" PUT \" , \" POST \" ) , ** overrides ) def examples ( self , * examples , ** overrides ) : \"\"\" Sets the examples that the route should use \"\"\" return self . where ( examples = examples , ** overrides ) def suffixes ( self , * suffixes , ** overrides ) : \"\"\" Sets the suffixes supported by the route \"\"\" return self . where ( suffixes = suffixes , ** overrides ) def prefixes ( self , * prefixes , ** overrides ) : \"\"\" Sets the prefixes supported by the route \"\"\" return self . where ( prefixes = prefixes , ** overrides ) def where ( self , ** overrides ) : if \" urls \" in overrides : existing_urls = self . route . get ( \" urls \" , ()) use_urls = [] for url in ( ( overrides [ \" urls \" ], ) if isinstance ( overrides [ \" urls \" ], str ) else overrides [ \" urls \" ] ) : if url . startswith ( \" / \" ) or not existing_urls : use_urls . append ( url ) else : for existing in existing_urls : use_urls . append ( urljoin ( existing . rstrip ( \" / \" ) + \" / \" , url )) overrides [ \" urls \" ] = tuple ( use_urls ) return super () . where ( ** overrides ) Ancestors (in MRO) hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router Descendants hug.route.Object","title":"Routing"},{"location":"reference/hug/routing/#module-hugrouting","text":"hug/routing.py Defines the chainable classes responsible for defining the routing of Python functions for use with Falcon and CLIs Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/routing.py Defines the chainable classes responsible for defining the routing of Python functions for use with Falcon and CLIs Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import os import re from collections import OrderedDict from functools import wraps from urllib . parse import urljoin import falcon from falcon import HTTP_METHODS import hug . api import hug . interface import hug . output_format from hug import introspect from hug . exceptions import InvalidTypeData class Router ( object ) : \"\"\" The base chainable router object \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , transform = None , output = None , validate = None , api = None , requires = () , map_params = None , args = None , ** kwargs ) : self . route = {} if transform is not None : self . route [ \" transform \" ] = transform if output : self . route [ \" output \" ] = output if validate : self . route [ \" validate \" ] = validate if api : self . route [ \" api \" ] = api if requires : self . route [ \" requires \" ] = ( ( requires , ) if not isinstance ( requires , ( tuple , list )) else requires ) if map_params : self . route [ \" map_params \" ] = map_params if args : self . route [ \" args \" ] = args def output ( self , formatter , ** overrides ) : \"\"\" Sets the output formatter that should be used to render this route \"\"\" return self . where ( output = formatter , ** overrides ) def transform ( self , function , ** overrides ) : \"\"\" Sets the function that should be used to transform the returned Python structure into something serializable by specified output format \"\"\" return self . where ( transform = function , ** overrides ) def validate ( self , validation_function , ** overrides ) : \"\"\" Sets the secondary validation fucntion to use for this handler \"\"\" return self . where ( validate = validation_function , ** overrides ) def api ( self , api , ** overrides ) : \"\"\" Sets the API that should contain this route \"\"\" return self . where ( api = api , ** overrides ) def requires ( self , requirements , ** overrides ) : \"\"\" Adds additional requirements to the specified route \"\"\" return self . where ( requires = tuple ( self . route . get ( \" requires \" , ())) + tuple ( requirements ) , ** overrides ) def doesnt_require ( self , requirements , ** overrides ) : \"\"\" Removes individual requirements while keeping all other defined ones within a route \"\"\" return self . where ( requires = tuple ( set ( self . route . get ( \" requires \" , ())) . difference ( requirements if type ( requirements ) in ( list , tuple ) else ( requirements , ) ) ) ) def map_params ( self , ** map_params ) : \"\"\" Map interface specific params to an internal name representation \"\"\" return self . where ( map_params = map_params ) def where ( self , ** overrides ) : \"\"\" Creates a new route, based on the current route, with the specified overrided values \"\"\" route_data = self . route . copy () route_data . update ( overrides ) return self . __class__ ( ** route_data ) class CLIRouter ( Router ) : \"\"\" The CLIRouter provides a chainable router that can be used to route a CLI command to a Python function \"\"\" __slots__ = () def __init__ ( self , name = None , version = None , doc = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if name is not None : self . route [ \" name \" ] = name if version : self . route [ \" version \" ] = version if doc : self . route [ \" doc \" ] = doc def name ( self , name , ** overrides ) : \"\"\" Sets the name for the CLI interface \"\"\" return self . where ( name = name , ** overrides ) def version ( self , version , ** overrides ) : \"\"\" Sets the version for the CLI interface \"\"\" return self . where ( version = version , ** overrides ) def doc ( self , documentation , ** overrides ) : \"\"\" Sets the documentation for the CLI interface \"\"\" return self . where ( doc = documentation , ** overrides ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a Hug compatible function as a Command Line Interface \"\"\" hug . interface . CLI ( self . route , api_function ) return api_function class InternalValidation ( Router ) : \"\"\" Defines the base route for interfaces that define their own internal validation \"\"\" __slots__ = () def __init__ ( self , raise_on_invalid = False , on_invalid = None , output_invalid = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if raise_on_invalid : self . route [ \" raise_on_invalid \" ] = raise_on_invalid if on_invalid is not None : self . route [ \" on_invalid \" ] = on_invalid if output_invalid is not None : self . route [ \" output_invalid \" ] = output_invalid def raise_on_invalid ( self , setting = True , ** overrides ) : \"\"\" Sets the route to raise validation errors instead of catching them \"\"\" return self . where ( raise_on_invalid = setting , ** overrides ) def on_invalid ( self , function , ** overrides ) : \"\"\" Sets a function to use to transform data on validation errors. Defaults to the transform function if one is set to ensure no special handling occurs for invalid data set to ` False `. \"\"\" return self . where ( on_invalid = function , ** overrides ) def output_invalid ( self , output_handler , ** overrides ) : \"\"\" Sets an output handler to be used when handler validation fails. Defaults to the output formatter set globally for the route . \"\"\" return self . where ( output_invalid = output_handler , ** overrides ) class LocalRouter ( InternalValidation ) : \"\"\" The LocalRouter defines how interfaces should be handled when accessed locally from within Python code \"\"\" __slots__ = () def __init__ ( self , directives = True , validate = True , version = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if version is not None : self . route [ \" version \" ] = version if not directives : self . route [ \" skip_directives \" ] = True if not validate : self . route [ \" skip_validation \" ] = True def directives ( self , use = True , ** kwargs ) : return self . where ( directives = use ) def validate ( self , enforce = True , ** kwargs ) : return self . where ( validate = enforce ) def version ( self , supported , ** kwargs ) : return self . where ( version = supported ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a hug compatible function locally \"\"\" return hug . interface . Local ( self . route , api_function ) class HTTPRouter ( InternalValidation ) : \"\"\" The HTTPRouter provides the base concept of a router from an HTTPRequest to a Python function \"\"\" __slots__ = () def __init__ ( self , versions = any , parse_body = False , parameters = None , defaults = None , status = None , response_headers = None , private = False , inputs = None , ** kwargs ) : if defaults is None : defaults = {} super () . __init__ ( ** kwargs ) if versions is not any : self . route [ \" versions \" ] = ( ( versions , ) if isinstance ( versions , ( int , float , None . __class__ )) else versions ) self . route [ \" versions \" ] = tuple ( int ( version ) if version else version for version in self . route [ \" versions \" ] ) if parse_body : self . route [ \" parse_body \" ] = parse_body if parameters : self . route [ \" parameters \" ] = parameters if defaults : self . route [ \" defaults \" ] = defaults if status : self . route [ \" status \" ] = status if response_headers : self . route [ \" response_headers \" ] = response_headers if private : self . route [ \" private \" ] = private if inputs : self . route [ \" inputs \" ] = inputs def versions ( self , supported , ** overrides ) : \"\"\" Sets the versions that this route should be compatiable with \"\"\" return self . where ( versions = supported , ** overrides ) def parse_body ( self , automatic = True , ** overrides ) : \"\"\" Tells hug to automatically parse the input body if it matches a registered input format \"\"\" return self . where ( parse_body = automatic , ** overrides ) def set_status ( self , status , ** overrides ) : \"\"\" Sets the status that will be returned by default \"\"\" return self . where ( status = status , ** overrides ) def parameters ( self , parameters , ** overrides ) : \"\"\" Sets the custom parameters that will be used instead of those found introspecting the decorated function \"\"\" return self . where ( parameters = parameters , ** overrides ) def defaults ( self , defaults , ** overrides ) : \"\"\" Sets the custom defaults that will be used for custom parameters \"\"\" return self . where ( defaults = defaults , ** overrides ) def _create_interface ( self , api , api_function , catch_exceptions = True ) : interface = hug . interface . HTTP ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) def response_headers ( self , headers , ** overrides ) : \"\"\" Sets the response headers automatically injected by the router \"\"\" return self . where ( response_headers = headers , ** overrides ) def add_response_headers ( self , headers , ** overrides ) : \"\"\" Adds the specified response headers while keeping existing ones in-tact \"\"\" response_headers = self . route . get ( \" response_headers \" , {} ) . copy () response_headers . update ( headers ) return self . where ( response_headers = response_headers , ** overrides ) def cache ( self , private = False , max_age = 31536000 , s_maxage = None , no_cache = False , no_store = False , must_revalidate = False , ** overrides ) : \"\"\" Convenience method for quickly adding cache header to route \"\"\" parts = ( \" private \" if private else \" public \" , \" max-age={0} \" . format ( max_age ) , \" s-maxage={0} \" . format ( s_maxage ) if s_maxage is not None else None , no_cache and \" no-cache \" , no_store and \" no-store \" , must_revalidate and \" must-revalidate \" , ) return self . add_response_headers ( { \" cache-control \" : \" , \" . join ( filter ( bool , parts )) }, ** overrides ) def allow_origins ( self , * origins , methods = None , max_age = None , credentials = None , headers = None , ** overrides ) : \"\"\" Convenience method for quickly allowing other resources to access this one \"\"\" response_headers = {} if origins : @ hug . response_middleware ( api = self . route . get ( \" api \" , None )) def process_data ( request , response , resource ) : if \" ORIGIN \" in request . headers : origin = request . headers [ \" ORIGIN \" ] if origin in origins : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) else : response_headers [ \" Access-Control-Allow-Origin \" ] = \" * \" if methods : response_headers [ \" Access-Control-Allow-Methods \" ] = \" , \" . join ( methods ) if max_age : response_headers [ \" Access-Control-Max-Age \" ] = max_age if credentials : response_headers [ \" Access-Control-Allow-Credentials \" ] = str ( credentials ) . lower () if headers : response_headers [ \" Access-Control-Allow-Headers \" ] = headers return self . add_response_headers ( response_headers , ** overrides ) class NotFoundRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route 404'd request to a Python function \"\"\" __slots__ = () def __init__ ( self , output = None , versions = any , status = falcon . HTTP_NOT_FOUND , ** kwargs ) : super () . __init__ ( output = output , versions = versions , status = status , ** kwargs ) def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for version in self . route . get ( \" versions \" , ( None , )) : api . http . set_not_found_handler ( interface , version ) return callable_method class SinkRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route all routes pass a certain base URL (essentially route/*) \"\"\" __slots__ = () def __init__ ( self , urls = None , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) if urls : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : api . http . add_sink ( interface , base_url ) return callable_method class StaticRouter ( SinkRouter ) : \"\"\" Provides a chainable router that can be used to return static files automatically from a set of directories \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , urls = None , output = hug . output_format . file , cache = False , ** kwargs ) : super () . __init__ ( urls = urls , output = output , ** kwargs ) if cache is True : self . cache () elif cache is not False : self . cache ( ** cache ) def __call__ ( self , api_function ) : directories = [] for directory in api_function () : path = os . path . abspath ( directory ) directories . append ( path ) api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : def read_file ( request = None , path = \"\" ) : filename = path . lstrip ( \" / \" ) for directory in directories : path = os . path . abspath ( os . path . join ( directory , filename )) if not path . startswith ( directory ) : hug . redirect . not_found () if os . path . isdir ( path ) : new_path = os . path . join ( path , \" index.html \" ) if os . path . exists ( new_path ) and os . path . isfile ( new_path ) : path = new_path if os . path . exists ( path ) and os . path . isfile ( path ) : return path hug . redirect . not_found () api . http . add_sink ( self . _create_interface ( api , read_file ) [ 0 ], base_url ) return api_function class ExceptionRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route exceptions thrown during request handling \"\"\" __slots__ = () def __init__ ( self , exceptions = ( Exception , ) , exclude = () , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) self . route [ \" exceptions \" ] = ( ( exceptions , ) if not isinstance ( exceptions , ( list , tuple )) else exceptions ) self . route [ \" exclude \" ] = ( exclude , ) if not isinstance ( exclude , ( list , tuple )) else exclude def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function , catch_exceptions = False ) for version in self . route . get ( \" versions \" , ( None , )) : for exception in self . route [ \" exceptions \" ]: api . http . add_exception_handler ( exception , interface , version ) return callable_method def _create_interface ( self , api , api_function , catch_exceptions = False ) : interface = hug . interface . ExceptionRaised ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) class URLRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route a URL to a Python function \"\"\" __slots__ = () def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , examples = () , versions = any , suffixes = () , prefixes = () , response_headers = None , parse_body = True , ** kwargs ) : super () . __init__ ( output = output , versions = versions , parse_body = parse_body , response_headers = response_headers , ** kwargs ) if urls is not None : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls if accept : self . route [ \" accept \" ] = ( accept , ) if isinstance ( accept , str ) else accept if examples : self . route [ \" examples \" ] = ( examples , ) if isinstance ( examples , str ) else examples if suffixes : self . route [ \" suffixes \" ] = ( suffixes , ) if isinstance ( suffixes , str ) else suffixes if prefixes : self . route [ \" prefixes \" ] = ( prefixes , ) if isinstance ( prefixes , str ) else prefixes def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) api . http . routes . setdefault ( api . http . base_url , OrderedDict ()) ( interface , callable_method ) = self . _create_interface ( api , api_function ) use_examples = self . route . get ( \" examples \" , ()) if not interface . required and not use_examples : use_examples = ( True , ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : expose = [ base_url ] for suffix in self . route . get ( \" suffixes \" , ()) : if suffix . startswith ( \" / \" ) : expose . append ( os . path . join ( base_url , suffix . lstrip ( \" / \" ))) else : expose . append ( base_url + suffix ) for prefix in self . route . get ( \" prefixes \" , ()) : expose . append ( prefix + base_url ) for url in expose : handlers = api . http . routes [ api . http . base_url ]. setdefault ( url , {} ) for method in self . route . get ( \" accept \" , ()) : version_mapping = handlers . setdefault ( method . upper () , {} ) for version in self . route . get ( \" versions \" , ( None , )) : version_mapping [ version ] = interface api . http . versioned . setdefault ( version , {} ) [ callable_method . __name__ ] = callable_method interface . examples = use_examples return callable_method def urls ( self , * urls , ** overrides ) : \"\"\" Sets the URLs that will map to this API call \"\"\" return self . where ( urls = urls , ** overrides ) def accept ( self , * accept , ** overrides ) : \"\"\" Sets a list of HTTP methods this router should accept \"\"\" return self . where ( accept = accept , ** overrides ) def get ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to a GET \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" GET \" , ** overrides ) def delete ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to DELETE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" DELETE \" , ** overrides ) def post ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to POST \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" POST \" , ** overrides ) def put ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PUT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PUT \" , ** overrides ) def trace ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to TRACE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" TRACE \" , ** overrides ) def patch ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PATCH \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PATCH \" , ** overrides ) def options ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to OPTIONS \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" OPTIONS \" , ** overrides ) def head ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to HEAD \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" HEAD \" , ** overrides ) def connect ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to CONNECT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" CONNECT \" , ** overrides ) def call ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def http ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def get_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and GET methods \"\"\" return self . where ( accept = ( \" GET \" , \" POST \" ) , ** overrides ) def put_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and PUT methods \"\"\" return self . where ( accept = ( \" PUT \" , \" POST \" ) , ** overrides ) def examples ( self , * examples , ** overrides ) : \"\"\" Sets the examples that the route should use \"\"\" return self . where ( examples = examples , ** overrides ) def suffixes ( self , * suffixes , ** overrides ) : \"\"\" Sets the suffixes supported by the route \"\"\" return self . where ( suffixes = suffixes , ** overrides ) def prefixes ( self , * prefixes , ** overrides ) : \"\"\" Sets the prefixes supported by the route \"\"\" return self . where ( prefixes = prefixes , ** overrides ) def where ( self , ** overrides ) : if \" urls \" in overrides : existing_urls = self . route . get ( \" urls \" , ()) use_urls = [] for url in ( ( overrides [ \" urls \" ], ) if isinstance ( overrides [ \" urls \" ], str ) else overrides [ \" urls \" ] ) : if url . startswith ( \" / \" ) or not existing_urls : use_urls . append ( url ) else : for existing in existing_urls : use_urls . append ( urljoin ( existing . rstrip ( \" / \" ) + \" / \" , url )) overrides [ \" urls \" ] = tuple ( use_urls ) return super () . where ( ** overrides )","title":"Module hug.routing"},{"location":"reference/hug/routing/#variables","text":"HTTP_METHODS","title":"Variables"},{"location":"reference/hug/routing/#classes","text":"","title":"Classes"},{"location":"reference/hug/routing/#clirouter","text":"class ( name = None , version = None , doc = None , ** kwargs ) The CLIRouter provides a chainable router that can be used to route a CLI command to a Python function View Source class CLIRouter ( Router ) : \"\"\" The CLIRouter provides a chainable router that can be used to route a CLI command to a Python function \"\"\" __slots__ = () def __init__ ( self , name = None , version = None , doc = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if name is not None : self . route [ \" name \" ] = name if version : self . route [ \" version \" ] = version if doc : self . route [ \" doc \" ] = doc def name ( self , name , ** overrides ) : \"\"\" Sets the name for the CLI interface \"\"\" return self . where ( name = name , ** overrides ) def version ( self , version , ** overrides ) : \"\"\" Sets the version for the CLI interface \"\"\" return self . where ( version = version , ** overrides ) def doc ( self , documentation , ** overrides ) : \"\"\" Sets the documentation for the CLI interface \"\"\" return self . where ( doc = documentation , ** overrides ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a Hug compatible function as a Command Line Interface \"\"\" hug . interface . CLI ( self . route , api_function ) return api_function","title":"CLIRouter"},{"location":"reference/hug/routing/#ancestors-in-mro","text":"hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#exceptionrouter","text":"class ( exceptions = ( < class ' Exception '>,), exclude = (), output = None , ** kwargs ) Provides a chainable router that can be used to route exceptions thrown during request handling View Source class ExceptionRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route exceptions thrown during request handling \"\"\" __slots__ = () def __init__ ( self , exceptions = ( Exception , ) , exclude = () , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) self . route [ \" exceptions \" ] = ( ( exceptions , ) if not isinstance ( exceptions , ( list , tuple )) else exceptions ) self . route [ \" exclude \" ] = ( exclude , ) if not isinstance ( exclude , ( list , tuple )) else exclude def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function , catch_exceptions = False ) for version in self . route . get ( \" versions \" , ( None , )) : for exception in self . route [ \" exceptions \" ]: api . http . add_exception_handler ( exception , interface , version ) return callable_method def _create_interface ( self , api , api_function , catch_exceptions = False ) : interface = hug . interface . ExceptionRaised ( self . route , api_function , catch_exceptions ) return ( interface , api_function )","title":"ExceptionRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_1","text":"hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#httprouter","text":"class ( versions =< built - in function any > , parse_body = False , parameters = None , defaults = None , status = None , response_headers = None , private = False , inputs = None , ** kwargs ) The HTTPRouter provides the base concept of a router from an HTTPRequest to a Python function View Source class HTTPRouter ( InternalValidation ) : \"\"\" The HTTPRouter provides the base concept of a router from an HTTPRequest to a Python function \"\"\" __slots__ = () def __init__ ( self , versions = any , parse_body = False , parameters = None , defaults = None , status = None , response_headers = None , private = False , inputs = None , ** kwargs ) : if defaults is None : defaults = {} super () . __init__ ( ** kwargs ) if versions is not any : self . route [ \" versions \" ] = ( ( versions , ) if isinstance ( versions , ( int , float , None . __class__ )) else versions ) self . route [ \" versions \" ] = tuple ( int ( version ) if version else version for version in self . route [ \" versions \" ] ) if parse_body : self . route [ \" parse_body \" ] = parse_body if parameters : self . route [ \" parameters \" ] = parameters if defaults : self . route [ \" defaults \" ] = defaults if status : self . route [ \" status \" ] = status if response_headers : self . route [ \" response_headers \" ] = response_headers if private : self . route [ \" private \" ] = private if inputs : self . route [ \" inputs \" ] = inputs def versions ( self , supported , ** overrides ) : \"\"\" Sets the versions that this route should be compatiable with \"\"\" return self . where ( versions = supported , ** overrides ) def parse_body ( self , automatic = True , ** overrides ) : \"\"\" Tells hug to automatically parse the input body if it matches a registered input format \"\"\" return self . where ( parse_body = automatic , ** overrides ) def set_status ( self , status , ** overrides ) : \"\"\" Sets the status that will be returned by default \"\"\" return self . where ( status = status , ** overrides ) def parameters ( self , parameters , ** overrides ) : \"\"\" Sets the custom parameters that will be used instead of those found introspecting the decorated function \"\"\" return self . where ( parameters = parameters , ** overrides ) def defaults ( self , defaults , ** overrides ) : \"\"\" Sets the custom defaults that will be used for custom parameters \"\"\" return self . where ( defaults = defaults , ** overrides ) def _create_interface ( self , api , api_function , catch_exceptions = True ) : interface = hug . interface . HTTP ( self . route , api_function , catch_exceptions ) return ( interface , api_function ) def response_headers ( self , headers , ** overrides ) : \"\"\" Sets the response headers automatically injected by the router \"\"\" return self . where ( response_headers = headers , ** overrides ) def add_response_headers ( self , headers , ** overrides ) : \"\"\" Adds the specified response headers while keeping existing ones in-tact \"\"\" response_headers = self . route . get ( \" response_headers \" , {} ) . copy () response_headers . update ( headers ) return self . where ( response_headers = response_headers , ** overrides ) def cache ( self , private = False , max_age = 31536000 , s_maxage = None , no_cache = False , no_store = False , must_revalidate = False , ** overrides ) : \"\"\" Convenience method for quickly adding cache header to route \"\"\" parts = ( \" private \" if private else \" public \" , \" max-age={0} \" . format ( max_age ) , \" s-maxage={0} \" . format ( s_maxage ) if s_maxage is not None else None , no_cache and \" no-cache \" , no_store and \" no-store \" , must_revalidate and \" must-revalidate \" , ) return self . add_response_headers ( { \" cache-control \" : \" , \" . join ( filter ( bool , parts )) }, ** overrides ) def allow_origins ( self , * origins , methods = None , max_age = None , credentials = None , headers = None , ** overrides ) : \"\"\" Convenience method for quickly allowing other resources to access this one \"\"\" response_headers = {} if origins : @ hug . response_middleware ( api = self . route . get ( \" api \" , None )) def process_data ( request , response , resource ) : if \" ORIGIN \" in request . headers : origin = request . headers [ \" ORIGIN \" ] if origin in origins : response . set_header ( \" Access-Control-Allow-Origin \" , origin ) else : response_headers [ \" Access-Control-Allow-Origin \" ] = \" * \" if methods : response_headers [ \" Access-Control-Allow-Methods \" ] = \" , \" . join ( methods ) if max_age : response_headers [ \" Access-Control-Max-Age \" ] = max_age if credentials : response_headers [ \" Access-Control-Allow-Credentials \" ] = str ( credentials ) . lower () if headers : response_headers [ \" Access-Control-Allow-Headers \" ] = headers return self . add_response_headers ( response_headers , ** overrides )","title":"HTTPRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_2","text":"hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#descendants","text":"hug.routing.NotFoundRouter hug.routing.SinkRouter hug.routing.ExceptionRouter hug.routing.URLRouter","title":"Descendants"},{"location":"reference/hug/routing/#internalvalidation","text":"class ( raise_on_invalid = False , on_invalid = None , output_invalid = None , ** kwargs ) Defines the base route for interfaces that define their own internal validation View Source class InternalValidation ( Router ) : \"\"\" Defines the base route for interfaces that define their own internal validation \"\"\" __slots__ = () def __init__ ( self , raise_on_invalid = False , on_invalid = None , output_invalid = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if raise_on_invalid : self . route [ \" raise_on_invalid \" ] = raise_on_invalid if on_invalid is not None : self . route [ \" on_invalid \" ] = on_invalid if output_invalid is not None : self . route [ \" output_invalid \" ] = output_invalid def raise_on_invalid ( self , setting = True , ** overrides ) : \"\"\" Sets the route to raise validation errors instead of catching them \"\"\" return self . where ( raise_on_invalid = setting , ** overrides ) def on_invalid ( self , function , ** overrides ) : \"\"\" Sets a function to use to transform data on validation errors. Defaults to the transform function if one is set to ensure no special handling occurs for invalid data set to ` False `. \"\"\" return self . where ( on_invalid = function , ** overrides ) def output_invalid ( self , output_handler , ** overrides ) : \"\"\" Sets an output handler to be used when handler validation fails. Defaults to the output formatter set globally for the route . \"\"\" return self . where ( output_invalid = output_handler , ** overrides )","title":"InternalValidation"},{"location":"reference/hug/routing/#ancestors-in-mro_3","text":"hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#descendants_1","text":"hug.routing.LocalRouter hug.routing.HTTPRouter","title":"Descendants"},{"location":"reference/hug/routing/#localrouter","text":"class ( directives = True , validate = True , version = None , ** kwargs ) The LocalRouter defines how interfaces should be handled when accessed locally from within Python code View Source class LocalRouter ( InternalValidation ) : \"\"\" The LocalRouter defines how interfaces should be handled when accessed locally from within Python code \"\"\" __slots__ = () def __init__ ( self , directives = True , validate = True , version = None , ** kwargs ) : super () . __init__ ( ** kwargs ) if version is not None : self . route [ \" version \" ] = version if not directives : self . route [ \" skip_directives \" ] = True if not validate : self . route [ \" skip_validation \" ] = True def directives ( self , use = True , ** kwargs ) : return self . where ( directives = use ) def validate ( self , enforce = True , ** kwargs ) : return self . where ( validate = enforce ) def version ( self , supported , ** kwargs ) : return self . where ( version = supported ) def __call__ ( self , api_function ) : \"\"\" Enables exposing a hug compatible function locally \"\"\" return hug . interface . Local ( self . route , api_function )","title":"LocalRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_4","text":"hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#notfoundrouter","text":"class ( output = None , versions =< built - in function any > , status = '404 Not Found' , ** kwargs ) Provides a chainable router that can be used to route 404'd request to a Python function View Source class NotFoundRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route 404'd request to a Python function \"\"\" __slots__ = () def __init__ ( self , output = None , versions = any , status = falcon . HTTP_NOT_FOUND , ** kwargs ) : super () . __init__ ( output = output , versions = versions , status = status , ** kwargs ) def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for version in self . route . get ( \" versions \" , ( None , )) : api . http . set_not_found_handler ( interface , version ) return callable_method","title":"NotFoundRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_5","text":"hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#router","text":"class ( transform = None , output = None , validate = None , api = None , requires = (), map_params = None , args = None , ** kwargs ) The base chainable router object View Source class Router ( object ) : \"\"\" The base chainable router object \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , transform = None , output = None , validate = None , api = None , requires = () , map_params = None , args = None , ** kwargs ) : self . route = {} if transform is not None : self . route [ \" transform \" ] = transform if output : self . route [ \" output \" ] = output if validate : self . route [ \" validate \" ] = validate if api : self . route [ \" api \" ] = api if requires : self . route [ \" requires \" ] = ( ( requires , ) if not isinstance ( requires , ( tuple , list )) else requires ) if map_params : self . route [ \" map_params \" ] = map_params if args : self . route [ \" args \" ] = args def output ( self , formatter , ** overrides ) : \"\"\" Sets the output formatter that should be used to render this route \"\"\" return self . where ( output = formatter , ** overrides ) def transform ( self , function , ** overrides ) : \"\"\" Sets the function that should be used to transform the returned Python structure into something serializable by specified output format \"\"\" return self . where ( transform = function , ** overrides ) def validate ( self , validation_function , ** overrides ) : \"\"\" Sets the secondary validation fucntion to use for this handler \"\"\" return self . where ( validate = validation_function , ** overrides ) def api ( self , api , ** overrides ) : \"\"\" Sets the API that should contain this route \"\"\" return self . where ( api = api , ** overrides ) def requires ( self , requirements , ** overrides ) : \"\"\" Adds additional requirements to the specified route \"\"\" return self . where ( requires = tuple ( self . route . get ( \" requires \" , ())) + tuple ( requirements ) , ** overrides ) def doesnt_require ( self , requirements , ** overrides ) : \"\"\" Removes individual requirements while keeping all other defined ones within a route \"\"\" return self . where ( requires = tuple ( set ( self . route . get ( \" requires \" , ())) . difference ( requirements if type ( requirements ) in ( list , tuple ) else ( requirements , ) ) ) ) def map_params ( self , ** map_params ) : \"\"\" Map interface specific params to an internal name representation \"\"\" return self . where ( map_params = map_params ) def where ( self , ** overrides ) : \"\"\" Creates a new route, based on the current route, with the specified overrided values \"\"\" route_data = self . route . copy () route_data . update ( overrides ) return self . __class__ ( ** route_data )","title":"Router"},{"location":"reference/hug/routing/#descendants_2","text":"hug.routing.CLIRouter hug.routing.InternalValidation","title":"Descendants"},{"location":"reference/hug/routing/#sinkrouter","text":"class ( urls = None , output = None , ** kwargs ) Provides a chainable router that can be used to route all routes pass a certain base URL (essentially route/*) View Source class SinkRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route all routes pass a certain base URL (essentially route/*) \"\"\" __slots__ = () def __init__ ( self , urls = None , output = None , ** kwargs ) : super () . __init__ ( output = output , ** kwargs ) if urls : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) ( interface , callable_method ) = self . _create_interface ( api , api_function ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : api . http . add_sink ( interface , base_url ) return callable_method","title":"SinkRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_6","text":"hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#descendants_3","text":"hug.routing.StaticRouter","title":"Descendants"},{"location":"reference/hug/routing/#staticrouter","text":"class ( urls = None , output =< function file at 0x7f0676c9c048 > , cache = False , ** kwargs ) Provides a chainable router that can be used to return static files automatically from a set of directories View Source class StaticRouter ( SinkRouter ) : \"\"\" Provides a chainable router that can be used to return static files automatically from a set of directories \"\"\" __slots__ = ( \" route \" , ) def __init__ ( self , urls = None , output = hug . output_format . file , cache = False , ** kwargs ) : super () . __init__ ( urls = urls , output = output , ** kwargs ) if cache is True : self . cache () elif cache is not False : self . cache ( ** cache ) def __call__ ( self , api_function ) : directories = [] for directory in api_function () : path = os . path . abspath ( directory ) directories . append ( path ) api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : def read_file ( request = None , path = \"\" ) : filename = path . lstrip ( \" / \" ) for directory in directories : path = os . path . abspath ( os . path . join ( directory , filename )) if not path . startswith ( directory ) : hug . redirect . not_found () if os . path . isdir ( path ) : new_path = os . path . join ( path , \" index.html \" ) if os . path . exists ( new_path ) and os . path . isfile ( new_path ) : path = new_path if os . path . exists ( path ) and os . path . isfile ( path ) : return path hug . redirect . not_found () api . http . add_sink ( self . _create_interface ( api , read_file ) [ 0 ], base_url ) return api_function","title":"StaticRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_7","text":"hug.routing.SinkRouter hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#urlrouter","text":"class ( urls = None , accept = ( 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'PATCH' , 'POST' , 'PUT' , 'TRACE' ), output = None , examples = (), versions =< built - in function any > , suffixes = (), prefixes = (), response_headers = None , parse_body = True , ** kwargs ) Provides a chainable router that can be used to route a URL to a Python function View Source class URLRouter ( HTTPRouter ) : \"\"\" Provides a chainable router that can be used to route a URL to a Python function \"\"\" __slots__ = () def __init__ ( self , urls = None , accept = HTTP_METHODS , output = None , examples = () , versions = any , suffixes = () , prefixes = () , response_headers = None , parse_body = True , ** kwargs ) : super () . __init__ ( output = output , versions = versions , parse_body = parse_body , response_headers = response_headers , ** kwargs ) if urls is not None : self . route [ \" urls \" ] = ( urls , ) if isinstance ( urls , str ) else urls if accept : self . route [ \" accept \" ] = ( accept , ) if isinstance ( accept , str ) else accept if examples : self . route [ \" examples \" ] = ( examples , ) if isinstance ( examples , str ) else examples if suffixes : self . route [ \" suffixes \" ] = ( suffixes , ) if isinstance ( suffixes , str ) else suffixes if prefixes : self . route [ \" prefixes \" ] = ( prefixes , ) if isinstance ( prefixes , str ) else prefixes def __call__ ( self , api_function ) : api = self . route . get ( \" api \" , hug . api . from_object ( api_function )) api . http . routes . setdefault ( api . http . base_url , OrderedDict ()) ( interface , callable_method ) = self . _create_interface ( api , api_function ) use_examples = self . route . get ( \" examples \" , ()) if not interface . required and not use_examples : use_examples = ( True , ) for base_url in self . route . get ( \" urls \" , ( \" /{0} \" . format ( api_function . __name__ ) , )) : expose = [ base_url ] for suffix in self . route . get ( \" suffixes \" , ()) : if suffix . startswith ( \" / \" ) : expose . append ( os . path . join ( base_url , suffix . lstrip ( \" / \" ))) else : expose . append ( base_url + suffix ) for prefix in self . route . get ( \" prefixes \" , ()) : expose . append ( prefix + base_url ) for url in expose : handlers = api . http . routes [ api . http . base_url ]. setdefault ( url , {} ) for method in self . route . get ( \" accept \" , ()) : version_mapping = handlers . setdefault ( method . upper () , {} ) for version in self . route . get ( \" versions \" , ( None , )) : version_mapping [ version ] = interface api . http . versioned . setdefault ( version , {} ) [ callable_method . __name__ ] = callable_method interface . examples = use_examples return callable_method def urls ( self , * urls , ** overrides ) : \"\"\" Sets the URLs that will map to this API call \"\"\" return self . where ( urls = urls , ** overrides ) def accept ( self , * accept , ** overrides ) : \"\"\" Sets a list of HTTP methods this router should accept \"\"\" return self . where ( accept = accept , ** overrides ) def get ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to a GET \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" GET \" , ** overrides ) def delete ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to DELETE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" DELETE \" , ** overrides ) def post ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to POST \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" POST \" , ** overrides ) def put ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PUT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PUT \" , ** overrides ) def trace ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to TRACE \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" TRACE \" , ** overrides ) def patch ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to PATCH \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" PATCH \" , ** overrides ) def options ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to OPTIONS \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" OPTIONS \" , ** overrides ) def head ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to HEAD \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" HEAD \" , ** overrides ) def connect ( self , urls = None , ** overrides ) : \"\"\" Sets the acceptable HTTP method to CONNECT \"\"\" if urls is not None : overrides [ \" urls \" ] = urls return self . where ( accept = \" CONNECT \" , ** overrides ) def call ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def http ( self , ** overrides ) : \"\"\" Sets the acceptable HTTP method to all known \"\"\" return self . where ( accept = HTTP_METHODS , ** overrides ) def get_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and GET methods \"\"\" return self . where ( accept = ( \" GET \" , \" POST \" ) , ** overrides ) def put_post ( self , ** overrides ) : \"\"\" Exposes a Python method externally under both the HTTP POST and PUT methods \"\"\" return self . where ( accept = ( \" PUT \" , \" POST \" ) , ** overrides ) def examples ( self , * examples , ** overrides ) : \"\"\" Sets the examples that the route should use \"\"\" return self . where ( examples = examples , ** overrides ) def suffixes ( self , * suffixes , ** overrides ) : \"\"\" Sets the suffixes supported by the route \"\"\" return self . where ( suffixes = suffixes , ** overrides ) def prefixes ( self , * prefixes , ** overrides ) : \"\"\" Sets the prefixes supported by the route \"\"\" return self . where ( prefixes = prefixes , ** overrides ) def where ( self , ** overrides ) : if \" urls \" in overrides : existing_urls = self . route . get ( \" urls \" , ()) use_urls = [] for url in ( ( overrides [ \" urls \" ], ) if isinstance ( overrides [ \" urls \" ], str ) else overrides [ \" urls \" ] ) : if url . startswith ( \" / \" ) or not existing_urls : use_urls . append ( url ) else : for existing in existing_urls : use_urls . append ( urljoin ( existing . rstrip ( \" / \" ) + \" / \" , url )) overrides [ \" urls \" ] = tuple ( use_urls ) return super () . where ( ** overrides )","title":"URLRouter"},{"location":"reference/hug/routing/#ancestors-in-mro_8","text":"hug.routing.HTTPRouter hug.routing.InternalValidation hug.routing.Router","title":"Ancestors (in MRO)"},{"location":"reference/hug/routing/#descendants_4","text":"hug.route.Object","title":"Descendants"},{"location":"reference/hug/store/","text":"Module hug.store hug/store.py. A collecton of native stores which can be used with, among others, the session middleware. Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/store.py. A collecton of native stores which can be used with , among others , the session middleware . Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from hug . exceptions import StoreKeyNotFound class InMemoryStore : \"\"\" Naive store class which can be used for the session middleware and unit tests . It is not thread - safe and no data will survive the lifecycle of the hug process . Regard this as a blueprint for more useful and probably more complex store implementations , for example stores which make use of databases like Redis , PostgreSQL or others . \"\"\" def __init__ ( self ) : self . _data = {} def get ( self , key ) : \"\"\" Get data for given store key. Raise hug.exceptions.StoreKeyNotFound if key does not exist. \"\"\" try : data = self . _data [ key ] except KeyError : raise StoreKeyNotFound ( key ) return data def exists ( self , key ) : \"\"\" Return whether key exists or not. \"\"\" return key in self . _data def set ( self , key , data ) : \"\"\" Set data object for given store key. \"\"\" self . _data [ key ] = data def delete ( self , key ) : \"\"\" Delete data for given store key. \"\"\" if key in self . _data : del self . _data [ key ] Classes InMemoryStore class ( ) Naive store class which can be used for the session middleware and unit tests. It is not thread-safe and no data will survive the lifecycle of the hug process. Regard this as a blueprint for more useful and probably more complex store implementations, for example stores which make use of databases like Redis, PostgreSQL or others. View Source class InMemoryStore : \"\"\" Naive store class which can be used for the session middleware and unit tests . It is not thread - safe and no data will survive the lifecycle of the hug process . Regard this as a blueprint for more useful and probably more complex store implementations , for example stores which make use of databases like Redis , PostgreSQL or others . \"\"\" def __init__ ( self ) : self . _data = {} def get ( self , key ) : \"\"\" Get data for given store key. Raise hug.exceptions.StoreKeyNotFound if key does not exist. \"\"\" try : data = self . _data [ key ] except KeyError : raise StoreKeyNotFound ( key ) return data def exists ( self , key ) : \"\"\" Return whether key exists or not. \"\"\" return key in self . _data def set ( self , key , data ) : \"\"\" Set data object for given store key. \"\"\" self . _data [ key ] = data def delete ( self , key ) : \"\"\" Delete data for given store key. \"\"\" if key in self . _data : del self . _data [ key ]","title":"Store"},{"location":"reference/hug/store/#module-hugstore","text":"hug/store.py. A collecton of native stores which can be used with, among others, the session middleware. Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/store.py. A collecton of native stores which can be used with , among others , the session middleware . Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from hug . exceptions import StoreKeyNotFound class InMemoryStore : \"\"\" Naive store class which can be used for the session middleware and unit tests . It is not thread - safe and no data will survive the lifecycle of the hug process . Regard this as a blueprint for more useful and probably more complex store implementations , for example stores which make use of databases like Redis , PostgreSQL or others . \"\"\" def __init__ ( self ) : self . _data = {} def get ( self , key ) : \"\"\" Get data for given store key. Raise hug.exceptions.StoreKeyNotFound if key does not exist. \"\"\" try : data = self . _data [ key ] except KeyError : raise StoreKeyNotFound ( key ) return data def exists ( self , key ) : \"\"\" Return whether key exists or not. \"\"\" return key in self . _data def set ( self , key , data ) : \"\"\" Set data object for given store key. \"\"\" self . _data [ key ] = data def delete ( self , key ) : \"\"\" Delete data for given store key. \"\"\" if key in self . _data : del self . _data [ key ]","title":"Module hug.store"},{"location":"reference/hug/store/#classes","text":"","title":"Classes"},{"location":"reference/hug/store/#inmemorystore","text":"class ( ) Naive store class which can be used for the session middleware and unit tests. It is not thread-safe and no data will survive the lifecycle of the hug process. Regard this as a blueprint for more useful and probably more complex store implementations, for example stores which make use of databases like Redis, PostgreSQL or others. View Source class InMemoryStore : \"\"\" Naive store class which can be used for the session middleware and unit tests . It is not thread - safe and no data will survive the lifecycle of the hug process . Regard this as a blueprint for more useful and probably more complex store implementations , for example stores which make use of databases like Redis , PostgreSQL or others . \"\"\" def __init__ ( self ) : self . _data = {} def get ( self , key ) : \"\"\" Get data for given store key. Raise hug.exceptions.StoreKeyNotFound if key does not exist. \"\"\" try : data = self . _data [ key ] except KeyError : raise StoreKeyNotFound ( key ) return data def exists ( self , key ) : \"\"\" Return whether key exists or not. \"\"\" return key in self . _data def set ( self , key , data ) : \"\"\" Set data object for given store key. \"\"\" self . _data [ key ] = data def delete ( self , key ) : \"\"\" Delete data for given store key. \"\"\" if key in self . _data : del self . _data [ key ]","title":"InMemoryStore"},{"location":"reference/hug/test/","text":"Module hug.test hug/test.py. Defines utility function that aid in the round-trip testing of Hug APIs Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/test.py. Defines utility function that aid in the round - trip testing of Hug APIs Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import ast import sys from functools import partial from io import BytesIO from unittest import mock from urllib . parse import urlencode from falcon import HTTP_METHODS from falcon . testing import DEFAULT_HOST , StartResponseMock , create_environ from hug import output_format from hug . api import API from hug . json_module import json def _internal_result ( raw_response ) : try : return raw_response [ 0 ]. decode ( \" utf8 \" ) except TypeError : data = BytesIO () for chunk in raw_response : data . write ( chunk ) data = data . getvalue () try : return data . decode ( \" utf8 \" ) except UnicodeDecodeError : # pragma : no cover return data except ( UnicodeDecodeError , AttributeError ) : return raw_response [ 0 ] def call ( method , api_or_module , url , body = \"\" , headers = None , params = None , query_string = \"\" , scheme = \" http \" , host = DEFAULT_HOST , ** kwargs ) : \"\"\" Simulates a round-trip call against the given API / URL \"\"\" api = API ( api_or_module ) . http . server () response = StartResponseMock () headers = {} if headers is None else headers if not isinstance ( body , str ) and \" json \" in headers . get ( \" content-type \" , \" application/json \" ) : body = output_format . json ( body ) headers . setdefault ( \" content-type \" , \" application/json \" ) params = params if params else {} params . update ( kwargs ) if params : query_string = \" {}{}{} \" . format ( query_string , \" & \" if query_string else \"\" , urlencode ( params , True ) ) result = api ( create_environ ( path = url , method = method , headers = headers , query_string = query_string , body = body , scheme = scheme , host = host , ) , response , ) if result : response . data = _internal_result ( result ) response . content_type = response . headers_dict [ \" content-type \" ] if \" application/json \" in response . content_type : response . data = json . loads ( response . data ) return response for method in HTTP_METHODS : tester = partial ( call , method ) tester . __doc__ = \"\"\" Simulates a round-trip HTTP {0} against the given API / URL \"\"\" . format ( method . upper () ) globals () [ method . lower () ] = tester def cli ( method , * args , api = None , module = None , ** arguments ) : \"\"\" Simulates testing a hug cli method from the command line \"\"\" collect_output = arguments . pop ( \" collect_output \" , True ) if api and module : raise ValueError ( \" Please specify an API OR a Module that contains the API, not both \" ) elif api or module : method = API ( api or module ) . cli . commands [ method ]. interface . _function command_args = [ method . __name__ ] + list ( args ) for name , values in arguments . items () : if not isinstance ( values , ( tuple , list )) : values = ( values , ) for value in values : command_args . append ( \" --{0} \" . format ( name )) if not value in ( True , False ) : command_args . append ( \" {0} \" . format ( value )) old_sys_argv = sys . argv sys . argv = [ str ( part ) for part in command_args ] old_outputs = method . interface . cli . outputs if collect_output : method . interface . cli . outputs = lambda data : to_return . append ( old_outputs ( data )) to_return = [] try : method . interface . cli () except Exception as e : to_return = ( e , ) method . interface . cli . outputs = old_outputs sys . argv = old_sys_argv if to_return : result = _internal_result ( to_return ) try : result = json . loads ( result ) except Exception : try : result = ast . literal_eval ( result ) except Exception : pass return result Variables DEFAULT_HOST HTTP_METHODS connect delete get head method options patch post put tester trace Functions call def ( method , api_or_module , url , body = '' , headers = None , params = None , query_string = '' , scheme = 'http' , host = 'falconframework.org' , ** kwargs ) Simulates a round-trip call against the given API / URL View Source def call ( method , api_or_module , url , body = \"\" , headers = None , params = None , query_string = \"\" , scheme = \" http \" , host = DEFAULT_HOST , ** kwargs ) : \"\"\" Simulates a round-trip call against the given API / URL \"\"\" api = API ( api_or_module ) . http . server () response = StartResponseMock () headers = {} if headers is None else headers if not isinstance ( body , str ) and \" json \" in headers . get ( \" content-type \" , \" application/json \" ) : body = output_format . json ( body ) headers . setdefault ( \" content-type \" , \" application/json \" ) params = params if params else {} params . update ( kwargs ) if params : query_string = \" {}{}{} \" . format ( query_string , \" & \" if query_string else \"\" , urlencode ( params , True ) ) result = api ( create_environ ( path = url , method = method , headers = headers , query_string = query_string , body = body , scheme = scheme , host = host , ) , response , ) if result : response . data = _internal_result ( result ) response . content_type = response . headers_dict [ \" content-type \" ] if \" application/json \" in response . content_type : response . data = json . loads ( response . data ) return response cli def ( method , * args , api = None , module = None , ** arguments ) Simulates testing a hug cli method from the command line View Source def cli ( method , * args , api = None , module = None , ** arguments ) : \"\"\" Simulates testing a hug cli method from the command line \"\"\" collect_output = arguments . pop ( \" collect_output \" , True ) if api and module : raise ValueError ( \" Please specify an API OR a Module that contains the API, not both \" ) elif api or module : method = API ( api or module ) . cli . commands [ method ]. interface . _function command_args = [ method . __name__ ] + list ( args ) for name , values in arguments . items () : if not isinstance ( values , ( tuple , list )) : values = ( values , ) for value in values : command_args . append ( \" --{0} \" . format ( name )) if not value in ( True , False ) : command_args . append ( \" {0} \" . format ( value )) old_sys_argv = sys . argv sys . argv = [ str ( part ) for part in command_args ] old_outputs = method . interface . cli . outputs if collect_output : method . interface . cli . outputs = lambda data : to_return . append ( old_outputs ( data )) to_return = [] try : method . interface . cli () except Exception as e : to_return = ( e , ) method . interface . cli . outputs = old_outputs sys . argv = old_sys_argv if to_return : result = _internal_result ( to_return ) try : result = json . loads ( result ) except Exception : try : result = ast . literal_eval ( result ) except Exception : pass return result","title":"Test"},{"location":"reference/hug/test/#module-hugtest","text":"hug/test.py. Defines utility function that aid in the round-trip testing of Hug APIs Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/test.py. Defines utility function that aid in the round - trip testing of Hug APIs Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import ast import sys from functools import partial from io import BytesIO from unittest import mock from urllib . parse import urlencode from falcon import HTTP_METHODS from falcon . testing import DEFAULT_HOST , StartResponseMock , create_environ from hug import output_format from hug . api import API from hug . json_module import json def _internal_result ( raw_response ) : try : return raw_response [ 0 ]. decode ( \" utf8 \" ) except TypeError : data = BytesIO () for chunk in raw_response : data . write ( chunk ) data = data . getvalue () try : return data . decode ( \" utf8 \" ) except UnicodeDecodeError : # pragma : no cover return data except ( UnicodeDecodeError , AttributeError ) : return raw_response [ 0 ] def call ( method , api_or_module , url , body = \"\" , headers = None , params = None , query_string = \"\" , scheme = \" http \" , host = DEFAULT_HOST , ** kwargs ) : \"\"\" Simulates a round-trip call against the given API / URL \"\"\" api = API ( api_or_module ) . http . server () response = StartResponseMock () headers = {} if headers is None else headers if not isinstance ( body , str ) and \" json \" in headers . get ( \" content-type \" , \" application/json \" ) : body = output_format . json ( body ) headers . setdefault ( \" content-type \" , \" application/json \" ) params = params if params else {} params . update ( kwargs ) if params : query_string = \" {}{}{} \" . format ( query_string , \" & \" if query_string else \"\" , urlencode ( params , True ) ) result = api ( create_environ ( path = url , method = method , headers = headers , query_string = query_string , body = body , scheme = scheme , host = host , ) , response , ) if result : response . data = _internal_result ( result ) response . content_type = response . headers_dict [ \" content-type \" ] if \" application/json \" in response . content_type : response . data = json . loads ( response . data ) return response for method in HTTP_METHODS : tester = partial ( call , method ) tester . __doc__ = \"\"\" Simulates a round-trip HTTP {0} against the given API / URL \"\"\" . format ( method . upper () ) globals () [ method . lower () ] = tester def cli ( method , * args , api = None , module = None , ** arguments ) : \"\"\" Simulates testing a hug cli method from the command line \"\"\" collect_output = arguments . pop ( \" collect_output \" , True ) if api and module : raise ValueError ( \" Please specify an API OR a Module that contains the API, not both \" ) elif api or module : method = API ( api or module ) . cli . commands [ method ]. interface . _function command_args = [ method . __name__ ] + list ( args ) for name , values in arguments . items () : if not isinstance ( values , ( tuple , list )) : values = ( values , ) for value in values : command_args . append ( \" --{0} \" . format ( name )) if not value in ( True , False ) : command_args . append ( \" {0} \" . format ( value )) old_sys_argv = sys . argv sys . argv = [ str ( part ) for part in command_args ] old_outputs = method . interface . cli . outputs if collect_output : method . interface . cli . outputs = lambda data : to_return . append ( old_outputs ( data )) to_return = [] try : method . interface . cli () except Exception as e : to_return = ( e , ) method . interface . cli . outputs = old_outputs sys . argv = old_sys_argv if to_return : result = _internal_result ( to_return ) try : result = json . loads ( result ) except Exception : try : result = ast . literal_eval ( result ) except Exception : pass return result","title":"Module hug.test"},{"location":"reference/hug/test/#variables","text":"DEFAULT_HOST HTTP_METHODS connect delete get head method options patch post put tester trace","title":"Variables"},{"location":"reference/hug/test/#functions","text":"","title":"Functions"},{"location":"reference/hug/test/#call","text":"def ( method , api_or_module , url , body = '' , headers = None , params = None , query_string = '' , scheme = 'http' , host = 'falconframework.org' , ** kwargs ) Simulates a round-trip call against the given API / URL View Source def call ( method , api_or_module , url , body = \"\" , headers = None , params = None , query_string = \"\" , scheme = \" http \" , host = DEFAULT_HOST , ** kwargs ) : \"\"\" Simulates a round-trip call against the given API / URL \"\"\" api = API ( api_or_module ) . http . server () response = StartResponseMock () headers = {} if headers is None else headers if not isinstance ( body , str ) and \" json \" in headers . get ( \" content-type \" , \" application/json \" ) : body = output_format . json ( body ) headers . setdefault ( \" content-type \" , \" application/json \" ) params = params if params else {} params . update ( kwargs ) if params : query_string = \" {}{}{} \" . format ( query_string , \" & \" if query_string else \"\" , urlencode ( params , True ) ) result = api ( create_environ ( path = url , method = method , headers = headers , query_string = query_string , body = body , scheme = scheme , host = host , ) , response , ) if result : response . data = _internal_result ( result ) response . content_type = response . headers_dict [ \" content-type \" ] if \" application/json \" in response . content_type : response . data = json . loads ( response . data ) return response","title":"call"},{"location":"reference/hug/test/#cli","text":"def ( method , * args , api = None , module = None , ** arguments ) Simulates testing a hug cli method from the command line View Source def cli ( method , * args , api = None , module = None , ** arguments ) : \"\"\" Simulates testing a hug cli method from the command line \"\"\" collect_output = arguments . pop ( \" collect_output \" , True ) if api and module : raise ValueError ( \" Please specify an API OR a Module that contains the API, not both \" ) elif api or module : method = API ( api or module ) . cli . commands [ method ]. interface . _function command_args = [ method . __name__ ] + list ( args ) for name , values in arguments . items () : if not isinstance ( values , ( tuple , list )) : values = ( values , ) for value in values : command_args . append ( \" --{0} \" . format ( name )) if not value in ( True , False ) : command_args . append ( \" {0} \" . format ( value )) old_sys_argv = sys . argv sys . argv = [ str ( part ) for part in command_args ] old_outputs = method . interface . cli . outputs if collect_output : method . interface . cli . outputs = lambda data : to_return . append ( old_outputs ( data )) to_return = [] try : method . interface . cli () except Exception as e : to_return = ( e , ) method . interface . cli . outputs = old_outputs sys . argv = old_sys_argv if to_return : result = _internal_result ( to_return ) try : result = json . loads ( result ) except Exception : try : result = ast . literal_eval ( result ) except Exception : pass return result","title":"cli"},{"location":"reference/hug/this/","text":"Module hug.this hug/this.py. The Zen of Hug Copyright (C) 2019 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/this.py. The Zen of Hug Copyright ( C ) 2019 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" ZEN_OF_HUG = \"\"\" Simple Things should be easy , complex things should be possible . Complex things done often should be made simple . Magic should be avoided . Magic isn ' t magic as soon as its mechanics are universally understood. Wrong documentation is worse than no documentation . Everything should be documented . All code should be tested . All tests should be meaningful . Consistency is more important than perfection . It ' s okay to break consistency for practicality. Clarity is more important than performance . If we do our job right , there shouldn ' t need to be a choice. Interfaces are one honking great idea -- let ' s do more of those! \"\"\" print ( ZEN_OF_HUG ) Variables ZEN_OF_HUG","title":"This"},{"location":"reference/hug/this/#module-hugthis","text":"hug/this.py. The Zen of Hug Copyright (C) 2019 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/this.py. The Zen of Hug Copyright ( C ) 2019 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" ZEN_OF_HUG = \"\"\" Simple Things should be easy , complex things should be possible . Complex things done often should be made simple . Magic should be avoided . Magic isn ' t magic as soon as its mechanics are universally understood. Wrong documentation is worse than no documentation . Everything should be documented . All code should be tested . All tests should be meaningful . Consistency is more important than perfection . It ' s okay to break consistency for practicality. Clarity is more important than performance . If we do our job right , there shouldn ' t need to be a choice. Interfaces are one honking great idea -- let ' s do more of those! \"\"\" print ( ZEN_OF_HUG )","title":"Module hug.this"},{"location":"reference/hug/this/#variables","text":"ZEN_OF_HUG","title":"Variables"},{"location":"reference/hug/transform/","text":"Module hug.transform hug/transform.py Defines Hug's built-in output transforming functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/transform.py Defines Hug ' s built-in output transforming functions Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from hug . decorators import auto_kwargs def content_type ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the content type passed in. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [content-type] ' : transformation_action , ... } \"\"\" transformers = { content_type : auto_kwargs ( transformer ) if transformer else transformer for content_type , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : transformer = transformers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not transformer : return data return transformer ( data ) return transform def suffix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the suffix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [suffix] ' : transformation_action , ... } \"\"\" transformers = { suffix : auto_kwargs ( transformer ) if transformer else transformer for suffix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : path = request . path transformer = default for suffix_test , suffix_transformer in transformers . items () : if path . endswith ( suffix_test ) : transformer = suffix_transformer break return transformer ( data ) if transformer else data return transform def prefix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the prefix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [prefix] ' : transformation_action , ... } \"\"\" transformers = { prefix : auto_kwargs ( transformer ) if transformer else transformer for prefix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request = None , response = None ) : path = request . path transformer = default for prefix_test , prefix_transformer in transformers . items () : if path . startswith ( prefix_test ) : transformer = prefix_transformer break return transformer ( data ) if transformer else data return transform def all ( * transformers ) : \"\"\" Returns the results of applying all passed in transformers to data should pass in list of transformers [ transformer_1 , transformer_2 ...] \"\"\" transformers = tuple ( auto_kwargs ( transformer ) for transformer in transformers ) def transform ( data , request = None , response = None ) : for transformer in transformers : data = transformer ( data , request = request , response = response ) return data return transform Functions all def ( * transformers ) Returns the results of applying all passed in transformers to data should pass in list of transformers [ transformer_1 , transformer_2 ...] View Source def all ( * transformers ) : \"\"\" Returns the results of applying all passed in transformers to data should pass in list of transformers [ transformer_1 , transformer_2 ...] \"\"\" transformers = tuple ( auto_kwargs ( transformer ) for transformer in transformers ) def transform ( data , request = None , response = None ) : for transformer in transformers : data = transformer ( data , request = request , response = response ) return data return transform content_type def ( transformers , default = None ) Returns a different transformer depending on the content type passed in. If none match and no default is given no transformation takes place. should pass in a dict with the following format: { '[content-type]' : transformation_action , ... } View Source def content_type ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the content type passed in. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [content-type] ' : transformation_action , ... } \"\"\" transformers = { content_type : auto_kwargs ( transformer ) if transformer else transformer for content_type , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : transformer = transformers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not transformer : return data return transformer ( data ) return transform prefix def ( transformers , default = None ) Returns a different transformer depending on the prefix at the end of the requested URL. If none match and no default is given no transformation takes place. should pass in a dict with the following format: { '[prefix]' : transformation_action , ... } View Source def prefix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the prefix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [prefix] ' : transformation_action , ... } \"\"\" transformers = { prefix : auto_kwargs ( transformer ) if transformer else transformer for prefix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request = None , response = None ) : path = request . path transformer = default for prefix_test , prefix_transformer in transformers . items () : if path . startswith ( prefix_test ) : transformer = prefix_transformer break return transformer ( data ) if transformer else data return transform suffix def ( transformers , default = None ) Returns a different transformer depending on the suffix at the end of the requested URL. If none match and no default is given no transformation takes place. should pass in a dict with the following format: { '[suffix]' : transformation_action , ... } View Source def suffix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the suffix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [suffix] ' : transformation_action , ... } \"\"\" transformers = { suffix : auto_kwargs ( transformer ) if transformer else transformer for suffix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : path = request . path transformer = default for suffix_test , suffix_transformer in transformers . items () : if path . endswith ( suffix_test ) : transformer = suffix_transformer break return transformer ( data ) if transformer else data return transform","title":"Transform"},{"location":"reference/hug/transform/#module-hugtransform","text":"hug/transform.py Defines Hug's built-in output transforming functions Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/transform.py Defines Hug ' s built-in output transforming functions Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import from hug . decorators import auto_kwargs def content_type ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the content type passed in. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [content-type] ' : transformation_action , ... } \"\"\" transformers = { content_type : auto_kwargs ( transformer ) if transformer else transformer for content_type , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : transformer = transformers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not transformer : return data return transformer ( data ) return transform def suffix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the suffix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [suffix] ' : transformation_action , ... } \"\"\" transformers = { suffix : auto_kwargs ( transformer ) if transformer else transformer for suffix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : path = request . path transformer = default for suffix_test , suffix_transformer in transformers . items () : if path . endswith ( suffix_test ) : transformer = suffix_transformer break return transformer ( data ) if transformer else data return transform def prefix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the prefix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [prefix] ' : transformation_action , ... } \"\"\" transformers = { prefix : auto_kwargs ( transformer ) if transformer else transformer for prefix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request = None , response = None ) : path = request . path transformer = default for prefix_test , prefix_transformer in transformers . items () : if path . startswith ( prefix_test ) : transformer = prefix_transformer break return transformer ( data ) if transformer else data return transform def all ( * transformers ) : \"\"\" Returns the results of applying all passed in transformers to data should pass in list of transformers [ transformer_1 , transformer_2 ...] \"\"\" transformers = tuple ( auto_kwargs ( transformer ) for transformer in transformers ) def transform ( data , request = None , response = None ) : for transformer in transformers : data = transformer ( data , request = request , response = response ) return data return transform","title":"Module hug.transform"},{"location":"reference/hug/transform/#functions","text":"","title":"Functions"},{"location":"reference/hug/transform/#all","text":"def ( * transformers ) Returns the results of applying all passed in transformers to data should pass in list of transformers [ transformer_1 , transformer_2 ...] View Source def all ( * transformers ) : \"\"\" Returns the results of applying all passed in transformers to data should pass in list of transformers [ transformer_1 , transformer_2 ...] \"\"\" transformers = tuple ( auto_kwargs ( transformer ) for transformer in transformers ) def transform ( data , request = None , response = None ) : for transformer in transformers : data = transformer ( data , request = request , response = response ) return data return transform","title":"all"},{"location":"reference/hug/transform/#content_type","text":"def ( transformers , default = None ) Returns a different transformer depending on the content type passed in. If none match and no default is given no transformation takes place. should pass in a dict with the following format: { '[content-type]' : transformation_action , ... } View Source def content_type ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the content type passed in. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [content-type] ' : transformation_action , ... } \"\"\" transformers = { content_type : auto_kwargs ( transformer ) if transformer else transformer for content_type , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : transformer = transformers . get ( request . content_type . split ( \" ; \" ) [ 0 ], default ) if not transformer : return data return transformer ( data ) return transform","title":"content_type"},{"location":"reference/hug/transform/#prefix","text":"def ( transformers , default = None ) Returns a different transformer depending on the prefix at the end of the requested URL. If none match and no default is given no transformation takes place. should pass in a dict with the following format: { '[prefix]' : transformation_action , ... } View Source def prefix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the prefix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [prefix] ' : transformation_action , ... } \"\"\" transformers = { prefix : auto_kwargs ( transformer ) if transformer else transformer for prefix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request = None , response = None ) : path = request . path transformer = default for prefix_test , prefix_transformer in transformers . items () : if path . startswith ( prefix_test ) : transformer = prefix_transformer break return transformer ( data ) if transformer else data return transform","title":"prefix"},{"location":"reference/hug/transform/#suffix","text":"def ( transformers , default = None ) Returns a different transformer depending on the suffix at the end of the requested URL. If none match and no default is given no transformation takes place. should pass in a dict with the following format: { '[suffix]' : transformation_action , ... } View Source def suffix ( transformers , default = None ) : \"\"\" Returns a different transformer depending on the suffix at the end of the requested URL. If none match and no default is given no transformation takes place . should pass in a dict with the following format : { ' [suffix] ' : transformation_action , ... } \"\"\" transformers = { suffix : auto_kwargs ( transformer ) if transformer else transformer for suffix , transformer in transformers . items () } default = default and auto_kwargs ( default ) def transform ( data , request ) : path = request . path transformer = default for suffix_test , suffix_transformer in transformers . items () : if path . endswith ( suffix_test ) : transformer = suffix_transformer break return transformer ( data ) if transformer else data return transform","title":"suffix"},{"location":"reference/hug/types/","text":"Module hug.types hug/types.py Defines hugs built-in supported types / validators Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/types.py Defines hugs built - in supported types / validators Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import uuid as native_uuid from decimal import Decimal from distutils . version import LooseVersion import hug . _empty as empty from hug import introspect from hug . exceptions import InvalidTypeData from hug . json_module import json as json_converter MARSHMALLOW_MAJOR_VERSION = None try : import marshmallow from marshmallow import ValidationError MARSHMALLOW_MAJOR_VERSION = getattr ( marshmallow , \" __version_info__ \" , LooseVersion ( marshmallow . __version__ ) . version ) [ 0 ] except ImportError : # Just define the error that is never raised so that Python does not complain . class ValidationError ( Exception ) : pass class Type ( object ) : \"\"\" Defines the base hug concept of a type for use in function annotation. Override ` __call__ ` to define how the type should be transformed and validated \"\"\" _hug_type = True _sub_type = None _accept_context = False def __init__ ( self ) : pass def __call__ ( self , value ) : raise NotImplementedError ( \" To implement a new type __call__ must be defined \" ) def create ( doc = None , error_text = None , exception_handlers = empty . dict , extend = Type , chain = True , auto_instance = True , accept_context = False , ) : \"\"\" Creates a new type handler with the specified type-casting handler \"\"\" extend = extend if type ( extend ) == type else type ( extend ) def new_type_handler ( function ) : class NewType ( extend ) : __slots__ = () _accept_context = accept_context if chain and extend != Type : if error_text or exception_handlers : if not accept_context : def __call__ ( self , value ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if extend . _accept_context : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if not accept_context : def __call__ ( self , value ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) else : if extend . _accept_context : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) else : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) else : if not accept_context : if error_text or exception_handlers : def __call__ ( self , value ) : try : return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value ) : return function ( value ) else : if error_text or exception_handlers : def __call__ ( self , value , context ) : try : return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : return function ( value , context ) NewType . __doc__ = function . __doc__ if doc is None else doc if auto_instance and not ( introspect . arguments ( NewType . __init__ , - 1 ) or introspect . takes_kwargs ( NewType . __init__ ) or introspect . takes_args ( NewType . __init__ ) ) : return NewType () return NewType return new_type_handler def accept ( kind , doc = None , error_text = None , exception_handlers = empty . dict , accept_context = False ) : \"\"\" Allows quick wrapping of any Python type cast function for use as a hug type annotation \"\"\" return create ( doc , error_text , exception_handlers = exception_handlers , chain = False , accept_context = accept_context , )( kind ) number = accept ( int , \" A whole number \" , \" Invalid whole number provided \" ) float_number = accept ( float , \" A float number \" , \" Invalid float number provided \" ) decimal = accept ( Decimal , \" A decimal number \" , \" Invalid decimal number provided \" ) boolean = accept ( bool , \" Providing any value will set this to true \" , \" Invalid boolean value provided \" ) uuid = accept ( native_uuid . UUID , \" A Universally Unique IDentifier \" , \" Invalid UUID provided \" ) class Text ( Type ) : \"\"\" Basic text / string value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( list , tuple ) or value is None : raise ValueError ( \" Invalid text value provided \" ) return str ( value ) text = Text () class SubTyped ( type ) : def __getitem__ ( cls , sub_type ) : class TypedSubclass ( cls ) : _sub_type = sub_type return TypedSubclass class Multiple ( Type , metaclass = SubTyped ) : \"\"\" Multiple Values \"\"\" __slots__ = () def __call__ ( self , value ) : as_multiple = value if isinstance ( value , list ) else [ value ] if self . _sub_type : return [ self . _sub_type ( item ) for item in as_multiple ] return as_multiple class DelimitedList ( Type , metaclass = SubTyped ) : \"\"\" Defines a list type that is formed by delimiting a list with a certain character or set of characters \"\"\" def __init__ ( self , using = \" , \" ) : super () . __init__ () self . using = using @ property def __doc__ ( self ) : return ''' Multiple values, separated by \"{0}\" ''' . format ( self . using ) def __call__ ( self , value ) : value_list = value if type ( value ) in ( list , tuple ) else value . split ( self . using ) if self . _sub_type : value_list = [ self . _sub_type ( val ) for val in value_list ] return value_list class SmartBoolean ( type ( boolean )) : \"\"\" Accepts a true or false value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) == bool or value in ( None , 1 , 0 ) : return bool ( value ) value = value . lower () if value in ( \" true \" , \" t \" , \" 1 \" ) : return True elif value in ( \" false \" , \" f \" , \" 0 \" , \"\" ) : return False raise KeyError ( \" Invalid value passed in for true/false field \" ) class InlineDictionary ( Type , metaclass = SubTyped ) : \"\"\" A single line dictionary, where items are separted by commas and key:value are separated by a pipe \"\"\" def __init__ ( self , * args , ** kwargs ) : super () . __init__ ( * args , ** kwargs ) self . key_type = self . value_type = None if self . _sub_type : if type ( self . _sub_type ) in ( tuple , list ) : if len ( self . _sub_type ) >= 2 : self . key_type , self . value_type = self . _sub_type [: 2 ] else : self . key_type = self . _sub_type def __call__ ( self , string ) : dictionary = {} for key , value in ( item . split ( \" : \" ) for item in string . split ( \" | \" )) : key , value = key . strip () , value . strip () dictionary [ self . key_type ( key ) if self . key_type else key ] = ( self . value_type ( value ) if self . value_type else value ) return dictionary class OneOf ( Type ) : \"\"\" Ensures the value is within a set of acceptable values \"\"\" __slots__ = ( \" values \" , ) def __init__ ( self , values ) : self . values = values @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return value class Mapping ( OneOf ) : \"\"\" Ensures the value is one of an acceptable set of values mapping those values to a Python equivelent \"\"\" __slots__ = ( \" value_map \" , ) def __init__ ( self , value_map ) : self . value_map = value_map self . values = value_map . keys () @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return self . value_map [ value ] class JSON ( Type ) : \"\"\" Accepts a JSON formatted data structure \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( str , bytes ) : try : return json_converter . loads ( value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . try : fixed_value = \" , \" . join ( value ) return json_converter . loads ( fixed_value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) else : return value class Multi ( Type ) : \"\"\" Enables accepting one of multiple type methods \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types @ property def __doc__ ( self ) : type_strings = ( type_method . __doc__ for type_method in self . types ) return \" Accepts any of the following value types:{0} \\n \" . format ( \" \\n - \" . join ( type_strings )) def __call__ ( self , value ) : for type_method in self . types : try : return type_method ( value ) except BaseException : pass raise ValueError ( self . __doc__ ) class InRange ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = number ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater or equal to {1} and less than {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) if value < self . lower : raise ValueError ( \" '{0}' is less than the lower limit {1} \" . format ( value , self . lower )) if value >= self . upper : raise ValueError ( \" '{0}' reaches the limit of {1} \" . format ( value , self . upper )) return value class LessThan ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = number ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is less than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) if not value < self . limit : raise ValueError ( \" '{0}' must be less than {1} \" . format ( value , self . limit )) return value class GreaterThan ( Type ) : \"\"\" Accepts a value above a given minimum \"\"\" __slots__ = ( \" minimum \" , \" convert \" ) def __init__ ( self , minimum , convert = number ) : self . minimum = minimum self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater than {1} \" . format ( self . convert . __doc__ , self . minimum ) def __call__ ( self , value ) : value = self . convert ( value ) if not value > self . minimum : raise ValueError ( \" '{0}' must be greater than {1} \" . format ( value , self . minimum )) return value class Length ( Type ) : \"\"\" Accepts a a value that is within a specific length limit \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = text ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that has a length longer or equal to {1} and less then {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if length < self . lower : raise ValueError ( \" '{0}' is shorter than the lower limit of {1} \" . format ( value , self . lower ) ) if length >= self . upper : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . upper ) ) return value class ShorterThan ( Type ) : \"\"\" Accepts a text value shorter than the specified length limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length of no more than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length < self . limit : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . limit ) ) return value class LongerThan ( Type ) : \"\"\" Accepts a value up to the specified limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length longer than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length > self . limit : raise ValueError ( \" '{0}' must be longer than {1} \" . format ( value , self . limit )) return value class CutOff ( Type ) : \"\"\" Cuts off the provided value at the specified index \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" '{0}' with anything over the length of {1} being ignored \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : return self . convert ( value ) [: self . limit ] class Chain ( Type ) : \"\"\" type for chaining multiple types together \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : for type_function in self . types : value = type_function ( value ) return value class Nullable ( Chain ) : \"\"\" A Chain types that Allows None values \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : if value is None : return None else : return super ( Nullable , self ) . __call__ ( value ) class TypedProperty ( object ) : \"\"\" class for building property objects for schema objects \"\"\" __slots__ = ( \" name \" , \" type_func \" ) def __init__ ( self , name , type_func ) : self . name = \" _ \" + name self . type_func = type_func def __get__ ( self , instance , cls ) : return getattr ( instance , self . name , None ) def __set__ ( self , instance , value ) : setattr ( instance , self . name , self . type_func ( value )) def __delete__ ( self , instance ) : raise AttributeError ( \" Can't delete attribute \" ) class NewTypeMeta ( type ) : \"\"\" Meta class to turn Schema objects into format usable by hug \"\"\" __slots__ = () def __init__ ( cls , name , bases , nmspc ) : cls . _types = { attr : getattr ( cls , attr ) for attr in dir ( cls ) if getattr ( getattr ( cls , attr ) , \" _hug_type \" , False ) } slots = getattr ( cls , \" __slots__ \" , ()) slots = set ( slots ) for attr , type_func in cls . _types . items () : slots . add ( \" _ \" + attr ) slots . add ( attr ) prop = TypedProperty ( attr , type_func ) setattr ( cls , attr , prop ) cls . __slots__ = tuple ( slots ) super ( NewTypeMeta , cls ) . __init__ ( name , bases , nmspc ) class Schema ( object , metaclass = NewTypeMeta ) : \"\"\" Schema for creating complex types using hug types \"\"\" __slots__ = () def __new__ ( cls , json , * args , ** kwargs ) : if json . __class__ == cls : return json else : return super ( Schema , cls ) . __new__ ( cls ) def __init__ ( self , json , force = False ) : if self != json : for ( key , value ) in json . items () : if force : key = \" _ \" + key setattr ( self , key , value ) json = JSON () class MarshmallowInputSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug input type annotation \"\"\" __slots__ = \" schema \" def __init__ ( self , schema ) : self . schema = schema @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value , context ) : self . schema . context = context # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) else : errors = {} try : value = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value class MarshmallowReturnSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug return type annotation \"\"\" __slots__ = ( \" schema \" , ) def __init__ ( self , schema ) : self . schema = schema @ property def context ( self ) : return self . schema . context @ context . setter def context ( self , context ) : self . schema . context = context @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value ) : # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = self . schema . dump ( value ) else : errors = {} try : value = self . schema . dump ( value ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value multiple = Multiple () smart_boolean = SmartBoolean () inline_dictionary = InlineDictionary () comma_separated_list = DelimitedList ( using = \" , \" ) # NOTE : These forms are going to be DEPRECATED , here for backwards compatibility only delimited_list = DelimitedList one_of = OneOf mapping = Mapping multi = Multi in_range = InRange less_than = LessThan greater_than = GreaterThan length = Length shorter_than = ShorterThan longer_than = LongerThan cut_off = CutOff Variables MARSHMALLOW_MAJOR_VERSION boolean comma_separated_list decimal float_number inline_dictionary json multiple number smart_boolean text uuid Functions accept def ( kind , doc = None , error_text = None , exception_handlers = mappingproxy ({}), accept_context = False ) Allows quick wrapping of any Python type cast function for use as a hug type annotation View Source def accept ( kind , doc = None , error_text = None , exception_handlers = empty . dict , accept_context = False ) : \"\"\" Allows quick wrapping of any Python type cast function for use as a hug type annotation \"\"\" return create ( doc , error_text , exception_handlers = exception_handlers , chain = False , accept_context = accept_context , )( kind ) create def ( doc = None , error_text = None , exception_handlers = mappingproxy ({}), extend =< class ' hug . types . Type '>, chain = True , auto_instance = True , accept_context = False ) Creates a new type handler with the specified type-casting handler View Source def create ( doc = None , error_text = None , exception_handlers = empty . dict , extend = Type , chain = True , auto_instance = True , accept_context = False , ) : \"\"\" Creates a new type handler with the specified type-casting handler \"\"\" extend = extend if type ( extend ) == type else type ( extend ) def new_type_handler ( function ) : class NewType ( extend ) : __slots__ = () _accept_context = accept_context if chain and extend != Type : if error_text or exception_handlers : if not accept_context : def __call__ ( self , value ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if extend . _accept_context : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if not accept_context : def __call__ ( self , value ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) else : if extend . _accept_context : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) else : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) else : if not accept_context : if error_text or exception_handlers : def __call__ ( self , value ) : try : return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value ) : return function ( value ) else : if error_text or exception_handlers : def __call__ ( self , value , context ) : try : return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : return function ( value , context ) NewType . __doc__ = function . __doc__ if doc is None else doc if auto_instance and not ( introspect . arguments ( NewType . __init__ , - 1 ) or introspect . takes_kwargs ( NewType . __init__ ) or introspect . takes_args ( NewType . __init__ ) ) : return NewType () return NewType return new_type_handler Classes Chain class ( * types ) type for chaining multiple types together View Source class Chain ( Type ) : \"\"\" type for chaining multiple types together \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : for type_function in self . types : value = type_function ( value ) return value Ancestors (in MRO) hug.types.Type Descendants hug.types.Nullable CutOff class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class CutOff ( Type ) : \"\"\" Cuts off the provided value at the specified index \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" '{0}' with anything over the length of {1} being ignored \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : return self . convert ( value ) [: self . limit ] Ancestors (in MRO) hug.types.Type DelimitedList class ( using = ',' ) View Source class DelimitedList ( Type , metaclass = SubTyped ) : \"\"\" Defines a list type that is formed by delimiting a list with a certain character or set of characters \"\"\" def __init__ ( self , using = \" , \" ) : super () . __init__ () self . using = using @ property def __doc__ ( self ) : return ''' Multiple values, separated by \"{0}\" ''' . format ( self . using ) def __call__ ( self , value ) : value_list = value if type ( value ) in ( list , tuple ) else value . split ( self . using ) if self . _sub_type : value_list = [ self . _sub_type ( val ) for val in value_list ] return value_list Ancestors (in MRO) hug.types.Type GreaterThan class ( minimum , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class GreaterThan ( Type ) : \"\"\" Accepts a value above a given minimum \"\"\" __slots__ = ( \" minimum \" , \" convert \" ) def __init__ ( self , minimum , convert = number ) : self . minimum = minimum self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater than {1} \" . format ( self . convert . __doc__ , self . minimum ) def __call__ ( self , value ) : value = self . convert ( value ) if not value > self . minimum : raise ValueError ( \" '{0}' must be greater than {1} \" . format ( value , self . minimum )) return value Ancestors (in MRO) hug.types.Type InRange class ( lower , upper , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class InRange ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = number ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater or equal to {1} and less than {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) if value < self . lower : raise ValueError ( \" '{0}' is less than the lower limit {1} \" . format ( value , self . lower )) if value >= self . upper : raise ValueError ( \" '{0}' reaches the limit of {1} \" . format ( value , self . upper )) return value Ancestors (in MRO) hug.types.Type InlineDictionary class ( * args , ** kwargs ) A single line dictionary, where items are separted by commas and key:value are separated by a pipe View Source class InlineDictionary ( Type , metaclass = SubTyped ) : \"\"\" A single line dictionary, where items are separted by commas and key:value are separated by a pipe \"\"\" def __init__ ( self , * args , ** kwargs ) : super () . __init__ ( * args , ** kwargs ) self . key_type = self . value_type = None if self . _sub_type : if type ( self . _sub_type ) in ( tuple , list ) : if len ( self . _sub_type ) >= 2 : self . key_type , self . value_type = self . _sub_type [: 2 ] else : self . key_type = self . _sub_type def __call__ ( self , string ) : dictionary = {} for key , value in ( item . split ( \" : \" ) for item in string . split ( \" | \" )) : key , value = key . strip () , value . strip () dictionary [ self . key_type ( key ) if self . key_type else key ] = ( self . value_type ( value ) if self . value_type else value ) return dictionary Ancestors (in MRO) hug.types.Type JSON class ( ) Accepts a JSON formatted data structure View Source class JSON ( Type ) : \"\"\" Accepts a JSON formatted data structure \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( str , bytes ) : try : return json_converter . loads ( value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . try : fixed_value = \" , \" . join ( value ) return json_converter . loads ( fixed_value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) else : return value Ancestors (in MRO) hug.types.Type Length class ( lower , upper , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class Length ( Type ) : \"\"\" Accepts a a value that is within a specific length limit \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = text ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that has a length longer or equal to {1} and less then {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if length < self . lower : raise ValueError ( \" '{0}' is shorter than the lower limit of {1} \" . format ( value , self . lower ) ) if length >= self . upper : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . upper ) ) return value Ancestors (in MRO) hug.types.Type LessThan class ( limit , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class LessThan ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = number ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is less than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) if not value < self . limit : raise ValueError ( \" '{0}' must be less than {1} \" . format ( value , self . limit )) return value Ancestors (in MRO) hug.types.Type LongerThan class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class LongerThan ( Type ) : \"\"\" Accepts a value up to the specified limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length longer than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length > self . limit : raise ValueError ( \" '{0}' must be longer than {1} \" . format ( value , self . limit )) return value Ancestors (in MRO) hug.types.Type Mapping class ( value_map ) View Source class Mapping ( OneOf ) : \"\"\" Ensures the value is one of an acceptable set of values mapping those values to a Python equivelent \"\"\" __slots__ = ( \" value_map \" , ) def __init__ ( self , value_map ) : self . value_map = value_map self . values = value_map . keys () @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return self . value_map [ value ] Ancestors (in MRO) hug.types.OneOf hug.types.Type MarshmallowInputSchema class ( schema ) View Source class MarshmallowInputSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug input type annotation \"\"\" __slots__ = \" schema \" def __init__ ( self , schema ) : self . schema = schema @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value , context ) : self . schema . context = context # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) else : errors = {} try : value = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value Ancestors (in MRO) hug.types.Type MarshmallowReturnSchema class ( schema ) View Source class MarshmallowReturnSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug return type annotation \"\"\" __slots__ = ( \" schema \" , ) def __init__ ( self , schema ) : self . schema = schema @ property def context ( self ) : return self . schema . context @ context . setter def context ( self , context ) : self . schema . context = context @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value ) : # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = self . schema . dump ( value ) else : errors = {} try : value = self . schema . dump ( value ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value Ancestors (in MRO) hug.types.Type Multi class ( * types ) View Source class Multi ( Type ) : \"\"\" Enables accepting one of multiple type methods \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types @ property def __doc__ ( self ) : type_strings = ( type_method . __doc__ for type_method in self . types ) return \" Accepts any of the following value types:{0} \\n \" . format ( \" \\n - \" . join ( type_strings )) def __call__ ( self , value ) : for type_method in self . types : try : return type_method ( value ) except BaseException : pass raise ValueError ( self . __doc__ ) Ancestors (in MRO) hug.types.Type Multiple class ( ) Multiple Values View Source class Multiple ( Type , metaclass = SubTyped ) : \"\"\" Multiple Values \"\"\" __slots__ = () def __call__ ( self , value ) : as_multiple = value if isinstance ( value , list ) else [ value ] if self . _sub_type : return [ self . _sub_type ( item ) for item in as_multiple ] return as_multiple Ancestors (in MRO) hug.types.Type NewTypeMeta class ( cls , name , bases , nmspc ) Meta class to turn Schema objects into format usable by hug View Source class NewTypeMeta ( type ) : \"\"\" Meta class to turn Schema objects into format usable by hug \"\"\" __slots__ = () def __init__ ( cls , name , bases , nmspc ) : cls . _types = { attr : getattr ( cls , attr ) for attr in dir ( cls ) if getattr ( getattr ( cls , attr ) , \" _hug_type \" , False ) } slots = getattr ( cls , \" __slots__ \" , ()) slots = set ( slots ) for attr , type_func in cls . _types . items () : slots . add ( \" _ \" + attr ) slots . add ( attr ) prop = TypedProperty ( attr , type_func ) setattr ( cls , attr , prop ) cls . __slots__ = tuple ( slots ) super ( NewTypeMeta , cls ) . __init__ ( name , bases , nmspc ) Ancestors (in MRO) builtins.type Nullable class ( * types ) A Chain types that Allows None values View Source class Nullable ( Chain ) : \"\"\" A Chain types that Allows None values \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : if value is None : return None else : return super ( Nullable , self ) . __call__ ( value ) Ancestors (in MRO) hug.types.Chain hug.types.Type OneOf class ( values ) View Source class OneOf ( Type ) : \"\"\" Ensures the value is within a set of acceptable values \"\"\" __slots__ = ( \" values \" , ) def __init__ ( self , values ) : self . values = values @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return value Ancestors (in MRO) hug.types.Type Descendants hug.types.Mapping Schema class ( json , force = False ) Schema for creating complex types using hug types View Source class Schema ( object , metaclass = NewTypeMeta ) : \"\"\" Schema for creating complex types using hug types \"\"\" __slots__ = () def __new__ ( cls , json , * args , ** kwargs ) : if json . __class__ == cls : return json else : return super ( Schema , cls ) . __new__ ( cls ) def __init__ ( self , json , force = False ) : if self != json : for ( key , value ) in json . items () : if force : key = \" _ \" + key setattr ( self , key , value ) ShorterThan class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class ShorterThan ( Type ) : \"\"\" Accepts a text value shorter than the specified length limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length of no more than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length < self . limit : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . limit ) ) return value Ancestors (in MRO) hug.types.Type SmartBoolean class ( ) Accepts a true or false value View Source class SmartBoolean ( type ( boolean )) : \"\"\" Accepts a true or false value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) == bool or value in ( None , 1 , 0 ) : return bool ( value ) value = value . lower () if value in ( \" true \" , \" t \" , \" 1 \" ) : return True elif value in ( \" false \" , \" f \" , \" 0 \" , \"\" ) : return False raise KeyError ( \" Invalid value passed in for true/false field \" ) Ancestors (in MRO) hug.types.NewType hug.types.Type SubTyped class ( / , * args , ** kwargs ) type(object_or_name, bases, dict) type(object) -> the object's type type(name, bases, dict) -> a new type View Source class SubTyped ( type ) : def __getitem__ ( cls , sub_type ) : class TypedSubclass ( cls ) : _sub_type = sub_type return TypedSubclass Ancestors (in MRO) builtins.type Text class ( ) Basic text / string value View Source class Text ( Type ) : \"\"\" Basic text / string value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( list , tuple ) or value is None : raise ValueError ( \" Invalid text value provided \" ) return str ( value ) Ancestors (in MRO) hug.types.Type Type class ( ) Defines the base hug concept of a type for use in function annotation. Override __call__ to define how the type should be transformed and validated View Source class Type ( object ) : \"\"\" Defines the base hug concept of a type for use in function annotation. Override ` __call__ ` to define how the type should be transformed and validated \"\"\" _hug_type = True _sub_type = None _accept_context = False def __init__ ( self ) : pass def __call__ ( self , value ) : raise NotImplementedError ( \" To implement a new type __call__ must be defined \" ) Descendants hug.types.NewType hug.types.NewType hug.types.NewType hug.types.NewType hug.types.NewType hug.types.Text hug.types.Multiple hug.types.DelimitedList hug.types.InlineDictionary hug.types.OneOf hug.types.JSON hug.types.Multi hug.types.InRange hug.types.LessThan hug.types.GreaterThan hug.types.Length hug.types.ShorterThan hug.types.LongerThan hug.types.CutOff hug.types.Chain hug.types.MarshmallowInputSchema hug.types.MarshmallowReturnSchema TypedProperty class ( name , type_func ) class for building property objects for schema objects View Source class TypedProperty ( object ) : \"\"\" class for building property objects for schema objects \"\"\" __slots__ = ( \" name \" , \" type_func \" ) def __init__ ( self , name , type_func ) : self . name = \" _ \" + name self . type_func = type_func def __get__ ( self , instance , cls ) : return getattr ( instance , self . name , None ) def __set__ ( self , instance , value ) : setattr ( instance , self . name , self . type_func ( value )) def __delete__ ( self , instance ) : raise AttributeError ( \" Can't delete attribute \" ) ValidationError class ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class ValidationError ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException cut_off class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class CutOff ( Type ) : \"\"\" Cuts off the provided value at the specified index \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" '{0}' with anything over the length of {1} being ignored \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : return self . convert ( value ) [: self . limit ] Ancestors (in MRO) hug.types.Type delimited_list class ( using = ',' ) View Source class DelimitedList ( Type , metaclass = SubTyped ) : \"\"\" Defines a list type that is formed by delimiting a list with a certain character or set of characters \"\"\" def __init__ ( self , using = \" , \" ) : super () . __init__ () self . using = using @ property def __doc__ ( self ) : return ''' Multiple values, separated by \"{0}\" ''' . format ( self . using ) def __call__ ( self , value ) : value_list = value if type ( value ) in ( list , tuple ) else value . split ( self . using ) if self . _sub_type : value_list = [ self . _sub_type ( val ) for val in value_list ] return value_list Ancestors (in MRO) hug.types.Type greater_than class ( minimum , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class GreaterThan ( Type ) : \"\"\" Accepts a value above a given minimum \"\"\" __slots__ = ( \" minimum \" , \" convert \" ) def __init__ ( self , minimum , convert = number ) : self . minimum = minimum self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater than {1} \" . format ( self . convert . __doc__ , self . minimum ) def __call__ ( self , value ) : value = self . convert ( value ) if not value > self . minimum : raise ValueError ( \" '{0}' must be greater than {1} \" . format ( value , self . minimum )) return value Ancestors (in MRO) hug.types.Type in_range class ( lower , upper , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class InRange ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = number ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater or equal to {1} and less than {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) if value < self . lower : raise ValueError ( \" '{0}' is less than the lower limit {1} \" . format ( value , self . lower )) if value >= self . upper : raise ValueError ( \" '{0}' reaches the limit of {1} \" . format ( value , self . upper )) return value Ancestors (in MRO) hug.types.Type length class ( lower , upper , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class Length ( Type ) : \"\"\" Accepts a a value that is within a specific length limit \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = text ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that has a length longer or equal to {1} and less then {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if length < self . lower : raise ValueError ( \" '{0}' is shorter than the lower limit of {1} \" . format ( value , self . lower ) ) if length >= self . upper : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . upper ) ) return value Ancestors (in MRO) hug.types.Type less_than class ( limit , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class LessThan ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = number ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is less than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) if not value < self . limit : raise ValueError ( \" '{0}' must be less than {1} \" . format ( value , self . limit )) return value Ancestors (in MRO) hug.types.Type longer_than class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class LongerThan ( Type ) : \"\"\" Accepts a value up to the specified limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length longer than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length > self . limit : raise ValueError ( \" '{0}' must be longer than {1} \" . format ( value , self . limit )) return value Ancestors (in MRO) hug.types.Type mapping class ( value_map ) View Source class Mapping ( OneOf ) : \"\"\" Ensures the value is one of an acceptable set of values mapping those values to a Python equivelent \"\"\" __slots__ = ( \" value_map \" , ) def __init__ ( self , value_map ) : self . value_map = value_map self . values = value_map . keys () @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return self . value_map [ value ] Ancestors (in MRO) hug.types.OneOf hug.types.Type multi class ( * types ) View Source class Multi ( Type ) : \"\"\" Enables accepting one of multiple type methods \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types @ property def __doc__ ( self ) : type_strings = ( type_method . __doc__ for type_method in self . types ) return \" Accepts any of the following value types:{0} \\n \" . format ( \" \\n - \" . join ( type_strings )) def __call__ ( self , value ) : for type_method in self . types : try : return type_method ( value ) except BaseException : pass raise ValueError ( self . __doc__ ) Ancestors (in MRO) hug.types.Type one_of class ( values ) View Source class OneOf ( Type ) : \"\"\" Ensures the value is within a set of acceptable values \"\"\" __slots__ = ( \" values \" , ) def __init__ ( self , values ) : self . values = values @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return value Ancestors (in MRO) hug.types.Type Descendants hug.types.Mapping shorter_than class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class ShorterThan ( Type ) : \"\"\" Accepts a text value shorter than the specified length limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length of no more than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length < self . limit : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . limit ) ) return value Ancestors (in MRO) hug.types.Type","title":"Types"},{"location":"reference/hug/types/#module-hugtypes","text":"hug/types.py Defines hugs built-in supported types / validators Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/types.py Defines hugs built - in supported types / validators Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import uuid as native_uuid from decimal import Decimal from distutils . version import LooseVersion import hug . _empty as empty from hug import introspect from hug . exceptions import InvalidTypeData from hug . json_module import json as json_converter MARSHMALLOW_MAJOR_VERSION = None try : import marshmallow from marshmallow import ValidationError MARSHMALLOW_MAJOR_VERSION = getattr ( marshmallow , \" __version_info__ \" , LooseVersion ( marshmallow . __version__ ) . version ) [ 0 ] except ImportError : # Just define the error that is never raised so that Python does not complain . class ValidationError ( Exception ) : pass class Type ( object ) : \"\"\" Defines the base hug concept of a type for use in function annotation. Override ` __call__ ` to define how the type should be transformed and validated \"\"\" _hug_type = True _sub_type = None _accept_context = False def __init__ ( self ) : pass def __call__ ( self , value ) : raise NotImplementedError ( \" To implement a new type __call__ must be defined \" ) def create ( doc = None , error_text = None , exception_handlers = empty . dict , extend = Type , chain = True , auto_instance = True , accept_context = False , ) : \"\"\" Creates a new type handler with the specified type-casting handler \"\"\" extend = extend if type ( extend ) == type else type ( extend ) def new_type_handler ( function ) : class NewType ( extend ) : __slots__ = () _accept_context = accept_context if chain and extend != Type : if error_text or exception_handlers : if not accept_context : def __call__ ( self , value ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if extend . _accept_context : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if not accept_context : def __call__ ( self , value ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) else : if extend . _accept_context : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) else : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) else : if not accept_context : if error_text or exception_handlers : def __call__ ( self , value ) : try : return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value ) : return function ( value ) else : if error_text or exception_handlers : def __call__ ( self , value , context ) : try : return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : return function ( value , context ) NewType . __doc__ = function . __doc__ if doc is None else doc if auto_instance and not ( introspect . arguments ( NewType . __init__ , - 1 ) or introspect . takes_kwargs ( NewType . __init__ ) or introspect . takes_args ( NewType . __init__ ) ) : return NewType () return NewType return new_type_handler def accept ( kind , doc = None , error_text = None , exception_handlers = empty . dict , accept_context = False ) : \"\"\" Allows quick wrapping of any Python type cast function for use as a hug type annotation \"\"\" return create ( doc , error_text , exception_handlers = exception_handlers , chain = False , accept_context = accept_context , )( kind ) number = accept ( int , \" A whole number \" , \" Invalid whole number provided \" ) float_number = accept ( float , \" A float number \" , \" Invalid float number provided \" ) decimal = accept ( Decimal , \" A decimal number \" , \" Invalid decimal number provided \" ) boolean = accept ( bool , \" Providing any value will set this to true \" , \" Invalid boolean value provided \" ) uuid = accept ( native_uuid . UUID , \" A Universally Unique IDentifier \" , \" Invalid UUID provided \" ) class Text ( Type ) : \"\"\" Basic text / string value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( list , tuple ) or value is None : raise ValueError ( \" Invalid text value provided \" ) return str ( value ) text = Text () class SubTyped ( type ) : def __getitem__ ( cls , sub_type ) : class TypedSubclass ( cls ) : _sub_type = sub_type return TypedSubclass class Multiple ( Type , metaclass = SubTyped ) : \"\"\" Multiple Values \"\"\" __slots__ = () def __call__ ( self , value ) : as_multiple = value if isinstance ( value , list ) else [ value ] if self . _sub_type : return [ self . _sub_type ( item ) for item in as_multiple ] return as_multiple class DelimitedList ( Type , metaclass = SubTyped ) : \"\"\" Defines a list type that is formed by delimiting a list with a certain character or set of characters \"\"\" def __init__ ( self , using = \" , \" ) : super () . __init__ () self . using = using @ property def __doc__ ( self ) : return ''' Multiple values, separated by \"{0}\" ''' . format ( self . using ) def __call__ ( self , value ) : value_list = value if type ( value ) in ( list , tuple ) else value . split ( self . using ) if self . _sub_type : value_list = [ self . _sub_type ( val ) for val in value_list ] return value_list class SmartBoolean ( type ( boolean )) : \"\"\" Accepts a true or false value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) == bool or value in ( None , 1 , 0 ) : return bool ( value ) value = value . lower () if value in ( \" true \" , \" t \" , \" 1 \" ) : return True elif value in ( \" false \" , \" f \" , \" 0 \" , \"\" ) : return False raise KeyError ( \" Invalid value passed in for true/false field \" ) class InlineDictionary ( Type , metaclass = SubTyped ) : \"\"\" A single line dictionary, where items are separted by commas and key:value are separated by a pipe \"\"\" def __init__ ( self , * args , ** kwargs ) : super () . __init__ ( * args , ** kwargs ) self . key_type = self . value_type = None if self . _sub_type : if type ( self . _sub_type ) in ( tuple , list ) : if len ( self . _sub_type ) >= 2 : self . key_type , self . value_type = self . _sub_type [: 2 ] else : self . key_type = self . _sub_type def __call__ ( self , string ) : dictionary = {} for key , value in ( item . split ( \" : \" ) for item in string . split ( \" | \" )) : key , value = key . strip () , value . strip () dictionary [ self . key_type ( key ) if self . key_type else key ] = ( self . value_type ( value ) if self . value_type else value ) return dictionary class OneOf ( Type ) : \"\"\" Ensures the value is within a set of acceptable values \"\"\" __slots__ = ( \" values \" , ) def __init__ ( self , values ) : self . values = values @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return value class Mapping ( OneOf ) : \"\"\" Ensures the value is one of an acceptable set of values mapping those values to a Python equivelent \"\"\" __slots__ = ( \" value_map \" , ) def __init__ ( self , value_map ) : self . value_map = value_map self . values = value_map . keys () @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return self . value_map [ value ] class JSON ( Type ) : \"\"\" Accepts a JSON formatted data structure \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( str , bytes ) : try : return json_converter . loads ( value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . try : fixed_value = \" , \" . join ( value ) return json_converter . loads ( fixed_value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) else : return value class Multi ( Type ) : \"\"\" Enables accepting one of multiple type methods \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types @ property def __doc__ ( self ) : type_strings = ( type_method . __doc__ for type_method in self . types ) return \" Accepts any of the following value types:{0} \\n \" . format ( \" \\n - \" . join ( type_strings )) def __call__ ( self , value ) : for type_method in self . types : try : return type_method ( value ) except BaseException : pass raise ValueError ( self . __doc__ ) class InRange ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = number ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater or equal to {1} and less than {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) if value < self . lower : raise ValueError ( \" '{0}' is less than the lower limit {1} \" . format ( value , self . lower )) if value >= self . upper : raise ValueError ( \" '{0}' reaches the limit of {1} \" . format ( value , self . upper )) return value class LessThan ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = number ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is less than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) if not value < self . limit : raise ValueError ( \" '{0}' must be less than {1} \" . format ( value , self . limit )) return value class GreaterThan ( Type ) : \"\"\" Accepts a value above a given minimum \"\"\" __slots__ = ( \" minimum \" , \" convert \" ) def __init__ ( self , minimum , convert = number ) : self . minimum = minimum self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater than {1} \" . format ( self . convert . __doc__ , self . minimum ) def __call__ ( self , value ) : value = self . convert ( value ) if not value > self . minimum : raise ValueError ( \" '{0}' must be greater than {1} \" . format ( value , self . minimum )) return value class Length ( Type ) : \"\"\" Accepts a a value that is within a specific length limit \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = text ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that has a length longer or equal to {1} and less then {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if length < self . lower : raise ValueError ( \" '{0}' is shorter than the lower limit of {1} \" . format ( value , self . lower ) ) if length >= self . upper : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . upper ) ) return value class ShorterThan ( Type ) : \"\"\" Accepts a text value shorter than the specified length limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length of no more than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length < self . limit : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . limit ) ) return value class LongerThan ( Type ) : \"\"\" Accepts a value up to the specified limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length longer than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length > self . limit : raise ValueError ( \" '{0}' must be longer than {1} \" . format ( value , self . limit )) return value class CutOff ( Type ) : \"\"\" Cuts off the provided value at the specified index \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" '{0}' with anything over the length of {1} being ignored \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : return self . convert ( value ) [: self . limit ] class Chain ( Type ) : \"\"\" type for chaining multiple types together \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : for type_function in self . types : value = type_function ( value ) return value class Nullable ( Chain ) : \"\"\" A Chain types that Allows None values \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : if value is None : return None else : return super ( Nullable , self ) . __call__ ( value ) class TypedProperty ( object ) : \"\"\" class for building property objects for schema objects \"\"\" __slots__ = ( \" name \" , \" type_func \" ) def __init__ ( self , name , type_func ) : self . name = \" _ \" + name self . type_func = type_func def __get__ ( self , instance , cls ) : return getattr ( instance , self . name , None ) def __set__ ( self , instance , value ) : setattr ( instance , self . name , self . type_func ( value )) def __delete__ ( self , instance ) : raise AttributeError ( \" Can't delete attribute \" ) class NewTypeMeta ( type ) : \"\"\" Meta class to turn Schema objects into format usable by hug \"\"\" __slots__ = () def __init__ ( cls , name , bases , nmspc ) : cls . _types = { attr : getattr ( cls , attr ) for attr in dir ( cls ) if getattr ( getattr ( cls , attr ) , \" _hug_type \" , False ) } slots = getattr ( cls , \" __slots__ \" , ()) slots = set ( slots ) for attr , type_func in cls . _types . items () : slots . add ( \" _ \" + attr ) slots . add ( attr ) prop = TypedProperty ( attr , type_func ) setattr ( cls , attr , prop ) cls . __slots__ = tuple ( slots ) super ( NewTypeMeta , cls ) . __init__ ( name , bases , nmspc ) class Schema ( object , metaclass = NewTypeMeta ) : \"\"\" Schema for creating complex types using hug types \"\"\" __slots__ = () def __new__ ( cls , json , * args , ** kwargs ) : if json . __class__ == cls : return json else : return super ( Schema , cls ) . __new__ ( cls ) def __init__ ( self , json , force = False ) : if self != json : for ( key , value ) in json . items () : if force : key = \" _ \" + key setattr ( self , key , value ) json = JSON () class MarshmallowInputSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug input type annotation \"\"\" __slots__ = \" schema \" def __init__ ( self , schema ) : self . schema = schema @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value , context ) : self . schema . context = context # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) else : errors = {} try : value = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value class MarshmallowReturnSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug return type annotation \"\"\" __slots__ = ( \" schema \" , ) def __init__ ( self , schema ) : self . schema = schema @ property def context ( self ) : return self . schema . context @ context . setter def context ( self , context ) : self . schema . context = context @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value ) : # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = self . schema . dump ( value ) else : errors = {} try : value = self . schema . dump ( value ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value multiple = Multiple () smart_boolean = SmartBoolean () inline_dictionary = InlineDictionary () comma_separated_list = DelimitedList ( using = \" , \" ) # NOTE : These forms are going to be DEPRECATED , here for backwards compatibility only delimited_list = DelimitedList one_of = OneOf mapping = Mapping multi = Multi in_range = InRange less_than = LessThan greater_than = GreaterThan length = Length shorter_than = ShorterThan longer_than = LongerThan cut_off = CutOff","title":"Module hug.types"},{"location":"reference/hug/types/#variables","text":"MARSHMALLOW_MAJOR_VERSION boolean comma_separated_list decimal float_number inline_dictionary json multiple number smart_boolean text uuid","title":"Variables"},{"location":"reference/hug/types/#functions","text":"","title":"Functions"},{"location":"reference/hug/types/#accept","text":"def ( kind , doc = None , error_text = None , exception_handlers = mappingproxy ({}), accept_context = False ) Allows quick wrapping of any Python type cast function for use as a hug type annotation View Source def accept ( kind , doc = None , error_text = None , exception_handlers = empty . dict , accept_context = False ) : \"\"\" Allows quick wrapping of any Python type cast function for use as a hug type annotation \"\"\" return create ( doc , error_text , exception_handlers = exception_handlers , chain = False , accept_context = accept_context , )( kind )","title":"accept"},{"location":"reference/hug/types/#create","text":"def ( doc = None , error_text = None , exception_handlers = mappingproxy ({}), extend =< class ' hug . types . Type '>, chain = True , auto_instance = True , accept_context = False ) Creates a new type handler with the specified type-casting handler View Source def create ( doc = None , error_text = None , exception_handlers = empty . dict , extend = Type , chain = True , auto_instance = True , accept_context = False , ) : \"\"\" Creates a new type handler with the specified type-casting handler \"\"\" extend = extend if type ( extend ) == type else type ( extend ) def new_type_handler ( function ) : class NewType ( extend ) : __slots__ = () _accept_context = accept_context if chain and extend != Type : if error_text or exception_handlers : if not accept_context : def __call__ ( self , value ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if extend . _accept_context : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : try : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : if not accept_context : def __call__ ( self , value ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value ) else : if extend . _accept_context : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value , context ) return function ( value , context ) else : def __call__ ( self , value , context ) : value = super ( NewType , self ) . __call__ ( value ) return function ( value , context ) else : if not accept_context : if error_text or exception_handlers : def __call__ ( self , value ) : try : return function ( value ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value ) : return function ( value ) else : if error_text or exception_handlers : def __call__ ( self , value , context ) : try : return function ( value , context ) except Exception as exception : for take_exception , rewrite in exception_handlers . items () : if isinstance ( exception , take_exception ) : if isinstance ( rewrite , str ) : raise ValueError ( rewrite ) else : raise rewrite ( value ) if error_text : raise ValueError ( error_text ) raise exception else : def __call__ ( self , value , context ) : return function ( value , context ) NewType . __doc__ = function . __doc__ if doc is None else doc if auto_instance and not ( introspect . arguments ( NewType . __init__ , - 1 ) or introspect . takes_kwargs ( NewType . __init__ ) or introspect . takes_args ( NewType . __init__ ) ) : return NewType () return NewType return new_type_handler","title":"create"},{"location":"reference/hug/types/#classes","text":"","title":"Classes"},{"location":"reference/hug/types/#chain","text":"class ( * types ) type for chaining multiple types together View Source class Chain ( Type ) : \"\"\" type for chaining multiple types together \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : for type_function in self . types : value = type_function ( value ) return value","title":"Chain"},{"location":"reference/hug/types/#ancestors-in-mro","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#descendants","text":"hug.types.Nullable","title":"Descendants"},{"location":"reference/hug/types/#cutoff","text":"class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class CutOff ( Type ) : \"\"\" Cuts off the provided value at the specified index \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" '{0}' with anything over the length of {1} being ignored \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : return self . convert ( value ) [: self . limit ]","title":"CutOff"},{"location":"reference/hug/types/#ancestors-in-mro_1","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#delimitedlist","text":"class ( using = ',' ) View Source class DelimitedList ( Type , metaclass = SubTyped ) : \"\"\" Defines a list type that is formed by delimiting a list with a certain character or set of characters \"\"\" def __init__ ( self , using = \" , \" ) : super () . __init__ () self . using = using @ property def __doc__ ( self ) : return ''' Multiple values, separated by \"{0}\" ''' . format ( self . using ) def __call__ ( self , value ) : value_list = value if type ( value ) in ( list , tuple ) else value . split ( self . using ) if self . _sub_type : value_list = [ self . _sub_type ( val ) for val in value_list ] return value_list","title":"DelimitedList"},{"location":"reference/hug/types/#ancestors-in-mro_2","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#greaterthan","text":"class ( minimum , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class GreaterThan ( Type ) : \"\"\" Accepts a value above a given minimum \"\"\" __slots__ = ( \" minimum \" , \" convert \" ) def __init__ ( self , minimum , convert = number ) : self . minimum = minimum self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater than {1} \" . format ( self . convert . __doc__ , self . minimum ) def __call__ ( self , value ) : value = self . convert ( value ) if not value > self . minimum : raise ValueError ( \" '{0}' must be greater than {1} \" . format ( value , self . minimum )) return value","title":"GreaterThan"},{"location":"reference/hug/types/#ancestors-in-mro_3","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#inrange","text":"class ( lower , upper , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class InRange ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = number ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater or equal to {1} and less than {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) if value < self . lower : raise ValueError ( \" '{0}' is less than the lower limit {1} \" . format ( value , self . lower )) if value >= self . upper : raise ValueError ( \" '{0}' reaches the limit of {1} \" . format ( value , self . upper )) return value","title":"InRange"},{"location":"reference/hug/types/#ancestors-in-mro_4","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#inlinedictionary","text":"class ( * args , ** kwargs ) A single line dictionary, where items are separted by commas and key:value are separated by a pipe View Source class InlineDictionary ( Type , metaclass = SubTyped ) : \"\"\" A single line dictionary, where items are separted by commas and key:value are separated by a pipe \"\"\" def __init__ ( self , * args , ** kwargs ) : super () . __init__ ( * args , ** kwargs ) self . key_type = self . value_type = None if self . _sub_type : if type ( self . _sub_type ) in ( tuple , list ) : if len ( self . _sub_type ) >= 2 : self . key_type , self . value_type = self . _sub_type [: 2 ] else : self . key_type = self . _sub_type def __call__ ( self , string ) : dictionary = {} for key , value in ( item . split ( \" : \" ) for item in string . split ( \" | \" )) : key , value = key . strip () , value . strip () dictionary [ self . key_type ( key ) if self . key_type else key ] = ( self . value_type ( value ) if self . value_type else value ) return dictionary","title":"InlineDictionary"},{"location":"reference/hug/types/#ancestors-in-mro_5","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#json","text":"class ( ) Accepts a JSON formatted data structure View Source class JSON ( Type ) : \"\"\" Accepts a JSON formatted data structure \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( str , bytes ) : try : return json_converter . loads ( value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . try : fixed_value = \" , \" . join ( value ) return json_converter . loads ( fixed_value ) except Exception : raise ValueError ( \" Incorrectly formatted JSON provided \" ) else : return value","title":"JSON"},{"location":"reference/hug/types/#ancestors-in-mro_6","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#length","text":"class ( lower , upper , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class Length ( Type ) : \"\"\" Accepts a a value that is within a specific length limit \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = text ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that has a length longer or equal to {1} and less then {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if length < self . lower : raise ValueError ( \" '{0}' is shorter than the lower limit of {1} \" . format ( value , self . lower ) ) if length >= self . upper : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . upper ) ) return value","title":"Length"},{"location":"reference/hug/types/#ancestors-in-mro_7","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#lessthan","text":"class ( limit , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class LessThan ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = number ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is less than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) if not value < self . limit : raise ValueError ( \" '{0}' must be less than {1} \" . format ( value , self . limit )) return value","title":"LessThan"},{"location":"reference/hug/types/#ancestors-in-mro_8","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#longerthan","text":"class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class LongerThan ( Type ) : \"\"\" Accepts a value up to the specified limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length longer than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length > self . limit : raise ValueError ( \" '{0}' must be longer than {1} \" . format ( value , self . limit )) return value","title":"LongerThan"},{"location":"reference/hug/types/#ancestors-in-mro_9","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#mapping","text":"class ( value_map ) View Source class Mapping ( OneOf ) : \"\"\" Ensures the value is one of an acceptable set of values mapping those values to a Python equivelent \"\"\" __slots__ = ( \" value_map \" , ) def __init__ ( self , value_map ) : self . value_map = value_map self . values = value_map . keys () @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return self . value_map [ value ]","title":"Mapping"},{"location":"reference/hug/types/#ancestors-in-mro_10","text":"hug.types.OneOf hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#marshmallowinputschema","text":"class ( schema ) View Source class MarshmallowInputSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug input type annotation \"\"\" __slots__ = \" schema \" def __init__ ( self , schema ) : self . schema = schema @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value , context ) : self . schema . context = context # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) else : errors = {} try : value = ( self . schema . loads ( value ) if isinstance ( value , str ) else self . schema . load ( value ) ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value","title":"MarshmallowInputSchema"},{"location":"reference/hug/types/#ancestors-in-mro_11","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#marshmallowreturnschema","text":"class ( schema ) View Source class MarshmallowReturnSchema ( Type ) : \"\"\" Allows using a Marshmallow Schema directly in a hug return type annotation \"\"\" __slots__ = ( \" schema \" , ) def __init__ ( self , schema ) : self . schema = schema @ property def context ( self ) : return self . schema . context @ context . setter def context ( self , context ) : self . schema . context = context @ property def __doc__ ( self ) : return self . schema . __doc__ or self . schema . __class__ . __name__ def __call__ ( self , value ) : # In marshmallow 2 schemas return tuple ( ` data `, ` errors ` ) upon loading . They might also raise on invalid data # if configured so , but will still return a tuple . # In marshmallow 3 schemas always raise Validation error on load if input data is invalid and a single # value ` data ` is returned . if MARSHMALLOW_MAJOR_VERSION is None or MARSHMALLOW_MAJOR_VERSION == 2 : value , errors = self . schema . dump ( value ) else : errors = {} try : value = self . schema . dump ( value ) except ValidationError as e : errors = e . messages if errors : raise InvalidTypeData ( \" Invalid {0} passed in \" . format ( self . schema . __class__ . __name__ ) , errors ) return value","title":"MarshmallowReturnSchema"},{"location":"reference/hug/types/#ancestors-in-mro_12","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#multi","text":"class ( * types ) View Source class Multi ( Type ) : \"\"\" Enables accepting one of multiple type methods \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types @ property def __doc__ ( self ) : type_strings = ( type_method . __doc__ for type_method in self . types ) return \" Accepts any of the following value types:{0} \\n \" . format ( \" \\n - \" . join ( type_strings )) def __call__ ( self , value ) : for type_method in self . types : try : return type_method ( value ) except BaseException : pass raise ValueError ( self . __doc__ )","title":"Multi"},{"location":"reference/hug/types/#ancestors-in-mro_13","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#multiple","text":"class ( ) Multiple Values View Source class Multiple ( Type , metaclass = SubTyped ) : \"\"\" Multiple Values \"\"\" __slots__ = () def __call__ ( self , value ) : as_multiple = value if isinstance ( value , list ) else [ value ] if self . _sub_type : return [ self . _sub_type ( item ) for item in as_multiple ] return as_multiple","title":"Multiple"},{"location":"reference/hug/types/#ancestors-in-mro_14","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#newtypemeta","text":"class ( cls , name , bases , nmspc ) Meta class to turn Schema objects into format usable by hug View Source class NewTypeMeta ( type ) : \"\"\" Meta class to turn Schema objects into format usable by hug \"\"\" __slots__ = () def __init__ ( cls , name , bases , nmspc ) : cls . _types = { attr : getattr ( cls , attr ) for attr in dir ( cls ) if getattr ( getattr ( cls , attr ) , \" _hug_type \" , False ) } slots = getattr ( cls , \" __slots__ \" , ()) slots = set ( slots ) for attr , type_func in cls . _types . items () : slots . add ( \" _ \" + attr ) slots . add ( attr ) prop = TypedProperty ( attr , type_func ) setattr ( cls , attr , prop ) cls . __slots__ = tuple ( slots ) super ( NewTypeMeta , cls ) . __init__ ( name , bases , nmspc )","title":"NewTypeMeta"},{"location":"reference/hug/types/#ancestors-in-mro_15","text":"builtins.type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#nullable","text":"class ( * types ) A Chain types that Allows None values View Source class Nullable ( Chain ) : \"\"\" A Chain types that Allows None values \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types def __call__ ( self , value ) : if value is None : return None else : return super ( Nullable , self ) . __call__ ( value )","title":"Nullable"},{"location":"reference/hug/types/#ancestors-in-mro_16","text":"hug.types.Chain hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#oneof","text":"class ( values ) View Source class OneOf ( Type ) : \"\"\" Ensures the value is within a set of acceptable values \"\"\" __slots__ = ( \" values \" , ) def __init__ ( self , values ) : self . values = values @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return value","title":"OneOf"},{"location":"reference/hug/types/#ancestors-in-mro_17","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#descendants_1","text":"hug.types.Mapping","title":"Descendants"},{"location":"reference/hug/types/#schema","text":"class ( json , force = False ) Schema for creating complex types using hug types View Source class Schema ( object , metaclass = NewTypeMeta ) : \"\"\" Schema for creating complex types using hug types \"\"\" __slots__ = () def __new__ ( cls , json , * args , ** kwargs ) : if json . __class__ == cls : return json else : return super ( Schema , cls ) . __new__ ( cls ) def __init__ ( self , json , force = False ) : if self != json : for ( key , value ) in json . items () : if force : key = \" _ \" + key setattr ( self , key , value )","title":"Schema"},{"location":"reference/hug/types/#shorterthan","text":"class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class ShorterThan ( Type ) : \"\"\" Accepts a text value shorter than the specified length limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length of no more than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length < self . limit : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . limit ) ) return value","title":"ShorterThan"},{"location":"reference/hug/types/#ancestors-in-mro_18","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#smartboolean","text":"class ( ) Accepts a true or false value View Source class SmartBoolean ( type ( boolean )) : \"\"\" Accepts a true or false value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) == bool or value in ( None , 1 , 0 ) : return bool ( value ) value = value . lower () if value in ( \" true \" , \" t \" , \" 1 \" ) : return True elif value in ( \" false \" , \" f \" , \" 0 \" , \"\" ) : return False raise KeyError ( \" Invalid value passed in for true/false field \" )","title":"SmartBoolean"},{"location":"reference/hug/types/#ancestors-in-mro_19","text":"hug.types.NewType hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#subtyped","text":"class ( / , * args , ** kwargs ) type(object_or_name, bases, dict) type(object) -> the object's type type(name, bases, dict) -> a new type View Source class SubTyped ( type ) : def __getitem__ ( cls , sub_type ) : class TypedSubclass ( cls ) : _sub_type = sub_type return TypedSubclass","title":"SubTyped"},{"location":"reference/hug/types/#ancestors-in-mro_20","text":"builtins.type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#text","text":"class ( ) Basic text / string value View Source class Text ( Type ) : \"\"\" Basic text / string value \"\"\" __slots__ = () def __call__ ( self , value ) : if type ( value ) in ( list , tuple ) or value is None : raise ValueError ( \" Invalid text value provided \" ) return str ( value )","title":"Text"},{"location":"reference/hug/types/#ancestors-in-mro_21","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#type","text":"class ( ) Defines the base hug concept of a type for use in function annotation. Override __call__ to define how the type should be transformed and validated View Source class Type ( object ) : \"\"\" Defines the base hug concept of a type for use in function annotation. Override ` __call__ ` to define how the type should be transformed and validated \"\"\" _hug_type = True _sub_type = None _accept_context = False def __init__ ( self ) : pass def __call__ ( self , value ) : raise NotImplementedError ( \" To implement a new type __call__ must be defined \" )","title":"Type"},{"location":"reference/hug/types/#descendants_2","text":"hug.types.NewType hug.types.NewType hug.types.NewType hug.types.NewType hug.types.NewType hug.types.Text hug.types.Multiple hug.types.DelimitedList hug.types.InlineDictionary hug.types.OneOf hug.types.JSON hug.types.Multi hug.types.InRange hug.types.LessThan hug.types.GreaterThan hug.types.Length hug.types.ShorterThan hug.types.LongerThan hug.types.CutOff hug.types.Chain hug.types.MarshmallowInputSchema hug.types.MarshmallowReturnSchema","title":"Descendants"},{"location":"reference/hug/types/#typedproperty","text":"class ( name , type_func ) class for building property objects for schema objects View Source class TypedProperty ( object ) : \"\"\" class for building property objects for schema objects \"\"\" __slots__ = ( \" name \" , \" type_func \" ) def __init__ ( self , name , type_func ) : self . name = \" _ \" + name self . type_func = type_func def __get__ ( self , instance , cls ) : return getattr ( instance , self . name , None ) def __set__ ( self , instance , value ) : setattr ( instance , self . name , self . type_func ( value )) def __delete__ ( self , instance ) : raise AttributeError ( \" Can't delete attribute \" )","title":"TypedProperty"},{"location":"reference/hug/types/#validationerror","text":"class ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class ValidationError ( Exception ): pass","title":"ValidationError"},{"location":"reference/hug/types/#ancestors-in-mro_22","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#cut_off","text":"class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class CutOff ( Type ) : \"\"\" Cuts off the provided value at the specified index \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" '{0}' with anything over the length of {1} being ignored \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : return self . convert ( value ) [: self . limit ]","title":"cut_off"},{"location":"reference/hug/types/#ancestors-in-mro_23","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#delimited_list","text":"class ( using = ',' ) View Source class DelimitedList ( Type , metaclass = SubTyped ) : \"\"\" Defines a list type that is formed by delimiting a list with a certain character or set of characters \"\"\" def __init__ ( self , using = \" , \" ) : super () . __init__ () self . using = using @ property def __doc__ ( self ) : return ''' Multiple values, separated by \"{0}\" ''' . format ( self . using ) def __call__ ( self , value ) : value_list = value if type ( value ) in ( list , tuple ) else value . split ( self . using ) if self . _sub_type : value_list = [ self . _sub_type ( val ) for val in value_list ] return value_list","title":"delimited_list"},{"location":"reference/hug/types/#ancestors-in-mro_24","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#greater_than","text":"class ( minimum , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class GreaterThan ( Type ) : \"\"\" Accepts a value above a given minimum \"\"\" __slots__ = ( \" minimum \" , \" convert \" ) def __init__ ( self , minimum , convert = number ) : self . minimum = minimum self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater than {1} \" . format ( self . convert . __doc__ , self . minimum ) def __call__ ( self , value ) : value = self . convert ( value ) if not value > self . minimum : raise ValueError ( \" '{0}' must be greater than {1} \" . format ( value , self . minimum )) return value","title":"greater_than"},{"location":"reference/hug/types/#ancestors-in-mro_25","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#in_range","text":"class ( lower , upper , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class InRange ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = number ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is greater or equal to {1} and less than {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) if value < self . lower : raise ValueError ( \" '{0}' is less than the lower limit {1} \" . format ( value , self . lower )) if value >= self . upper : raise ValueError ( \" '{0}' reaches the limit of {1} \" . format ( value , self . upper )) return value","title":"in_range"},{"location":"reference/hug/types/#ancestors-in-mro_26","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#length_1","text":"class ( lower , upper , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class Length ( Type ) : \"\"\" Accepts a a value that is within a specific length limit \"\"\" __slots__ = ( \" lower \" , \" upper \" , \" convert \" ) def __init__ ( self , lower , upper , convert = text ) : self . lower = lower self . upper = upper self . convert = convert @ property def __doc__ ( self ) : return \" {0} that has a length longer or equal to {1} and less then {2} \" . format ( self . convert . __doc__ , self . lower , self . upper ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if length < self . lower : raise ValueError ( \" '{0}' is shorter than the lower limit of {1} \" . format ( value , self . lower ) ) if length >= self . upper : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . upper ) ) return value","title":"length"},{"location":"reference/hug/types/#ancestors-in-mro_27","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#less_than","text":"class ( limit , convert =< hug . types . create .< locals >. new_type_handler .< locals >. NewType object at 0x7f06769bb1d0 > ) View Source class LessThan ( Type ) : \"\"\" Accepts a number within a lower and upper bound of acceptable values \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = number ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} that is less than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) if not value < self . limit : raise ValueError ( \" '{0}' must be less than {1} \" . format ( value , self . limit )) return value","title":"less_than"},{"location":"reference/hug/types/#ancestors-in-mro_28","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#longer_than","text":"class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class LongerThan ( Type ) : \"\"\" Accepts a value up to the specified limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length longer than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length > self . limit : raise ValueError ( \" '{0}' must be longer than {1} \" . format ( value , self . limit )) return value","title":"longer_than"},{"location":"reference/hug/types/#ancestors-in-mro_29","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#mapping_1","text":"class ( value_map ) View Source class Mapping ( OneOf ) : \"\"\" Ensures the value is one of an acceptable set of values mapping those values to a Python equivelent \"\"\" __slots__ = ( \" value_map \" , ) def __init__ ( self , value_map ) : self . value_map = value_map self . values = value_map . keys () @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return self . value_map [ value ]","title":"mapping"},{"location":"reference/hug/types/#ancestors-in-mro_30","text":"hug.types.OneOf hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#multi_1","text":"class ( * types ) View Source class Multi ( Type ) : \"\"\" Enables accepting one of multiple type methods \"\"\" __slots__ = ( \" types \" , ) def __init__ ( self , * types ) : self . types = types @ property def __doc__ ( self ) : type_strings = ( type_method . __doc__ for type_method in self . types ) return \" Accepts any of the following value types:{0} \\n \" . format ( \" \\n - \" . join ( type_strings )) def __call__ ( self , value ) : for type_method in self . types : try : return type_method ( value ) except BaseException : pass raise ValueError ( self . __doc__ )","title":"multi"},{"location":"reference/hug/types/#ancestors-in-mro_31","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#one_of","text":"class ( values ) View Source class OneOf ( Type ) : \"\"\" Ensures the value is within a set of acceptable values \"\"\" __slots__ = ( \" values \" , ) def __init__ ( self , values ) : self . values = values @ property def __doc__ ( self ) : return \" Accepts one of the following values: ({0}) \" . format ( \" | \" . join ( self . values )) def __call__ ( self , value ) : if not value in self . values : raise KeyError ( \" Invalid value passed. The accepted values are: ({0}) \" . format ( \" | \" . join ( self . values )) ) return value","title":"one_of"},{"location":"reference/hug/types/#ancestors-in-mro_32","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/types/#descendants_3","text":"hug.types.Mapping","title":"Descendants"},{"location":"reference/hug/types/#shorter_than","text":"class ( limit , convert =< hug . types . Text object at 0x7f06769bbac8 > ) View Source class ShorterThan ( Type ) : \"\"\" Accepts a text value shorter than the specified length limit \"\"\" __slots__ = ( \" limit \" , \" convert \" ) def __init__ ( self , limit , convert = text ) : self . limit = limit self . convert = convert @ property def __doc__ ( self ) : return \" {0} with a length of no more than {1} \" . format ( self . convert . __doc__ , self . limit ) def __call__ ( self , value ) : value = self . convert ( value ) length = len ( value ) if not length < self . limit : raise ValueError ( \" '{0}' is longer then the allowed limit of {1} \" . format ( value , self . limit ) ) return value","title":"shorter_than"},{"location":"reference/hug/types/#ancestors-in-mro_33","text":"hug.types.Type","title":"Ancestors (in MRO)"},{"location":"reference/hug/use/","text":"Module hug.use hug/use.py Provides a mechanism for using external hug APIs both locally or remotely in a seamless fashion Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/use.py Provides a mechanism for using external hug APIs both locally or remotely in a seamless fashion Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import re import socket from collections import namedtuple from io import BytesIO from queue import Queue import falcon import requests import hug . _empty as empty from hug . api import API from hug . defaults import input_format from hug . format import parse_content_type Response = namedtuple ( \" Response \" , ( \" data \" , \" status_code \" , \" headers \" )) Request = namedtuple ( \" Request \" , ( \" content_length \" , \" stream \" , \" params \" )) class Service ( object ) : \"\"\" Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface \"\"\" __slots__ = ( \" timeout \" , \" raise_on \" , \" version \" ) def __init__ ( self , version = None , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : self . version = version self . timeout = timeout self . raise_on = raise_on if type ( raise_on ) in ( tuple , list ) else ( raise_on , ) def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CALL \" method \"\"\" raise NotImplementedError ( \" Concrete services must define the request method \" ) def get ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" GET \" method \"\"\" return self . request ( \" GET \" , url = url , headers = headers , timeout = timeout , ** params ) def post ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" POST \" method \"\"\" return self . request ( \" POST \" , url = url , headers = headers , timeout = timeout , ** params ) def delete ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" DELETE \" method \"\"\" return self . request ( \" DELETE \" , url = url , headers = headers , timeout = timeout , ** params ) def put ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PUT \" method \"\"\" return self . request ( \" PUT \" , url = url , headers = headers , timeout = timeout , ** params ) def trace ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" TRACE \" method \"\"\" return self . request ( \" TRACE \" , url = url , headers = headers , timeout = timeout , ** params ) def patch ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PATCH \" method \"\"\" return self . request ( \" PATCH \" , url = url , headers = headers , timeout = timeout , ** params ) def options ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" OPTIONS \" method \"\"\" return self . request ( \" OPTIONS \" , url = url , headers = headers , timeout = timeout , ** params ) def head ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" HEAD \" method \"\"\" return self . request ( \" HEAD \" , url = url , headers = headers , timeout = timeout , ** params ) def connect ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CONNECT \" method \"\"\" return self . request ( \" CONNECT \" , url = url , headers = headers , timeout = timeout , ** params ) class HTTP ( Service ) : __slots__ = ( \" endpoint \" , \" session \" , \" json_transport \" ) def __init__ ( self , endpoint , auth = None , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , json_transport = True , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . endpoint = endpoint self . session = requests . Session () self . session . auth = auth self . session . headers . update ( headers ) self . json_transport = json_transport def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : url = \" {0}/{1} \" . format ( self . version , url . lstrip ( \" / \" )) if self . version else url kwargs = { \" json \" if self . json_transport else \" params \" : params } response = self . session . request ( method , self . endpoint + url . format ( url_params ) , headers = headers , ** kwargs ) data = BytesIO ( response . content ) content_type , content_params = parse_content_type ( response . headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) if response . status_code in self . raise_on : raise requests . HTTPError ( \" {0} {1} occured for url: {2} \" . format ( response . status_code , response . reason , url ) ) return Response ( data , response . status_code , response . headers ) class Local ( Service ) : __slots__ = ( \" api \" , \" headers \" ) def __init__ ( self , api , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . api = API ( api ) self . headers = headers def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : function = self . api . http . versioned . get ( self . version , {} ) . get ( url , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( url , None ) if not function : if 404 in self . raise_on : raise requests . HTTPError ( \" 404 Not Found occured for url: {0} \" . format ( url )) return Response ( \" Not Found \" , 404 , { \" content-type \" , \" application/json \" } ) interface = function . interface . http response = falcon . Response () request = Request ( None , None , empty . dict ) context = self . api . context_factory ( api = self . api , api_version = self . version , interface = interface ) interface . set_response_defaults ( response ) params . update ( url_params ) params = interface . gather_parameters ( request , response , context , api_version = self . version , ** params ) errors = interface . validate ( params , context ) if errors : interface . render_errors ( errors , request , response ) else : interface . render_content ( interface . call_function ( params ) , context , request , response ) data = BytesIO ( response . data ) content_type , content_params = parse_content_type ( response . _headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) status_code = int ( \"\" . join ( re . findall ( \" \\d+ \" , response . status ))) if status_code in self . raise_on : raise requests . HTTPError ( \" {0} occured for url: {1} \" . format ( response . status , url )) return Response ( data , status_code , response . _headers ) class Socket ( Service ) : __slots__ = ( \" connection_pool \" , \" timeout \" , \" connection \" , \" send_and_receive \" ) on_unix = getattr ( socket , \" AF_UNIX \" , False ) Connection = namedtuple ( \" Connection \" , ( \" connect_to \" , \" proto \" , \" sockopts \" )) protocols = { \" tcp \" : ( socket . AF_INET , socket . SOCK_STREAM ) , \" udp \" : ( socket . AF_INET , socket . SOCK_DGRAM ) , } streams = set (( \" tcp \" , )) datagrams = set (( \" udp \" , )) inet = set (( \" tcp \" , \" udp \" )) unix = set () if on_unix : protocols . update ( { \" unix_dgram \" : ( socket . AF_UNIX , socket . SOCK_DGRAM ) , \" unix_stream \" : ( socket . AF_UNIX , socket . SOCK_STREAM ) , } ) streams . add ( \" unix_stream \" ) datagrams . add ( \" unix_dgram \" ) unix . update (( \" unix_stream \" , \" unix_dgram \" )) def __init__ ( self , connect_to , proto , version = None , headers = empty . dict , timeout = None , pool = 0 , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) connect_to = tuple ( connect_to ) if proto in Socket . inet else connect_to self . timeout = timeout self . connection = Socket . Connection ( connect_to , proto , set ()) self . connection_pool = Queue ( maxsize = pool if pool else 1 ) if proto in Socket . streams : self . send_and_receive = self . _stream_send_and_receive else : self . send_and_receive = self . _dgram_send_and_receive def settimeout ( self , timeout ) : \"\"\" Set the default timeout \"\"\" self . timeout = timeout def setsockopt ( self , * sockopts ) : \"\"\" Add socket options to set \"\"\" if type ( sockopts [ 0 ] ) in ( list , tuple ) : for sock_opt in sockopts [ 0 ]: level , option , value = sock_opt self . connection . sockopts . add (( level , option , value )) else : level , option , value = sockopts self . connection . sockopts . add (( level , option , value )) def _register_socket ( self ) : \"\"\" Create/Connect socket, apply options \"\"\" _socket = socket . socket ( * Socket . protocols [ self . connection . proto ] ) _socket . settimeout ( self . timeout ) # Reconfigure original socket options . if self . connection . sockopts : for sock_opt in self . connection . sockopts : level , option , value = sock_opt _socket . setsockopt ( level , option , value ) _socket . connect ( self . connection . connect_to ) return _socket def _stream_send_and_receive ( self , _socket , message , * args , ** kwargs ) : \"\"\" TCP/Stream sender and receiver \"\"\" data = BytesIO () _socket_fd = _socket . makefile ( mode = \" rwb \" , encoding = \" utf-8 \" ) _socket_fd . write ( message . encode ( \" utf-8 \" )) _socket_fd . flush () for received in _socket_fd : data . write ( received ) data . seek ( 0 ) _socket_fd . close () return data def _dgram_send_and_receive ( self , _socket , message , buffer_size = 4096 , * args ) : \"\"\" User Datagram Protocol sender and receiver \"\"\" _socket . send ( message . encode ( \" utf-8 \" )) data , address = _socket . recvfrom ( buffer_size ) return BytesIO ( data ) def request ( self , message , timeout = False , * args , ** kwargs ) : \"\"\" Populate connection pool, send message, return BytesIO, and cleanup \"\"\" if not self . connection_pool . full () : self . connection_pool . put ( self . _register_socket ()) _socket = self . connection_pool . get () # setting timeout to None enables the socket to block . if timeout or timeout is None : _socket . settimeout ( timeout ) data = self . send_and_receive ( _socket , message , * args , ** kwargs ) if self . connection . proto in Socket . streams : _socket . shutdown ( socket . SHUT_RDWR ) return Response ( data , None , None ) Variables input_format Classes HTTP class ( endpoint , auth = None , version = None , headers = mappingproxy ({}), timeout = None , raise_on = ( 500 ,), json_transport = True , ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class HTTP ( Service ) : __slots__ = ( \" endpoint \" , \" session \" , \" json_transport \" ) def __init__ ( self , endpoint , auth = None , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , json_transport = True , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . endpoint = endpoint self . session = requests . Session () self . session . auth = auth self . session . headers . update ( headers ) self . json_transport = json_transport def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : url = \" {0}/{1} \" . format ( self . version , url . lstrip ( \" / \" )) if self . version else url kwargs = { \" json \" if self . json_transport else \" params \" : params } response = self . session . request ( method , self . endpoint + url . format ( url_params ) , headers = headers , ** kwargs ) data = BytesIO ( response . content ) content_type , content_params = parse_content_type ( response . headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) if response . status_code in self . raise_on : raise requests . HTTPError ( \" {0} {1} occured for url: {2} \" . format ( response . status_code , response . reason , url ) ) return Response ( data , response . status_code , response . headers ) Ancestors (in MRO) hug.use.Service Local class ( api , version = None , headers = mappingproxy ({}), timeout = None , raise_on = ( 500 ,), ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class Local ( Service ) : __slots__ = ( \" api \" , \" headers \" ) def __init__ ( self , api , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . api = API ( api ) self . headers = headers def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : function = self . api . http . versioned . get ( self . version , {} ) . get ( url , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( url , None ) if not function : if 404 in self . raise_on : raise requests . HTTPError ( \" 404 Not Found occured for url: {0} \" . format ( url )) return Response ( \" Not Found \" , 404 , { \" content-type \" , \" application/json \" } ) interface = function . interface . http response = falcon . Response () request = Request ( None , None , empty . dict ) context = self . api . context_factory ( api = self . api , api_version = self . version , interface = interface ) interface . set_response_defaults ( response ) params . update ( url_params ) params = interface . gather_parameters ( request , response , context , api_version = self . version , ** params ) errors = interface . validate ( params , context ) if errors : interface . render_errors ( errors , request , response ) else : interface . render_content ( interface . call_function ( params ) , context , request , response ) data = BytesIO ( response . data ) content_type , content_params = parse_content_type ( response . _headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) status_code = int ( \"\" . join ( re . findall ( \" \\d+ \" , response . status ))) if status_code in self . raise_on : raise requests . HTTPError ( \" {0} occured for url: {1} \" . format ( response . status , url )) return Response ( data , status_code , response . _headers ) Ancestors (in MRO) hug.use.Service Request class ( / , * args , ** kwargs ) Request(content_length, stream, params) Ancestors (in MRO) builtins.tuple Response class ( / , * args , ** kwargs ) Response(data, status_code, headers) Ancestors (in MRO) builtins.tuple Service class ( version = None , timeout = None , raise_on = ( 500 ,), ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class Service ( object ) : \"\"\" Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface \"\"\" __slots__ = ( \" timeout \" , \" raise_on \" , \" version \" ) def __init__ ( self , version = None , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : self . version = version self . timeout = timeout self . raise_on = raise_on if type ( raise_on ) in ( tuple , list ) else ( raise_on , ) def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CALL \" method \"\"\" raise NotImplementedError ( \" Concrete services must define the request method \" ) def get ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" GET \" method \"\"\" return self . request ( \" GET \" , url = url , headers = headers , timeout = timeout , ** params ) def post ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" POST \" method \"\"\" return self . request ( \" POST \" , url = url , headers = headers , timeout = timeout , ** params ) def delete ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" DELETE \" method \"\"\" return self . request ( \" DELETE \" , url = url , headers = headers , timeout = timeout , ** params ) def put ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PUT \" method \"\"\" return self . request ( \" PUT \" , url = url , headers = headers , timeout = timeout , ** params ) def trace ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" TRACE \" method \"\"\" return self . request ( \" TRACE \" , url = url , headers = headers , timeout = timeout , ** params ) def patch ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PATCH \" method \"\"\" return self . request ( \" PATCH \" , url = url , headers = headers , timeout = timeout , ** params ) def options ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" OPTIONS \" method \"\"\" return self . request ( \" OPTIONS \" , url = url , headers = headers , timeout = timeout , ** params ) def head ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" HEAD \" method \"\"\" return self . request ( \" HEAD \" , url = url , headers = headers , timeout = timeout , ** params ) def connect ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CONNECT \" method \"\"\" return self . request ( \" CONNECT \" , url = url , headers = headers , timeout = timeout , ** params ) Descendants hug.use.HTTP hug.use.Local hug.use.Socket Socket class ( connect_to , proto , version = None , headers = mappingproxy ({}), timeout = None , pool = 0 , raise_on = ( 500 ,), ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class Socket ( Service ) : __slots__ = ( \" connection_pool \" , \" timeout \" , \" connection \" , \" send_and_receive \" ) on_unix = getattr ( socket , \" AF_UNIX \" , False ) Connection = namedtuple ( \" Connection \" , ( \" connect_to \" , \" proto \" , \" sockopts \" )) protocols = { \" tcp \" : ( socket . AF_INET , socket . SOCK_STREAM ) , \" udp \" : ( socket . AF_INET , socket . SOCK_DGRAM ) , } streams = set (( \" tcp \" , )) datagrams = set (( \" udp \" , )) inet = set (( \" tcp \" , \" udp \" )) unix = set () if on_unix : protocols . update ( { \" unix_dgram \" : ( socket . AF_UNIX , socket . SOCK_DGRAM ) , \" unix_stream \" : ( socket . AF_UNIX , socket . SOCK_STREAM ) , } ) streams . add ( \" unix_stream \" ) datagrams . add ( \" unix_dgram \" ) unix . update (( \" unix_stream \" , \" unix_dgram \" )) def __init__ ( self , connect_to , proto , version = None , headers = empty . dict , timeout = None , pool = 0 , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) connect_to = tuple ( connect_to ) if proto in Socket . inet else connect_to self . timeout = timeout self . connection = Socket . Connection ( connect_to , proto , set ()) self . connection_pool = Queue ( maxsize = pool if pool else 1 ) if proto in Socket . streams : self . send_and_receive = self . _stream_send_and_receive else : self . send_and_receive = self . _dgram_send_and_receive def settimeout ( self , timeout ) : \"\"\" Set the default timeout \"\"\" self . timeout = timeout def setsockopt ( self , * sockopts ) : \"\"\" Add socket options to set \"\"\" if type ( sockopts [ 0 ] ) in ( list , tuple ) : for sock_opt in sockopts [ 0 ]: level , option , value = sock_opt self . connection . sockopts . add (( level , option , value )) else : level , option , value = sockopts self . connection . sockopts . add (( level , option , value )) def _register_socket ( self ) : \"\"\" Create/Connect socket, apply options \"\"\" _socket = socket . socket ( * Socket . protocols [ self . connection . proto ] ) _socket . settimeout ( self . timeout ) # Reconfigure original socket options . if self . connection . sockopts : for sock_opt in self . connection . sockopts : level , option , value = sock_opt _socket . setsockopt ( level , option , value ) _socket . connect ( self . connection . connect_to ) return _socket def _stream_send_and_receive ( self , _socket , message , * args , ** kwargs ) : \"\"\" TCP/Stream sender and receiver \"\"\" data = BytesIO () _socket_fd = _socket . makefile ( mode = \" rwb \" , encoding = \" utf-8 \" ) _socket_fd . write ( message . encode ( \" utf-8 \" )) _socket_fd . flush () for received in _socket_fd : data . write ( received ) data . seek ( 0 ) _socket_fd . close () return data def _dgram_send_and_receive ( self , _socket , message , buffer_size = 4096 , * args ) : \"\"\" User Datagram Protocol sender and receiver \"\"\" _socket . send ( message . encode ( \" utf-8 \" )) data , address = _socket . recvfrom ( buffer_size ) return BytesIO ( data ) def request ( self , message , timeout = False , * args , ** kwargs ) : \"\"\" Populate connection pool, send message, return BytesIO, and cleanup \"\"\" if not self . connection_pool . full () : self . connection_pool . put ( self . _register_socket ()) _socket = self . connection_pool . get () # setting timeout to None enables the socket to block . if timeout or timeout is None : _socket . settimeout ( timeout ) data = self . send_and_receive ( _socket , message , * args , ** kwargs ) if self . connection . proto in Socket . streams : _socket . shutdown ( socket . SHUT_RDWR ) return Response ( data , None , None ) Ancestors (in MRO) hug.use.Service Class variables Connection datagrams inet on_unix protocols streams unix","title":"Use"},{"location":"reference/hug/use/#module-huguse","text":"hug/use.py Provides a mechanism for using external hug APIs both locally or remotely in a seamless fashion Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/use.py Provides a mechanism for using external hug APIs both locally or remotely in a seamless fashion Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import import re import socket from collections import namedtuple from io import BytesIO from queue import Queue import falcon import requests import hug . _empty as empty from hug . api import API from hug . defaults import input_format from hug . format import parse_content_type Response = namedtuple ( \" Response \" , ( \" data \" , \" status_code \" , \" headers \" )) Request = namedtuple ( \" Request \" , ( \" content_length \" , \" stream \" , \" params \" )) class Service ( object ) : \"\"\" Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface \"\"\" __slots__ = ( \" timeout \" , \" raise_on \" , \" version \" ) def __init__ ( self , version = None , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : self . version = version self . timeout = timeout self . raise_on = raise_on if type ( raise_on ) in ( tuple , list ) else ( raise_on , ) def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CALL \" method \"\"\" raise NotImplementedError ( \" Concrete services must define the request method \" ) def get ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" GET \" method \"\"\" return self . request ( \" GET \" , url = url , headers = headers , timeout = timeout , ** params ) def post ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" POST \" method \"\"\" return self . request ( \" POST \" , url = url , headers = headers , timeout = timeout , ** params ) def delete ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" DELETE \" method \"\"\" return self . request ( \" DELETE \" , url = url , headers = headers , timeout = timeout , ** params ) def put ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PUT \" method \"\"\" return self . request ( \" PUT \" , url = url , headers = headers , timeout = timeout , ** params ) def trace ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" TRACE \" method \"\"\" return self . request ( \" TRACE \" , url = url , headers = headers , timeout = timeout , ** params ) def patch ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PATCH \" method \"\"\" return self . request ( \" PATCH \" , url = url , headers = headers , timeout = timeout , ** params ) def options ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" OPTIONS \" method \"\"\" return self . request ( \" OPTIONS \" , url = url , headers = headers , timeout = timeout , ** params ) def head ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" HEAD \" method \"\"\" return self . request ( \" HEAD \" , url = url , headers = headers , timeout = timeout , ** params ) def connect ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CONNECT \" method \"\"\" return self . request ( \" CONNECT \" , url = url , headers = headers , timeout = timeout , ** params ) class HTTP ( Service ) : __slots__ = ( \" endpoint \" , \" session \" , \" json_transport \" ) def __init__ ( self , endpoint , auth = None , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , json_transport = True , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . endpoint = endpoint self . session = requests . Session () self . session . auth = auth self . session . headers . update ( headers ) self . json_transport = json_transport def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : url = \" {0}/{1} \" . format ( self . version , url . lstrip ( \" / \" )) if self . version else url kwargs = { \" json \" if self . json_transport else \" params \" : params } response = self . session . request ( method , self . endpoint + url . format ( url_params ) , headers = headers , ** kwargs ) data = BytesIO ( response . content ) content_type , content_params = parse_content_type ( response . headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) if response . status_code in self . raise_on : raise requests . HTTPError ( \" {0} {1} occured for url: {2} \" . format ( response . status_code , response . reason , url ) ) return Response ( data , response . status_code , response . headers ) class Local ( Service ) : __slots__ = ( \" api \" , \" headers \" ) def __init__ ( self , api , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . api = API ( api ) self . headers = headers def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : function = self . api . http . versioned . get ( self . version , {} ) . get ( url , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( url , None ) if not function : if 404 in self . raise_on : raise requests . HTTPError ( \" 404 Not Found occured for url: {0} \" . format ( url )) return Response ( \" Not Found \" , 404 , { \" content-type \" , \" application/json \" } ) interface = function . interface . http response = falcon . Response () request = Request ( None , None , empty . dict ) context = self . api . context_factory ( api = self . api , api_version = self . version , interface = interface ) interface . set_response_defaults ( response ) params . update ( url_params ) params = interface . gather_parameters ( request , response , context , api_version = self . version , ** params ) errors = interface . validate ( params , context ) if errors : interface . render_errors ( errors , request , response ) else : interface . render_content ( interface . call_function ( params ) , context , request , response ) data = BytesIO ( response . data ) content_type , content_params = parse_content_type ( response . _headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) status_code = int ( \"\" . join ( re . findall ( \" \\d+ \" , response . status ))) if status_code in self . raise_on : raise requests . HTTPError ( \" {0} occured for url: {1} \" . format ( response . status , url )) return Response ( data , status_code , response . _headers ) class Socket ( Service ) : __slots__ = ( \" connection_pool \" , \" timeout \" , \" connection \" , \" send_and_receive \" ) on_unix = getattr ( socket , \" AF_UNIX \" , False ) Connection = namedtuple ( \" Connection \" , ( \" connect_to \" , \" proto \" , \" sockopts \" )) protocols = { \" tcp \" : ( socket . AF_INET , socket . SOCK_STREAM ) , \" udp \" : ( socket . AF_INET , socket . SOCK_DGRAM ) , } streams = set (( \" tcp \" , )) datagrams = set (( \" udp \" , )) inet = set (( \" tcp \" , \" udp \" )) unix = set () if on_unix : protocols . update ( { \" unix_dgram \" : ( socket . AF_UNIX , socket . SOCK_DGRAM ) , \" unix_stream \" : ( socket . AF_UNIX , socket . SOCK_STREAM ) , } ) streams . add ( \" unix_stream \" ) datagrams . add ( \" unix_dgram \" ) unix . update (( \" unix_stream \" , \" unix_dgram \" )) def __init__ ( self , connect_to , proto , version = None , headers = empty . dict , timeout = None , pool = 0 , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) connect_to = tuple ( connect_to ) if proto in Socket . inet else connect_to self . timeout = timeout self . connection = Socket . Connection ( connect_to , proto , set ()) self . connection_pool = Queue ( maxsize = pool if pool else 1 ) if proto in Socket . streams : self . send_and_receive = self . _stream_send_and_receive else : self . send_and_receive = self . _dgram_send_and_receive def settimeout ( self , timeout ) : \"\"\" Set the default timeout \"\"\" self . timeout = timeout def setsockopt ( self , * sockopts ) : \"\"\" Add socket options to set \"\"\" if type ( sockopts [ 0 ] ) in ( list , tuple ) : for sock_opt in sockopts [ 0 ]: level , option , value = sock_opt self . connection . sockopts . add (( level , option , value )) else : level , option , value = sockopts self . connection . sockopts . add (( level , option , value )) def _register_socket ( self ) : \"\"\" Create/Connect socket, apply options \"\"\" _socket = socket . socket ( * Socket . protocols [ self . connection . proto ] ) _socket . settimeout ( self . timeout ) # Reconfigure original socket options . if self . connection . sockopts : for sock_opt in self . connection . sockopts : level , option , value = sock_opt _socket . setsockopt ( level , option , value ) _socket . connect ( self . connection . connect_to ) return _socket def _stream_send_and_receive ( self , _socket , message , * args , ** kwargs ) : \"\"\" TCP/Stream sender and receiver \"\"\" data = BytesIO () _socket_fd = _socket . makefile ( mode = \" rwb \" , encoding = \" utf-8 \" ) _socket_fd . write ( message . encode ( \" utf-8 \" )) _socket_fd . flush () for received in _socket_fd : data . write ( received ) data . seek ( 0 ) _socket_fd . close () return data def _dgram_send_and_receive ( self , _socket , message , buffer_size = 4096 , * args ) : \"\"\" User Datagram Protocol sender and receiver \"\"\" _socket . send ( message . encode ( \" utf-8 \" )) data , address = _socket . recvfrom ( buffer_size ) return BytesIO ( data ) def request ( self , message , timeout = False , * args , ** kwargs ) : \"\"\" Populate connection pool, send message, return BytesIO, and cleanup \"\"\" if not self . connection_pool . full () : self . connection_pool . put ( self . _register_socket ()) _socket = self . connection_pool . get () # setting timeout to None enables the socket to block . if timeout or timeout is None : _socket . settimeout ( timeout ) data = self . send_and_receive ( _socket , message , * args , ** kwargs ) if self . connection . proto in Socket . streams : _socket . shutdown ( socket . SHUT_RDWR ) return Response ( data , None , None )","title":"Module hug.use"},{"location":"reference/hug/use/#variables","text":"input_format","title":"Variables"},{"location":"reference/hug/use/#classes","text":"","title":"Classes"},{"location":"reference/hug/use/#http","text":"class ( endpoint , auth = None , version = None , headers = mappingproxy ({}), timeout = None , raise_on = ( 500 ,), json_transport = True , ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class HTTP ( Service ) : __slots__ = ( \" endpoint \" , \" session \" , \" json_transport \" ) def __init__ ( self , endpoint , auth = None , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , json_transport = True , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . endpoint = endpoint self . session = requests . Session () self . session . auth = auth self . session . headers . update ( headers ) self . json_transport = json_transport def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : url = \" {0}/{1} \" . format ( self . version , url . lstrip ( \" / \" )) if self . version else url kwargs = { \" json \" if self . json_transport else \" params \" : params } response = self . session . request ( method , self . endpoint + url . format ( url_params ) , headers = headers , ** kwargs ) data = BytesIO ( response . content ) content_type , content_params = parse_content_type ( response . headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) if response . status_code in self . raise_on : raise requests . HTTPError ( \" {0} {1} occured for url: {2} \" . format ( response . status_code , response . reason , url ) ) return Response ( data , response . status_code , response . headers )","title":"HTTP"},{"location":"reference/hug/use/#ancestors-in-mro","text":"hug.use.Service","title":"Ancestors (in MRO)"},{"location":"reference/hug/use/#local","text":"class ( api , version = None , headers = mappingproxy ({}), timeout = None , raise_on = ( 500 ,), ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class Local ( Service ) : __slots__ = ( \" api \" , \" headers \" ) def __init__ ( self , api , version = None , headers = empty . dict , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) self . api = API ( api ) self . headers = headers def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : function = self . api . http . versioned . get ( self . version , {} ) . get ( url , None ) if not function : function = self . api . http . versioned . get ( None , {} ) . get ( url , None ) if not function : if 404 in self . raise_on : raise requests . HTTPError ( \" 404 Not Found occured for url: {0} \" . format ( url )) return Response ( \" Not Found \" , 404 , { \" content-type \" , \" application/json \" } ) interface = function . interface . http response = falcon . Response () request = Request ( None , None , empty . dict ) context = self . api . context_factory ( api = self . api , api_version = self . version , interface = interface ) interface . set_response_defaults ( response ) params . update ( url_params ) params = interface . gather_parameters ( request , response , context , api_version = self . version , ** params ) errors = interface . validate ( params , context ) if errors : interface . render_errors ( errors , request , response ) else : interface . render_content ( interface . call_function ( params ) , context , request , response ) data = BytesIO ( response . data ) content_type , content_params = parse_content_type ( response . _headers . get ( \" content-type \" , \"\" )) if content_type in input_format : data = input_format [ content_type ] ( data , ** content_params ) status_code = int ( \"\" . join ( re . findall ( \" \\d+ \" , response . status ))) if status_code in self . raise_on : raise requests . HTTPError ( \" {0} occured for url: {1} \" . format ( response . status , url )) return Response ( data , status_code , response . _headers )","title":"Local"},{"location":"reference/hug/use/#ancestors-in-mro_1","text":"hug.use.Service","title":"Ancestors (in MRO)"},{"location":"reference/hug/use/#request","text":"class ( / , * args , ** kwargs ) Request(content_length, stream, params)","title":"Request"},{"location":"reference/hug/use/#ancestors-in-mro_2","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/hug/use/#response","text":"class ( / , * args , ** kwargs ) Response(data, status_code, headers)","title":"Response"},{"location":"reference/hug/use/#ancestors-in-mro_3","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/hug/use/#service","text":"class ( version = None , timeout = None , raise_on = ( 500 ,), ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class Service ( object ) : \"\"\" Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface \"\"\" __slots__ = ( \" timeout \" , \" raise_on \" , \" version \" ) def __init__ ( self , version = None , timeout = None , raise_on = ( 500 , ) , ** kwargs ) : self . version = version self . timeout = timeout self . raise_on = raise_on if type ( raise_on ) in ( tuple , list ) else ( raise_on , ) def request ( self , method , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CALL \" method \"\"\" raise NotImplementedError ( \" Concrete services must define the request method \" ) def get ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" GET \" method \"\"\" return self . request ( \" GET \" , url = url , headers = headers , timeout = timeout , ** params ) def post ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" POST \" method \"\"\" return self . request ( \" POST \" , url = url , headers = headers , timeout = timeout , ** params ) def delete ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" DELETE \" method \"\"\" return self . request ( \" DELETE \" , url = url , headers = headers , timeout = timeout , ** params ) def put ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PUT \" method \"\"\" return self . request ( \" PUT \" , url = url , headers = headers , timeout = timeout , ** params ) def trace ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" TRACE \" method \"\"\" return self . request ( \" TRACE \" , url = url , headers = headers , timeout = timeout , ** params ) def patch ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" PATCH \" method \"\"\" return self . request ( \" PATCH \" , url = url , headers = headers , timeout = timeout , ** params ) def options ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" OPTIONS \" method \"\"\" return self . request ( \" OPTIONS \" , url = url , headers = headers , timeout = timeout , ** params ) def head ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" HEAD \" method \"\"\" return self . request ( \" HEAD \" , url = url , headers = headers , timeout = timeout , ** params ) def connect ( self , url , url_params = empty . dict , headers = empty . dict , timeout = None , ** params ) : \"\"\" Calls the service at the specified URL using the \" CONNECT \" method \"\"\" return self . request ( \" CONNECT \" , url = url , headers = headers , timeout = timeout , ** params )","title":"Service"},{"location":"reference/hug/use/#descendants","text":"hug.use.HTTP hug.use.Local hug.use.Socket","title":"Descendants"},{"location":"reference/hug/use/#socket","text":"class ( connect_to , proto , version = None , headers = mappingproxy ({}), timeout = None , pool = 0 , raise_on = ( 500 ,), ** kwargs ) Defines the base concept of a consumed service. This is to enable encapsulating the logic of calling a service so usage can be independant of the interface View Source class Socket ( Service ) : __slots__ = ( \" connection_pool \" , \" timeout \" , \" connection \" , \" send_and_receive \" ) on_unix = getattr ( socket , \" AF_UNIX \" , False ) Connection = namedtuple ( \" Connection \" , ( \" connect_to \" , \" proto \" , \" sockopts \" )) protocols = { \" tcp \" : ( socket . AF_INET , socket . SOCK_STREAM ) , \" udp \" : ( socket . AF_INET , socket . SOCK_DGRAM ) , } streams = set (( \" tcp \" , )) datagrams = set (( \" udp \" , )) inet = set (( \" tcp \" , \" udp \" )) unix = set () if on_unix : protocols . update ( { \" unix_dgram \" : ( socket . AF_UNIX , socket . SOCK_DGRAM ) , \" unix_stream \" : ( socket . AF_UNIX , socket . SOCK_STREAM ) , } ) streams . add ( \" unix_stream \" ) datagrams . add ( \" unix_dgram \" ) unix . update (( \" unix_stream \" , \" unix_dgram \" )) def __init__ ( self , connect_to , proto , version = None , headers = empty . dict , timeout = None , pool = 0 , raise_on = ( 500 , ) , ** kwargs ) : super () . __init__ ( timeout = timeout , raise_on = raise_on , version = version , ** kwargs ) connect_to = tuple ( connect_to ) if proto in Socket . inet else connect_to self . timeout = timeout self . connection = Socket . Connection ( connect_to , proto , set ()) self . connection_pool = Queue ( maxsize = pool if pool else 1 ) if proto in Socket . streams : self . send_and_receive = self . _stream_send_and_receive else : self . send_and_receive = self . _dgram_send_and_receive def settimeout ( self , timeout ) : \"\"\" Set the default timeout \"\"\" self . timeout = timeout def setsockopt ( self , * sockopts ) : \"\"\" Add socket options to set \"\"\" if type ( sockopts [ 0 ] ) in ( list , tuple ) : for sock_opt in sockopts [ 0 ]: level , option , value = sock_opt self . connection . sockopts . add (( level , option , value )) else : level , option , value = sockopts self . connection . sockopts . add (( level , option , value )) def _register_socket ( self ) : \"\"\" Create/Connect socket, apply options \"\"\" _socket = socket . socket ( * Socket . protocols [ self . connection . proto ] ) _socket . settimeout ( self . timeout ) # Reconfigure original socket options . if self . connection . sockopts : for sock_opt in self . connection . sockopts : level , option , value = sock_opt _socket . setsockopt ( level , option , value ) _socket . connect ( self . connection . connect_to ) return _socket def _stream_send_and_receive ( self , _socket , message , * args , ** kwargs ) : \"\"\" TCP/Stream sender and receiver \"\"\" data = BytesIO () _socket_fd = _socket . makefile ( mode = \" rwb \" , encoding = \" utf-8 \" ) _socket_fd . write ( message . encode ( \" utf-8 \" )) _socket_fd . flush () for received in _socket_fd : data . write ( received ) data . seek ( 0 ) _socket_fd . close () return data def _dgram_send_and_receive ( self , _socket , message , buffer_size = 4096 , * args ) : \"\"\" User Datagram Protocol sender and receiver \"\"\" _socket . send ( message . encode ( \" utf-8 \" )) data , address = _socket . recvfrom ( buffer_size ) return BytesIO ( data ) def request ( self , message , timeout = False , * args , ** kwargs ) : \"\"\" Populate connection pool, send message, return BytesIO, and cleanup \"\"\" if not self . connection_pool . full () : self . connection_pool . put ( self . _register_socket ()) _socket = self . connection_pool . get () # setting timeout to None enables the socket to block . if timeout or timeout is None : _socket . settimeout ( timeout ) data = self . send_and_receive ( _socket , message , * args , ** kwargs ) if self . connection . proto in Socket . streams : _socket . shutdown ( socket . SHUT_RDWR ) return Response ( data , None , None )","title":"Socket"},{"location":"reference/hug/use/#ancestors-in-mro_4","text":"hug.use.Service","title":"Ancestors (in MRO)"},{"location":"reference/hug/use/#class-variables","text":"Connection datagrams inet on_unix protocols streams unix","title":"Class variables"},{"location":"reference/hug/validate/","text":"Module hug.validate hug/validate.py Defines hugs built-in validation methods Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/validate.py Defines hugs built - in validation methods Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import def all ( * validators ) : \"\"\" Validation only succeeds if all passed in validators return no errors \"\"\" def validate_all ( fields ) : for validator in validators : errors = validator ( fields ) if errors : return errors validate_all . __doc__ = \" and \" . join ( validator . __doc__ for validator in validators ) return validate_all def any ( * validators ) : \"\"\" If any of the specified validators pass the validation succeeds \"\"\" def validate_any ( fields ) : errors = {} for validator in validators : validation_errors = validator ( fields ) if not validation_errors : return errors . update ( validation_errors ) return errors validate_any . __doc__ = \" or \" . join ( validator . __doc__ for validator in validators ) return validate_any def contains_one_of ( * fields ) : \"\"\" Enables ensuring that one of multiple optional fields is set \"\"\" message = \" Must contain any one of the following fields: {0} \" . format ( \" , \" . join ( fields )) def check_contains ( endpoint_fields ) : for field in fields : if field in endpoint_fields : return errors = {} for field in fields : errors [ field ] = \" one of these must have a value \" return errors check_contains . __doc__ = message return check_contains Functions all def ( * validators ) Validation only succeeds if all passed in validators return no errors View Source def all ( * validators ) : \"\"\" Validation only succeeds if all passed in validators return no errors \"\"\" def validate_all ( fields ) : for validator in validators : errors = validator ( fields ) if errors : return errors validate_all . __doc__ = \" and \" . join ( validator . __doc__ for validator in validators ) return validate_all any def ( * validators ) If any of the specified validators pass the validation succeeds View Source def any ( * validators ) : \"\"\" If any of the specified validators pass the validation succeeds \"\"\" def validate_any ( fields ) : errors = {} for validator in validators : validation_errors = validator ( fields ) if not validation_errors : return errors . update ( validation_errors ) return errors validate_any . __doc__ = \" or \" . join ( validator . __doc__ for validator in validators ) return validate_any contains_one_of def ( * fields ) Enables ensuring that one of multiple optional fields is set View Source def contains_one_of ( * fields ) : \"\"\" Enables ensuring that one of multiple optional fields is set \"\"\" message = \" Must contain any one of the following fields: {0} \" . format ( \" , \" . join ( fields )) def check_contains ( endpoint_fields ) : for field in fields : if field in endpoint_fields : return errors = {} for field in fields : errors [ field ] = \" one of these must have a value \" return errors check_contains . __doc__ = message return check_contains","title":"Validate"},{"location":"reference/hug/validate/#module-hugvalidate","text":"hug/validate.py Defines hugs built-in validation methods Copyright (C) 2016 Timothy Edmund Crosley Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. View Source \"\"\" hug/validate.py Defines hugs built - in validation methods Copyright ( C ) 2016 Timothy Edmund Crosley Permission is hereby granted , free of charge , to any person obtaining a copy of this software and associated documentation files ( the \" Software \" ) , to deal in the Software without restriction , including without limitation the rights to use , copy , modify , merge , publish , distribute , sublicense , and / or sell copies of the Software , and to permit persons to whom the Software is furnished to do so , subject to the following conditions : The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software . THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . \"\"\" from __future__ import absolute_import def all ( * validators ) : \"\"\" Validation only succeeds if all passed in validators return no errors \"\"\" def validate_all ( fields ) : for validator in validators : errors = validator ( fields ) if errors : return errors validate_all . __doc__ = \" and \" . join ( validator . __doc__ for validator in validators ) return validate_all def any ( * validators ) : \"\"\" If any of the specified validators pass the validation succeeds \"\"\" def validate_any ( fields ) : errors = {} for validator in validators : validation_errors = validator ( fields ) if not validation_errors : return errors . update ( validation_errors ) return errors validate_any . __doc__ = \" or \" . join ( validator . __doc__ for validator in validators ) return validate_any def contains_one_of ( * fields ) : \"\"\" Enables ensuring that one of multiple optional fields is set \"\"\" message = \" Must contain any one of the following fields: {0} \" . format ( \" , \" . join ( fields )) def check_contains ( endpoint_fields ) : for field in fields : if field in endpoint_fields : return errors = {} for field in fields : errors [ field ] = \" one of these must have a value \" return errors check_contains . __doc__ = message return check_contains","title":"Module hug.validate"},{"location":"reference/hug/validate/#functions","text":"","title":"Functions"},{"location":"reference/hug/validate/#all","text":"def ( * validators ) Validation only succeeds if all passed in validators return no errors View Source def all ( * validators ) : \"\"\" Validation only succeeds if all passed in validators return no errors \"\"\" def validate_all ( fields ) : for validator in validators : errors = validator ( fields ) if errors : return errors validate_all . __doc__ = \" and \" . join ( validator . __doc__ for validator in validators ) return validate_all","title":"all"},{"location":"reference/hug/validate/#any","text":"def ( * validators ) If any of the specified validators pass the validation succeeds View Source def any ( * validators ) : \"\"\" If any of the specified validators pass the validation succeeds \"\"\" def validate_any ( fields ) : errors = {} for validator in validators : validation_errors = validator ( fields ) if not validation_errors : return errors . update ( validation_errors ) return errors validate_any . __doc__ = \" or \" . join ( validator . __doc__ for validator in validators ) return validate_any","title":"any"},{"location":"reference/hug/validate/#contains_one_of","text":"def ( * fields ) Enables ensuring that one of multiple optional fields is set View Source def contains_one_of ( * fields ) : \"\"\" Enables ensuring that one of multiple optional fields is set \"\"\" message = \" Must contain any one of the following fields: {0} \" . format ( \" , \" . join ( fields )) def check_contains ( endpoint_fields ) : for field in fields : if field in endpoint_fields : return errors = {} for field in fields : errors [ field ] = \" one of these must have a value \" return errors check_contains . __doc__ = message return check_contains","title":"contains_one_of"},{"location":"venv/lib/python3.7/site-packages/Markdown-3.1.1.dist-info/LICENSE/","text":"Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Python Markdown Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE PYTHON MARKDOWN PROJECT ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANY CONTRIBUTORS TO THE PYTHON MARKDOWN PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/","text":"pdoc extracts documentation of: modules (including submodules), functions (including methods, properties, coroutines ...), classes, and variables (including globals, class variables, and instance variables). Documentation is extracted from live objects' docstrings using Python's __doc__ attribute 1 . Documentation for variables is found by examining objects' abstract syntax trees. What objects are documented? pdoc only extracts public API documentation. 2 All objects (modules, functions, classes, variables) are only considered public if their identifiers don't begin with an underscore ( _ ). 3 In addition, if a module defines __all__ , then only the identifiers contained in this list will be considered public. Otherwise, a module's global identifiers are considered public only if they don't begin with an underscore and are defined in this exact module (i.e. not imported from somewhere else). By transitivity, sub-objects of non-public objects (e.g. submodules of non-public modules, methods of non-public classes etc.) are not public and thus not documented. Where does pdoc get documentation from? In Python, objects like modules, functions, classes, and methods have a special attribute __doc__ which contains that object's documentation string ( docstring ). For example, the following code defines a function with a docstring and shows how to access its contents: >>> def test (): ... \"\"\"This is a docstring.\"\"\" ... pass ... >>> test . __doc__ 'This is a docstring.' It's pretty much the same with classes and modules. See PEP-257 for Python docstring conventions. These docstrings are set as descriptions for each module, class, function, and method listed in the documentation produced by pdoc . pdoc extends the standard use of docstrings in Python in two important ways: by allowing methods to inherit docstrings, and by introducing syntax for docstrings for variables. Docstrings inheritance pdoc considers methods' docstrings inherited from superclass methods', following the normal class inheritance patterns. Consider the following code example: >>> class A : ... def test ( self ) : ... \"\"\" Docstring for A. \"\"\" ... pass ... >>> class B ( A ) : ... def test ( self ) : ... pass ... >>> A . test . __doc__ ' Docstring for A. ' >>> B . test . __doc__ None In Python, the docstring for B.test doesn't exist, even though a docstring was defined for A.test . When pdoc generates documentation for the code such as above, it will automatically attach the docstring for A.test to B.test if B.test does not define its own docstring. In the default HTML template, such inherited docstrings are greyed out. Docstrings for variables Python by itself doesn't allow docstrings attached to variables . However, pdoc supports docstrings attached to module (or global) variables, class variables, and object instance variables; all in the same way as proposed in PEP-224 , with a docstring following the variable assignment. For example: module_variable = 1 \"\"\" Docstring for module_variable. \"\"\" class C : class_variable = 2 \"\"\" Docstring for class_variable. \"\"\" def __init__ ( self ) : self . variable = 3 \"\"\" Docstring for instance variable. \"\"\" While the resulting variables have no __doc__ attribute, pdoc compensates by reading the source code (when available) and parsing the syntax tree. By convention, variables defined in a class' __init__ method and attached to self are considered and documented as instance variables. Class and instance variables can also inherit docstrings . Overriding docstrings with __pdoc__ Docstrings for objects can be disabled or overridden with a special module-level dictionary __pdoc__ . The keys should be string identifiers within the scope of the module or, alternatively, fully-qualified reference names. E.g. for instance variable self.variable of class C , its module-level identifier is 'C.variable' . If __pdoc__[key] = False , then key (and its members) will be excluded from the documentation of the module. Alternatively, the values of __pdoc__ should be the overriding docstrings. This particular feature is useful when there's no feasible way of attaching a docstring to something. A good example of this is a namedtuple : __pdoc__ = {} Table = namedtuple ( ' Table ' , [ ' types ' , ' names ' , ' rows ' ] ) __pdoc__ [ ' Table.types ' ] = ' Types for each column in the table. ' __pdoc__ [ ' Table.names ' ] = ' The names of each column in the table. ' __pdoc__ [ ' Table.rows ' ] = ' Lists corresponding to each row in the table. ' pdoc will then show Table as a class with documentation for the types , names and rows members. .. note:: The assignments to __pdoc__ need to be placed where they'll be executed when the module is imported. For example, at the top level of a module or in the definition of a class. Supported docstring formats Currently, pure Markdown (with extensions ), numpydoc , and Google-style docstrings formats are supported, along with some reST directives . Additionally, if latex_math template config option is enabled, LaTeX math syntax is supported when placed between recognized delimiters : \\(...\\) for inline equations and \\[...\\] or $$...$$ for block equations. Note, you need to escape your backslashes in Python docstrings ( \\\\( , \\\\frac{}{} , ...) or, alternatively, use raw string literals . Supported reST directives The following reST directives should work: specific and generic admonitions , .. image:: or .. figure:: (without options), .. include:: , with support for the options: :start-line: , :end-line: , :start-after: and :end-before: . .. math:: .. versionadded:: .. versionchanged:: .. deprecated:: .. todo:: Linking to other identifiers In your documentation, you may refer to other identifiers in your modules. When exporting to HTML, linking is automatically done whenever you surround an identifier with backticks ( ` ). The identifier name must be fully qualified, for example `pdoc.Doc.docstring` is correct (and will link to pdoc.Doc.docstring ) while `Doc.docstring` is not . Command-line interface pdoc includes a feature-rich \"binary\" program for producing HTML and plain text documentation of your modules. For example, to produce HTML documentation of your whole package in subdirectory 'build' of the current directory, using the default HTML template, run: $ pdoc --html --output-dir build my_package To run a local HTTP server while developing your package or writing docstrings for it, run: $ pdoc --http : my_package To re-build documentation as part of your continuous integration (CI) best practice, i.e. ensuring all reference links are correct and up-to-date, make warnings error loudly by settings the environment variable PYTHONWARNINGS before running pdoc: $ export PYTHONWARNINGS = 'error::UserWarning' For brief usage instructions, type: $ pdoc --help Programmatic usage The main entry point is pdoc.Module which wraps a module object and recursively imports and wraps any submodules and their members. After all related modules are wrapped (related modules are those that share the same pdoc.Context ), you need to call pdoc.link_inheritance with the used Context instance to establish class inheritance links. Afterwards, you can use pdoc.Module.html and pdoc.Module.text methods to output documentation in the desired format. For example: import pdoc modules = [ 'a' , 'b' ] # Public submodules are auto-imported context = pdoc . Context () modules = [ pdoc . Module ( mod , context = context ) for mod in modules ] pdoc . link_inheritance ( context ) def recursive_htmls ( mod ): yield mod . name , mod . html () for submod in mod . submodules (): yield from recursive_htmls ( submod ) for mod in modules : for module_name , html in recursive_htmls ( mod ): ... # Process When documenting a single module, you might find functions pdoc.html and pdoc.text handy. For importing arbitrary modules/files, use pdoc.import_module . Alternatively, use the runnable script included with this package. Custom templates To override the built-in HTML/CSS and plain text templates, copy the relevant templates from pdoc/templates directory into a directory of your choosing and edit them. When you run pdoc command afterwards, pass the directory path as a parameter to the --template-dir switch. .. tip:: If you find you only need to apply minor alterations to the HTML template, see if you can do so by overriding just some of the following, placeholder sub-templates: * [ _config . mako_ ]: Basic template configuration , affects the way templates are rendered . * _head . mako_ : Included just before ` </ head > `. Best for adding resources and styles . * _logo . mako_ : Included at the very top of the navigation sidebar . Empty by default . * _credits . mako_ : Included in the footer , right before pdoc version string . See [ default template files ] for reference . .. tip:: You can also alter individual config.mako preferences using the --config command-line switch. If working with pdoc programmatically, prepend the directory with modified templates into the directories list of the pdoc.tpl_lookup object. Compatibility pdoc requires Python 3.5+. The last version to support Python 2.x is pdoc3 0.3.x . Contributing pdoc is on GitHub . Bug reports and pull requests are welcome. License pdoc is licensed under the terms of GNU AGPL-3.0 or later, meaning you can use it for any reasonable purpose and remain in complete ownership of all the documentation you produce, but you are also encouraged to make sure any upgrades to pdoc itself find their way back to the community. Documented modules are executed in order to provide __doc__ attributes. Any non-fenced global code in imported modules will affect the current environment. \u21a9 Here, public API refers to the API that is made available to your project end-users, not the public API e.g. of a private class that can be reasonably extended elsewhere by your project developers. \u21a9 Prefixing private, implementation-specific objects with an underscore is a common convention . \u21a9","title":"Documentation"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#what-objects-are-documented","text":"pdoc only extracts public API documentation. 2 All objects (modules, functions, classes, variables) are only considered public if their identifiers don't begin with an underscore ( _ ). 3 In addition, if a module defines __all__ , then only the identifiers contained in this list will be considered public. Otherwise, a module's global identifiers are considered public only if they don't begin with an underscore and are defined in this exact module (i.e. not imported from somewhere else). By transitivity, sub-objects of non-public objects (e.g. submodules of non-public modules, methods of non-public classes etc.) are not public and thus not documented.","title":"What objects are documented?"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#where-does-pdoc-get-documentation-from","text":"In Python, objects like modules, functions, classes, and methods have a special attribute __doc__ which contains that object's documentation string ( docstring ). For example, the following code defines a function with a docstring and shows how to access its contents: >>> def test (): ... \"\"\"This is a docstring.\"\"\" ... pass ... >>> test . __doc__ 'This is a docstring.' It's pretty much the same with classes and modules. See PEP-257 for Python docstring conventions. These docstrings are set as descriptions for each module, class, function, and method listed in the documentation produced by pdoc . pdoc extends the standard use of docstrings in Python in two important ways: by allowing methods to inherit docstrings, and by introducing syntax for docstrings for variables.","title":"Where does pdoc get documentation from?"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#docstrings-inheritance","text":"pdoc considers methods' docstrings inherited from superclass methods', following the normal class inheritance patterns. Consider the following code example: >>> class A : ... def test ( self ) : ... \"\"\" Docstring for A. \"\"\" ... pass ... >>> class B ( A ) : ... def test ( self ) : ... pass ... >>> A . test . __doc__ ' Docstring for A. ' >>> B . test . __doc__ None In Python, the docstring for B.test doesn't exist, even though a docstring was defined for A.test . When pdoc generates documentation for the code such as above, it will automatically attach the docstring for A.test to B.test if B.test does not define its own docstring. In the default HTML template, such inherited docstrings are greyed out.","title":"Docstrings inheritance"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#docstrings-for-variables","text":"Python by itself doesn't allow docstrings attached to variables . However, pdoc supports docstrings attached to module (or global) variables, class variables, and object instance variables; all in the same way as proposed in PEP-224 , with a docstring following the variable assignment. For example: module_variable = 1 \"\"\" Docstring for module_variable. \"\"\" class C : class_variable = 2 \"\"\" Docstring for class_variable. \"\"\" def __init__ ( self ) : self . variable = 3 \"\"\" Docstring for instance variable. \"\"\" While the resulting variables have no __doc__ attribute, pdoc compensates by reading the source code (when available) and parsing the syntax tree. By convention, variables defined in a class' __init__ method and attached to self are considered and documented as instance variables. Class and instance variables can also inherit docstrings .","title":"Docstrings for variables"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#overriding-docstrings-with-__pdoc__","text":"Docstrings for objects can be disabled or overridden with a special module-level dictionary __pdoc__ . The keys should be string identifiers within the scope of the module or, alternatively, fully-qualified reference names. E.g. for instance variable self.variable of class C , its module-level identifier is 'C.variable' . If __pdoc__[key] = False , then key (and its members) will be excluded from the documentation of the module. Alternatively, the values of __pdoc__ should be the overriding docstrings. This particular feature is useful when there's no feasible way of attaching a docstring to something. A good example of this is a namedtuple : __pdoc__ = {} Table = namedtuple ( ' Table ' , [ ' types ' , ' names ' , ' rows ' ] ) __pdoc__ [ ' Table.types ' ] = ' Types for each column in the table. ' __pdoc__ [ ' Table.names ' ] = ' The names of each column in the table. ' __pdoc__ [ ' Table.rows ' ] = ' Lists corresponding to each row in the table. ' pdoc will then show Table as a class with documentation for the types , names and rows members. .. note:: The assignments to __pdoc__ need to be placed where they'll be executed when the module is imported. For example, at the top level of a module or in the definition of a class.","title":"Overriding docstrings with __pdoc__"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#supported-docstring-formats","text":"Currently, pure Markdown (with extensions ), numpydoc , and Google-style docstrings formats are supported, along with some reST directives . Additionally, if latex_math template config option is enabled, LaTeX math syntax is supported when placed between recognized delimiters : \\(...\\) for inline equations and \\[...\\] or $$...$$ for block equations. Note, you need to escape your backslashes in Python docstrings ( \\\\( , \\\\frac{}{} , ...) or, alternatively, use raw string literals .","title":"Supported docstring formats"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#supported-rest-directives","text":"The following reST directives should work: specific and generic admonitions , .. image:: or .. figure:: (without options), .. include:: , with support for the options: :start-line: , :end-line: , :start-after: and :end-before: . .. math:: .. versionadded:: .. versionchanged:: .. deprecated:: .. todo::","title":"Supported reST directives"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#linking-to-other-identifiers","text":"In your documentation, you may refer to other identifiers in your modules. When exporting to HTML, linking is automatically done whenever you surround an identifier with backticks ( ` ). The identifier name must be fully qualified, for example `pdoc.Doc.docstring` is correct (and will link to pdoc.Doc.docstring ) while `Doc.docstring` is not .","title":"Linking to other identifiers"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#command-line-interface","text":"pdoc includes a feature-rich \"binary\" program for producing HTML and plain text documentation of your modules. For example, to produce HTML documentation of your whole package in subdirectory 'build' of the current directory, using the default HTML template, run: $ pdoc --html --output-dir build my_package To run a local HTTP server while developing your package or writing docstrings for it, run: $ pdoc --http : my_package To re-build documentation as part of your continuous integration (CI) best practice, i.e. ensuring all reference links are correct and up-to-date, make warnings error loudly by settings the environment variable PYTHONWARNINGS before running pdoc: $ export PYTHONWARNINGS = 'error::UserWarning' For brief usage instructions, type: $ pdoc --help","title":"Command-line interface"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#programmatic-usage","text":"The main entry point is pdoc.Module which wraps a module object and recursively imports and wraps any submodules and their members. After all related modules are wrapped (related modules are those that share the same pdoc.Context ), you need to call pdoc.link_inheritance with the used Context instance to establish class inheritance links. Afterwards, you can use pdoc.Module.html and pdoc.Module.text methods to output documentation in the desired format. For example: import pdoc modules = [ 'a' , 'b' ] # Public submodules are auto-imported context = pdoc . Context () modules = [ pdoc . Module ( mod , context = context ) for mod in modules ] pdoc . link_inheritance ( context ) def recursive_htmls ( mod ): yield mod . name , mod . html () for submod in mod . submodules (): yield from recursive_htmls ( submod ) for mod in modules : for module_name , html in recursive_htmls ( mod ): ... # Process When documenting a single module, you might find functions pdoc.html and pdoc.text handy. For importing arbitrary modules/files, use pdoc.import_module . Alternatively, use the runnable script included with this package.","title":"Programmatic usage"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#custom-templates","text":"To override the built-in HTML/CSS and plain text templates, copy the relevant templates from pdoc/templates directory into a directory of your choosing and edit them. When you run pdoc command afterwards, pass the directory path as a parameter to the --template-dir switch. .. tip:: If you find you only need to apply minor alterations to the HTML template, see if you can do so by overriding just some of the following, placeholder sub-templates: * [ _config . mako_ ]: Basic template configuration , affects the way templates are rendered . * _head . mako_ : Included just before ` </ head > `. Best for adding resources and styles . * _logo . mako_ : Included at the very top of the navigation sidebar . Empty by default . * _credits . mako_ : Included in the footer , right before pdoc version string . See [ default template files ] for reference . .. tip:: You can also alter individual config.mako preferences using the --config command-line switch. If working with pdoc programmatically, prepend the directory with modified templates into the directories list of the pdoc.tpl_lookup object.","title":"Custom templates"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#compatibility","text":"pdoc requires Python 3.5+. The last version to support Python 2.x is pdoc3 0.3.x .","title":"Compatibility"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#contributing","text":"pdoc is on GitHub . Bug reports and pull requests are welcome.","title":"Contributing"},{"location":"venv/lib/python3.7/site-packages/pdoc/documentation/#license","text":"pdoc is licensed under the terms of GNU AGPL-3.0 or later, meaning you can use it for any reasonable purpose and remain in complete ownership of all the documentation you produce, but you are also encouraged to make sure any upgrades to pdoc itself find their way back to the community. Documented modules are executed in order to provide __doc__ attributes. Any non-fenced global code in imported modules will affect the current environment. \u21a9 Here, public API refers to the API that is made available to your project end-users, not the public API e.g. of a private class that can be reasonably extended elsewhere by your project developers. \u21a9 Prefixing private, implementation-specific objects with an underscore is a common convention . \u21a9","title":"License"},{"location":"venv/lib/python3.7/site-packages/pdocs/templates/","text":"The license included in this directory is for HTML5 Boiler Plate . Some of the HTML and CSS used here is derived from that project.","title":"Home"},{"location":"venv/lib/python3.7/site-packages/pep562-1.0.dist-info/LICENSE/","text":"MIT License Copyright (c) 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"venv/lib/python3.7/site-packages/pymdown_extensions-6.1.dist-info/LICENSE/","text":"The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. superfences.py is derived from Python Markdown's fenced_code extension. Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See https://python-markdown.github.io/extensions/fenced_code_blocks/ for documentation. Original code Copyright 2007-2008 Waylan Limberg . All changes Copyright 2008-2014 The Python Markdown Project License: BSD inlinehilite.py is derived from Python Markdown's codehilite extension. CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See https://python-markdown.github.io/extensions/code_hilite/ for documentation. Original code Copyright 2006-2008 Waylan Limberg . All changes Copyright 2008-2014 The Python Markdown Project License: BSD extrarawhtml.py is a literal copy and paste from Python Markdown's extra extension. It basically splits out the raw html markdown parsing into a seprate extension that can be used even if it is not desired to use all of 'extra'. Python-Markdown Extra Extension =============================== See https://python-markdown.github.io/extensions/extra/ for documentation. Copyright The Python Markdown Project License: BSD gemoji_db.py is generated from Gemoji's source code: https://github.com/github/gemoji. Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. emoji1_db.py is generated from EmojiOne's source code: https://github.com/Ranks/emojione EmojiOne Non-Artwork Applies to the Javascript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"LICENSE"},{"location":"venv/lib64/python3.7/site-packages/Markdown-3.1.1.dist-info/LICENSE/","text":"Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Python Markdown Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE PYTHON MARKDOWN PROJECT ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANY CONTRIBUTORS TO THE PYTHON MARKDOWN PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/","text":"pdoc extracts documentation of: modules (including submodules), functions (including methods, properties, coroutines ...), classes, and variables (including globals, class variables, and instance variables). Documentation is extracted from live objects' docstrings using Python's __doc__ attribute 1 . Documentation for variables is found by examining objects' abstract syntax trees. What objects are documented? pdoc only extracts public API documentation. 2 All objects (modules, functions, classes, variables) are only considered public if their identifiers don't begin with an underscore ( _ ). 3 In addition, if a module defines __all__ , then only the identifiers contained in this list will be considered public. Otherwise, a module's global identifiers are considered public only if they don't begin with an underscore and are defined in this exact module (i.e. not imported from somewhere else). By transitivity, sub-objects of non-public objects (e.g. submodules of non-public modules, methods of non-public classes etc.) are not public and thus not documented. Where does pdoc get documentation from? In Python, objects like modules, functions, classes, and methods have a special attribute __doc__ which contains that object's documentation string ( docstring ). For example, the following code defines a function with a docstring and shows how to access its contents: >>> def test (): ... \"\"\"This is a docstring.\"\"\" ... pass ... >>> test . __doc__ 'This is a docstring.' It's pretty much the same with classes and modules. See PEP-257 for Python docstring conventions. These docstrings are set as descriptions for each module, class, function, and method listed in the documentation produced by pdoc . pdoc extends the standard use of docstrings in Python in two important ways: by allowing methods to inherit docstrings, and by introducing syntax for docstrings for variables. Docstrings inheritance pdoc considers methods' docstrings inherited from superclass methods', following the normal class inheritance patterns. Consider the following code example: >>> class A : ... def test ( self ) : ... \"\"\" Docstring for A. \"\"\" ... pass ... >>> class B ( A ) : ... def test ( self ) : ... pass ... >>> A . test . __doc__ ' Docstring for A. ' >>> B . test . __doc__ None In Python, the docstring for B.test doesn't exist, even though a docstring was defined for A.test . When pdoc generates documentation for the code such as above, it will automatically attach the docstring for A.test to B.test if B.test does not define its own docstring. In the default HTML template, such inherited docstrings are greyed out. Docstrings for variables Python by itself doesn't allow docstrings attached to variables . However, pdoc supports docstrings attached to module (or global) variables, class variables, and object instance variables; all in the same way as proposed in PEP-224 , with a docstring following the variable assignment. For example: module_variable = 1 \"\"\" Docstring for module_variable. \"\"\" class C : class_variable = 2 \"\"\" Docstring for class_variable. \"\"\" def __init__ ( self ) : self . variable = 3 \"\"\" Docstring for instance variable. \"\"\" While the resulting variables have no __doc__ attribute, pdoc compensates by reading the source code (when available) and parsing the syntax tree. By convention, variables defined in a class' __init__ method and attached to self are considered and documented as instance variables. Class and instance variables can also inherit docstrings . Overriding docstrings with __pdoc__ Docstrings for objects can be disabled or overridden with a special module-level dictionary __pdoc__ . The keys should be string identifiers within the scope of the module or, alternatively, fully-qualified reference names. E.g. for instance variable self.variable of class C , its module-level identifier is 'C.variable' . If __pdoc__[key] = False , then key (and its members) will be excluded from the documentation of the module. Alternatively, the values of __pdoc__ should be the overriding docstrings. This particular feature is useful when there's no feasible way of attaching a docstring to something. A good example of this is a namedtuple : __pdoc__ = {} Table = namedtuple ( ' Table ' , [ ' types ' , ' names ' , ' rows ' ] ) __pdoc__ [ ' Table.types ' ] = ' Types for each column in the table. ' __pdoc__ [ ' Table.names ' ] = ' The names of each column in the table. ' __pdoc__ [ ' Table.rows ' ] = ' Lists corresponding to each row in the table. ' pdoc will then show Table as a class with documentation for the types , names and rows members. .. note:: The assignments to __pdoc__ need to be placed where they'll be executed when the module is imported. For example, at the top level of a module or in the definition of a class. Supported docstring formats Currently, pure Markdown (with extensions ), numpydoc , and Google-style docstrings formats are supported, along with some reST directives . Additionally, if latex_math template config option is enabled, LaTeX math syntax is supported when placed between recognized delimiters : \\(...\\) for inline equations and \\[...\\] or $$...$$ for block equations. Note, you need to escape your backslashes in Python docstrings ( \\\\( , \\\\frac{}{} , ...) or, alternatively, use raw string literals . Supported reST directives The following reST directives should work: specific and generic admonitions , .. image:: or .. figure:: (without options), .. include:: , with support for the options: :start-line: , :end-line: , :start-after: and :end-before: . .. math:: .. versionadded:: .. versionchanged:: .. deprecated:: .. todo:: Linking to other identifiers In your documentation, you may refer to other identifiers in your modules. When exporting to HTML, linking is automatically done whenever you surround an identifier with backticks ( ` ). The identifier name must be fully qualified, for example `pdoc.Doc.docstring` is correct (and will link to pdoc.Doc.docstring ) while `Doc.docstring` is not . Command-line interface pdoc includes a feature-rich \"binary\" program for producing HTML and plain text documentation of your modules. For example, to produce HTML documentation of your whole package in subdirectory 'build' of the current directory, using the default HTML template, run: $ pdoc --html --output-dir build my_package To run a local HTTP server while developing your package or writing docstrings for it, run: $ pdoc --http : my_package To re-build documentation as part of your continuous integration (CI) best practice, i.e. ensuring all reference links are correct and up-to-date, make warnings error loudly by settings the environment variable PYTHONWARNINGS before running pdoc: $ export PYTHONWARNINGS = 'error::UserWarning' For brief usage instructions, type: $ pdoc --help Programmatic usage The main entry point is pdoc.Module which wraps a module object and recursively imports and wraps any submodules and their members. After all related modules are wrapped (related modules are those that share the same pdoc.Context ), you need to call pdoc.link_inheritance with the used Context instance to establish class inheritance links. Afterwards, you can use pdoc.Module.html and pdoc.Module.text methods to output documentation in the desired format. For example: import pdoc modules = [ 'a' , 'b' ] # Public submodules are auto-imported context = pdoc . Context () modules = [ pdoc . Module ( mod , context = context ) for mod in modules ] pdoc . link_inheritance ( context ) def recursive_htmls ( mod ): yield mod . name , mod . html () for submod in mod . submodules (): yield from recursive_htmls ( submod ) for mod in modules : for module_name , html in recursive_htmls ( mod ): ... # Process When documenting a single module, you might find functions pdoc.html and pdoc.text handy. For importing arbitrary modules/files, use pdoc.import_module . Alternatively, use the runnable script included with this package. Custom templates To override the built-in HTML/CSS and plain text templates, copy the relevant templates from pdoc/templates directory into a directory of your choosing and edit them. When you run pdoc command afterwards, pass the directory path as a parameter to the --template-dir switch. .. tip:: If you find you only need to apply minor alterations to the HTML template, see if you can do so by overriding just some of the following, placeholder sub-templates: * [ _config . mako_ ]: Basic template configuration , affects the way templates are rendered . * _head . mako_ : Included just before ` </ head > `. Best for adding resources and styles . * _logo . mako_ : Included at the very top of the navigation sidebar . Empty by default . * _credits . mako_ : Included in the footer , right before pdoc version string . See [ default template files ] for reference . .. tip:: You can also alter individual config.mako preferences using the --config command-line switch. If working with pdoc programmatically, prepend the directory with modified templates into the directories list of the pdoc.tpl_lookup object. Compatibility pdoc requires Python 3.5+. The last version to support Python 2.x is pdoc3 0.3.x . Contributing pdoc is on GitHub . Bug reports and pull requests are welcome. License pdoc is licensed under the terms of GNU AGPL-3.0 or later, meaning you can use it for any reasonable purpose and remain in complete ownership of all the documentation you produce, but you are also encouraged to make sure any upgrades to pdoc itself find their way back to the community. Documented modules are executed in order to provide __doc__ attributes. Any non-fenced global code in imported modules will affect the current environment. \u21a9 Here, public API refers to the API that is made available to your project end-users, not the public API e.g. of a private class that can be reasonably extended elsewhere by your project developers. \u21a9 Prefixing private, implementation-specific objects with an underscore is a common convention . \u21a9","title":"Documentation"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#what-objects-are-documented","text":"pdoc only extracts public API documentation. 2 All objects (modules, functions, classes, variables) are only considered public if their identifiers don't begin with an underscore ( _ ). 3 In addition, if a module defines __all__ , then only the identifiers contained in this list will be considered public. Otherwise, a module's global identifiers are considered public only if they don't begin with an underscore and are defined in this exact module (i.e. not imported from somewhere else). By transitivity, sub-objects of non-public objects (e.g. submodules of non-public modules, methods of non-public classes etc.) are not public and thus not documented.","title":"What objects are documented?"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#where-does-pdoc-get-documentation-from","text":"In Python, objects like modules, functions, classes, and methods have a special attribute __doc__ which contains that object's documentation string ( docstring ). For example, the following code defines a function with a docstring and shows how to access its contents: >>> def test (): ... \"\"\"This is a docstring.\"\"\" ... pass ... >>> test . __doc__ 'This is a docstring.' It's pretty much the same with classes and modules. See PEP-257 for Python docstring conventions. These docstrings are set as descriptions for each module, class, function, and method listed in the documentation produced by pdoc . pdoc extends the standard use of docstrings in Python in two important ways: by allowing methods to inherit docstrings, and by introducing syntax for docstrings for variables.","title":"Where does pdoc get documentation from?"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#docstrings-inheritance","text":"pdoc considers methods' docstrings inherited from superclass methods', following the normal class inheritance patterns. Consider the following code example: >>> class A : ... def test ( self ) : ... \"\"\" Docstring for A. \"\"\" ... pass ... >>> class B ( A ) : ... def test ( self ) : ... pass ... >>> A . test . __doc__ ' Docstring for A. ' >>> B . test . __doc__ None In Python, the docstring for B.test doesn't exist, even though a docstring was defined for A.test . When pdoc generates documentation for the code such as above, it will automatically attach the docstring for A.test to B.test if B.test does not define its own docstring. In the default HTML template, such inherited docstrings are greyed out.","title":"Docstrings inheritance"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#docstrings-for-variables","text":"Python by itself doesn't allow docstrings attached to variables . However, pdoc supports docstrings attached to module (or global) variables, class variables, and object instance variables; all in the same way as proposed in PEP-224 , with a docstring following the variable assignment. For example: module_variable = 1 \"\"\" Docstring for module_variable. \"\"\" class C : class_variable = 2 \"\"\" Docstring for class_variable. \"\"\" def __init__ ( self ) : self . variable = 3 \"\"\" Docstring for instance variable. \"\"\" While the resulting variables have no __doc__ attribute, pdoc compensates by reading the source code (when available) and parsing the syntax tree. By convention, variables defined in a class' __init__ method and attached to self are considered and documented as instance variables. Class and instance variables can also inherit docstrings .","title":"Docstrings for variables"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#overriding-docstrings-with-__pdoc__","text":"Docstrings for objects can be disabled or overridden with a special module-level dictionary __pdoc__ . The keys should be string identifiers within the scope of the module or, alternatively, fully-qualified reference names. E.g. for instance variable self.variable of class C , its module-level identifier is 'C.variable' . If __pdoc__[key] = False , then key (and its members) will be excluded from the documentation of the module. Alternatively, the values of __pdoc__ should be the overriding docstrings. This particular feature is useful when there's no feasible way of attaching a docstring to something. A good example of this is a namedtuple : __pdoc__ = {} Table = namedtuple ( ' Table ' , [ ' types ' , ' names ' , ' rows ' ] ) __pdoc__ [ ' Table.types ' ] = ' Types for each column in the table. ' __pdoc__ [ ' Table.names ' ] = ' The names of each column in the table. ' __pdoc__ [ ' Table.rows ' ] = ' Lists corresponding to each row in the table. ' pdoc will then show Table as a class with documentation for the types , names and rows members. .. note:: The assignments to __pdoc__ need to be placed where they'll be executed when the module is imported. For example, at the top level of a module or in the definition of a class.","title":"Overriding docstrings with __pdoc__"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#supported-docstring-formats","text":"Currently, pure Markdown (with extensions ), numpydoc , and Google-style docstrings formats are supported, along with some reST directives . Additionally, if latex_math template config option is enabled, LaTeX math syntax is supported when placed between recognized delimiters : \\(...\\) for inline equations and \\[...\\] or $$...$$ for block equations. Note, you need to escape your backslashes in Python docstrings ( \\\\( , \\\\frac{}{} , ...) or, alternatively, use raw string literals .","title":"Supported docstring formats"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#supported-rest-directives","text":"The following reST directives should work: specific and generic admonitions , .. image:: or .. figure:: (without options), .. include:: , with support for the options: :start-line: , :end-line: , :start-after: and :end-before: . .. math:: .. versionadded:: .. versionchanged:: .. deprecated:: .. todo::","title":"Supported reST directives"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#linking-to-other-identifiers","text":"In your documentation, you may refer to other identifiers in your modules. When exporting to HTML, linking is automatically done whenever you surround an identifier with backticks ( ` ). The identifier name must be fully qualified, for example `pdoc.Doc.docstring` is correct (and will link to pdoc.Doc.docstring ) while `Doc.docstring` is not .","title":"Linking to other identifiers"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#command-line-interface","text":"pdoc includes a feature-rich \"binary\" program for producing HTML and plain text documentation of your modules. For example, to produce HTML documentation of your whole package in subdirectory 'build' of the current directory, using the default HTML template, run: $ pdoc --html --output-dir build my_package To run a local HTTP server while developing your package or writing docstrings for it, run: $ pdoc --http : my_package To re-build documentation as part of your continuous integration (CI) best practice, i.e. ensuring all reference links are correct and up-to-date, make warnings error loudly by settings the environment variable PYTHONWARNINGS before running pdoc: $ export PYTHONWARNINGS = 'error::UserWarning' For brief usage instructions, type: $ pdoc --help","title":"Command-line interface"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#programmatic-usage","text":"The main entry point is pdoc.Module which wraps a module object and recursively imports and wraps any submodules and their members. After all related modules are wrapped (related modules are those that share the same pdoc.Context ), you need to call pdoc.link_inheritance with the used Context instance to establish class inheritance links. Afterwards, you can use pdoc.Module.html and pdoc.Module.text methods to output documentation in the desired format. For example: import pdoc modules = [ 'a' , 'b' ] # Public submodules are auto-imported context = pdoc . Context () modules = [ pdoc . Module ( mod , context = context ) for mod in modules ] pdoc . link_inheritance ( context ) def recursive_htmls ( mod ): yield mod . name , mod . html () for submod in mod . submodules (): yield from recursive_htmls ( submod ) for mod in modules : for module_name , html in recursive_htmls ( mod ): ... # Process When documenting a single module, you might find functions pdoc.html and pdoc.text handy. For importing arbitrary modules/files, use pdoc.import_module . Alternatively, use the runnable script included with this package.","title":"Programmatic usage"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#custom-templates","text":"To override the built-in HTML/CSS and plain text templates, copy the relevant templates from pdoc/templates directory into a directory of your choosing and edit them. When you run pdoc command afterwards, pass the directory path as a parameter to the --template-dir switch. .. tip:: If you find you only need to apply minor alterations to the HTML template, see if you can do so by overriding just some of the following, placeholder sub-templates: * [ _config . mako_ ]: Basic template configuration , affects the way templates are rendered . * _head . mako_ : Included just before ` </ head > `. Best for adding resources and styles . * _logo . mako_ : Included at the very top of the navigation sidebar . Empty by default . * _credits . mako_ : Included in the footer , right before pdoc version string . See [ default template files ] for reference . .. tip:: You can also alter individual config.mako preferences using the --config command-line switch. If working with pdoc programmatically, prepend the directory with modified templates into the directories list of the pdoc.tpl_lookup object.","title":"Custom templates"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#compatibility","text":"pdoc requires Python 3.5+. The last version to support Python 2.x is pdoc3 0.3.x .","title":"Compatibility"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#contributing","text":"pdoc is on GitHub . Bug reports and pull requests are welcome.","title":"Contributing"},{"location":"venv/lib64/python3.7/site-packages/pdoc/documentation/#license","text":"pdoc is licensed under the terms of GNU AGPL-3.0 or later, meaning you can use it for any reasonable purpose and remain in complete ownership of all the documentation you produce, but you are also encouraged to make sure any upgrades to pdoc itself find their way back to the community. Documented modules are executed in order to provide __doc__ attributes. Any non-fenced global code in imported modules will affect the current environment. \u21a9 Here, public API refers to the API that is made available to your project end-users, not the public API e.g. of a private class that can be reasonably extended elsewhere by your project developers. \u21a9 Prefixing private, implementation-specific objects with an underscore is a common convention . \u21a9","title":"License"},{"location":"venv/lib64/python3.7/site-packages/pdocs/templates/","text":"The license included in this directory is for HTML5 Boiler Plate . Some of the HTML and CSS used here is derived from that project.","title":"Home"},{"location":"venv/lib64/python3.7/site-packages/pep562-1.0.dist-info/LICENSE/","text":"MIT License Copyright (c) 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"venv/lib64/python3.7/site-packages/pymdown_extensions-6.1.dist-info/LICENSE/","text":"The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. superfences.py is derived from Python Markdown's fenced_code extension. Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See https://python-markdown.github.io/extensions/fenced_code_blocks/ for documentation. Original code Copyright 2007-2008 Waylan Limberg . All changes Copyright 2008-2014 The Python Markdown Project License: BSD inlinehilite.py is derived from Python Markdown's codehilite extension. CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See https://python-markdown.github.io/extensions/code_hilite/ for documentation. Original code Copyright 2006-2008 Waylan Limberg . All changes Copyright 2008-2014 The Python Markdown Project License: BSD extrarawhtml.py is a literal copy and paste from Python Markdown's extra extension. It basically splits out the raw html markdown parsing into a seprate extension that can be used even if it is not desired to use all of 'extra'. Python-Markdown Extra Extension =============================== See https://python-markdown.github.io/extensions/extra/ for documentation. Copyright The Python Markdown Project License: BSD gemoji_db.py is generated from Gemoji's source code: https://github.com/github/gemoji. Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. emoji1_db.py is generated from EmojiOne's source code: https://github.com/Ranks/emojione EmojiOne Non-Artwork Applies to the Javascript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"LICENSE"}]}